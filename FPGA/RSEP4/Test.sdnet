
struct switch_metadata_t {
  ingress_port : 4,
  egress_port : 4 }
struct veth_h {
  isValid : 1,
  dst : 48,
  src : 48,
  vx : 1,
  type : 15 }
struct vid_h {
  isValid : 1,
  id : 24 }
struct payload_h {
  isValid : 1,
  data : 256 }
struct encoded_payload_h {
  isValid : 1,
  data : 368 }
struct state_h {
  isValid : 1,
  dummy : 1,
  encoded : 1,
  fec_data : 1 }
struct headers_t {
  veth : veth_h,
  vid : vid_h,
  state : state_h }
class ioports_t::Tuple(inout) {
  struct {
    ingress_port : 4,
    egress_port : 4 } }
class Parser_t::ParsingEngine(12144,3,start) {
  class hdr_t::Tuple(out) {
    struct {
      veth : veth_h,
      vid : vid_h,
      state : state_h } }
  class Parser_extracts_t::Tuple(out) {
    struct {
      size : 32 } }
  hdr_t hdr;
  Parser_extracts_t Parser_extracts;
  class start::Section(1) {
    struct {
      dst_0 : 48,
      src_0 : 48,
      vx_0 : 1,
      type_0 : 15 }
    map transition_0 {
      (0, extract_payload),
      (1, parse_veth),
      accept }
    method update = {
      hdr.veth.isValid = 1,
      hdr.veth.dst = dst_0,
      hdr.veth.src = src_0,
      hdr.veth.vx = vx_0,
      hdr.veth.type = type_0,
      Parser_extracts.size = (Parser_extracts.size + 112) }
    method move_to_section = transition_0(vx_0);
    method increment_offset = 112; }
  class parse_veth::Section(2) {
    method move_to_section = accept;
    method increment_offset = 0; }
  class extract_payload::Section(2) {
    method move_to_section = accept;
    method increment_offset = 0; }
  class accept::Section(3) {
    method move_to_section = done(0);
    method increment_offset = 0; }
  class reject::Section {
    method move_to_section = done(0);
    method increment_offset = 0; } }
class Forward_lvl_t::TupleEngine(1,setup) {
  class Forward_fl_t::Tuple(out) {
    struct {
      index_1 : 32,
      max_1 : 32,
      index_new : 32,
      addr_1 : 32,
      op : 8,
      tmp_1 : 32,
      tmp_2 : 1 } }
  class hdr_t_0::Tuple(inout) {
    struct {
      veth : veth_h,
      vid : vid_h,
      state : state_h } }
  class ioports_t::Tuple(inout) {
    struct {
      ingress_port : 4,
      egress_port : 4 } }
  class local_state_t::Tuple(out) {
    struct {
      id : 16 } }
  Forward_fl_t Forward_fl;
  hdr_t_0 hdr;
  ioports_t ioports;
  local_state_t local_state;
  class setup::Section(1) {
    method move_to_section = done(0);
    method increment_offset = 0; } }
class Forward_lvl_0_t::TupleEngine(5,act_1_sec) {
  class Forward_fl_t::Tuple(inout) {
    struct {
      index_1 : 32,
      max_1 : 32,
      index_new : 32,
      addr_1 : 32,
      op : 8,
      tmp_1 : 32,
      tmp_2 : 1 } }
  class hdr_t_0::Tuple(inout) {
    struct {
      veth : veth_h,
      vid : vid_h,
      state : state_h } }
  class ioports_t::Tuple(inout) {
    struct {
      ingress_port : 4,
      egress_port : 4 } }
  class local_state_t::Tuple(inout) {
    struct {
      id : 16 } }
  class loop_input_t::Tuple(out) {
    struct {
      stateful_valid_0 : 1,
      addr : 32,
      max : 32 } }
  Forward_fl_t Forward_fl;
  hdr_t_0 hdr;
  ioports_t ioports;
  local_state_t local_state;
  loop_input_t loop_input;
  class act_0_sec::Section(3) {
    method update = {
      Forward_fl.op = 4,
      Forward_fl.addr_1 = 2,
      Forward_fl.max_1 = 4 }
    method move_to_section = act_7_sec;
    method increment_offset = 0; }
  class act_1_sec::Section(1) {
    method update = {
      hdr.state.encoded = 0,
      hdr.state.fec_data = 0 }
    method move_to_section = condition_sec_2;
    method increment_offset = 0; }
  class act_7_sec::Section(4) {
    method update = {
      loop_input.stateful_valid_0 = 1,
      loop_input.addr = Forward_fl.addr_1,
      loop_input.max = Forward_fl.max_1,
      local_state.id = 6 }
    method move_to_section = local_end;
    method increment_offset = 0; }
  class act_sec::Section(3) {
    method update = {
      Forward_fl.op = 1,
      Forward_fl.addr_1 = 1,
      Forward_fl.max_1 = 8 }
    method move_to_section = act_7_sec;
    method increment_offset = 0; }
  class condition_sec_2::Section(2) {
    method move_to_section = if ((hdr.veth.vx == 0)) act_sec else act_0_sec;
    method increment_offset = 0; }
  class local_end::Section(5) {
    method move_to_section = done(0);
    method increment_offset = 0; } }
class loop_0_t::UserEngine(100, 0) {
  class loop_input_t::Tuple(in) {
    struct {
      stateful_valid_0 : 1,
      addr : 32,
      max : 32 } }
  loop_input_t loop_input;
  class loop_output_t::Tuple(out) {
    struct {
      result_0 : 32 } }
  loop_output_t loop_output; }
class Forward_lvl_1_t::TupleEngine(10,local_start) {
  class Forward_fl_t::Tuple(inout) {
    struct {
      index_1 : 32,
      max_1 : 32,
      index_new : 32,
      addr_1 : 32,
      op : 8,
      tmp_1 : 32,
      tmp_2 : 1 } }
  class hdr_t_0::Tuple(inout) {
    struct {
      veth : veth_h,
      vid : vid_h,
      state : state_h } }
  class ioports_t::Tuple(inout) {
    struct {
      ingress_port : 4,
      egress_port : 4 } }
  class local_state_t::Tuple(inout) {
    struct {
      id : 16 } }
  class fec_input_t::Tuple(out) {
    struct {
      stateful_valid : 1,
      operation : 8,
      index : 32 } }
  class loop_output_t::Tuple(in) {
    struct {
      result_0 : 32 } }
  Forward_fl_t Forward_fl;
  hdr_t_0 hdr;
  ioports_t ioports;
  local_state_t local_state;
  fec_input_t fec_input;
  loop_output_t loop_output;
  class act_2_sec::Section(7) {
    method update = {
      Forward_fl.op = (Forward_fl.op | 2),
      ioports.egress_port = 13,
      hdr.veth.vx = 1,
      hdr.state.encoded = 0 }
    method move_to_section = act_8_sec;
    method increment_offset = 0; }
  class act_3_sec::Section(5) {
    method update = {
      hdr.veth.vx = 1,
      hdr.vid.id = Forward_fl.index_1,
      hdr.state.fec_data = 1,
      Forward_fl.index_new = (Forward_fl.index_1 + 1) }
    method move_to_section = condition_sec;
    method increment_offset = 0; }
  class act_4_sec::Section(7) {
    method update = {
      ioports.egress_port = 13 }
    method move_to_section = act_6_sec;
    method increment_offset = 0; }
  class act_5_sec::Section(5) {
    method update = {
      Forward_fl.index_1 = (Forward_fl.index_1 + 8),
      Forward_fl.index_new = ((Forward_fl.index_1 + 8) + 1) }
    method move_to_section = condition_sec_0;
    method increment_offset = 0; }
  class act_6_sec::Section(8) {
    method update = {
      hdr.state.encoded = 1,
      hdr.veth.vx = 1,
      hdr.vid.id = ((hdr.veth.dst & 8388607) | 8388608) }
    method move_to_section = act_8_sec;
    method increment_offset = 0; }
  class act_8_sec::Section(9) {
    method update = {
      fec_input.stateful_valid = 1,
      fec_input.operation = Forward_fl.op,
      fec_input.index = Forward_fl.index_1,
      local_state.id = 17 }
    method move_to_section = local_end_0;
    method increment_offset = 0; }
  class condition_sec::Section(6) {
    method move_to_section = if ((Forward_fl.index_new >= 8)) act_2_sec else act_8_sec;
    method increment_offset = 0; }
  class condition_sec_0::Section(6) {
    method move_to_section = if ((Forward_fl.index_new == 12)) act_6_sec else act_4_sec;
    method increment_offset = 0; }
  class condition_sec_1::Section(4) {
    method move_to_section = if ((hdr.veth.vx == 0)) act_3_sec else act_5_sec;
    method increment_offset = 0; }
  class local_end_0::Section(10) {
    method move_to_section = done(0);
    method increment_offset = 0; }
  class local_start::Section(1) {
    map transition {
      (6, loop_sec),
      local_end_0 }
    method move_to_section = transition(local_state.id);
    method increment_offset = 0; }
  class loop_sec::Section(2) {
    method update = {
      Forward_fl.tmp_1 = loop_output.result_0 }
    method move_to_section = split_act_sec;
    method increment_offset = 0; }
  class split_act_sec::Section(3) {
    method update = {
      Forward_fl.index_1 = Forward_fl.tmp_1 }
    method move_to_section = condition_sec_1;
    method increment_offset = 0; } }
class fec_0_t::UserEngine(100, 0) {
  class fec_input_t::Tuple(in) {
    struct {
      stateful_valid : 1,
      operation : 8,
      index : 32 } }
  fec_input_t fec_input;
  class fec_output_t::Tuple(out) {
    struct {
      result : 1 } }
  fec_output_t fec_output; }
class Forward_lvl_2_t::TupleEngine(4,local_start_0) {
  class Forward_fl_t::Tuple(in) {
    struct {
      index_1 : 32,
      max_1 : 32,
      index_new : 32,
      addr_1 : 32,
      op : 8,
      tmp_1 : 32,
      tmp_2 : 1 } }
  class hdr_t_0::Tuple(inout) {
    struct {
      veth : veth_h,
      vid : vid_h,
      state : state_h } }
  class ioports_t::Tuple(inout) {
    struct {
      ingress_port : 4,
      egress_port : 4 } }
  class local_state_t::Tuple(in) {
    struct {
      id : 16 } }
  class fec_output_t::Tuple(in) {
    struct {
      result : 1 } }
  Forward_fl_t Forward_fl;
  hdr_t_0 hdr;
  ioports_t ioports;
  local_state_t local_state;
  fec_output_t fec_output;
  class fec_sec::Section(2) {
    method update = {
      Forward_fl.tmp_2 = fec_output.result }
    method move_to_section = split_act_0_sec;
    method increment_offset = 0; }
  class local_start_0::Section(1) {
    map transition {
      (17, fec_sec),
      done(0) }
    method move_to_section = transition(local_state.id);
    method increment_offset = 0; }
  class sink::Section(4) {
    method move_to_section = done(0);
    method increment_offset = 0; }
  class split_act_0_sec::Section(3) {
    method update = {
      hdr.state.dummy = Forward_fl.tmp_2 }
    method move_to_section = sink;
    method increment_offset = 0; } }
class Deparser_t::EditingEngine(12144,9,extract_headers_sec) {
  class hdr_t_1::Tuple(in) {
    struct {
      veth : veth_h,
      vid : vid_h,
      state : state_h } }
  class Deparser_extracts_t::Tuple(in) {
    struct {
      size : 32 } }
  hdr_t_1 hdr;
  Deparser_extracts_t Deparser_extracts;
  class act_10_sec::Section(2) {
    method move_to_section = emit_2;
    method increment_offset = 0; }
  class act_11_sec::Section(8) {
    method move_to_section = emit_0;
    method increment_offset = 0; }
  class act_9_sec::Section(5) {
    method move_to_section = emit_1;
    method increment_offset = 0; }
  class condition_sec_3::Section(7) {
    method move_to_section = if ((hdr.state.fec_data == 1)) act_11_sec else done(0);
    method increment_offset = 0; }
  class condition_sec_4::Section(4) {
    method move_to_section = if ((hdr.veth.vx == 1)) act_9_sec else condition_sec_3;
    method increment_offset = 0; }
  class emit_0::Section(9) {
    struct {
      dst : 48,
      src : 48,
      vx : 1,
      type : 15 }
    method insert = if (hdr.veth.isValid) 112 else 0;
    method update = {
      dst = hdr.veth.dst,
      src = hdr.veth.src,
      vx = hdr.veth.vx,
      type = hdr.veth.type }
    method move_to_section = done(0);
    method increment_offset = 0; }
  class emit_1::Section(6) {
    struct {
      id : 24 }
    method insert = if (hdr.vid.isValid) 24 else 0;
    method update = {
      id = hdr.vid.id }
    method move_to_section = condition_sec_3;
    method increment_offset = 0; }
  class emit_2::Section(3) {
    struct {
      dst : 48,
      src : 48,
      vx : 1,
      type : 15 }
    method insert = if (hdr.veth.isValid) 112 else 0;
    method update = {
      dst = hdr.veth.dst,
      src = hdr.veth.src,
      vx = hdr.veth.vx,
      type = hdr.veth.type }
    method move_to_section = condition_sec_4;
    method increment_offset = 0; }
  class extract_headers_sec::Section(1) {
    method remove = Deparser_extracts.size;
    method move_to_section = act_10_sec;
    method increment_offset = 0; } }
class Packet_input::Packet(in) {}
class Packet_output::Packet(out) {}
class XilinxSwitch::System {
  ioports_t ioports;
  Parser_t Parser;
  Forward_lvl_t Forward_lvl;
  Forward_lvl_0_t Forward_lvl_0;
  loop_0_t loop_0;
  Forward_lvl_1_t Forward_lvl_1;
  fec_0_t fec_0;
  Forward_lvl_2_t Forward_lvl_2;
  Deparser_t Deparser;
  Packet_input packet_in;
  Packet_output packet_out;
  method connect = {
    Forward_lvl_0.Forward_fl = Forward_lvl.Forward_fl,
    Forward_lvl_0.hdr = Forward_lvl.hdr,
    Forward_lvl_0.ioports = Forward_lvl.ioports,
    Forward_lvl_0.local_state = Forward_lvl.local_state,
    Forward_lvl_1.Forward_fl = Forward_lvl_0.Forward_fl,
    Forward_lvl_1.hdr = Forward_lvl_0.hdr,
    Forward_lvl_1.ioports = Forward_lvl_0.ioports,
    Forward_lvl_1.local_state = Forward_lvl_0.local_state,
    loop_0.loop_input = Forward_lvl_0.loop_input,
    Forward_lvl_1.loop_output = loop_0.loop_output,
    Forward_lvl_2.Forward_fl = Forward_lvl_1.Forward_fl,
    Forward_lvl_2.hdr = Forward_lvl_1.hdr,
    Forward_lvl_2.ioports = Forward_lvl_1.ioports,
    Forward_lvl_2.local_state = Forward_lvl_1.local_state,
    fec_0.fec_input = Forward_lvl_1.fec_input,
    Forward_lvl_2.fec_output = fec_0.fec_output,
    Forward_lvl.hdr = Parser.hdr,
    Deparser.hdr = Forward_lvl_2.hdr,
    Forward_lvl.ioports = ioports,
    ioports = Forward_lvl_2.ioports,
    Parser.packet_in = packet_in,
    Deparser.packet_in = Parser.packet_out,
    packet_out = Deparser.packet_out,
    Deparser.Deparser_extracts = Parser.Parser_extracts } }