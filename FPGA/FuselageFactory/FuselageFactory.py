#!/usr/bin/env python3
"""
Tool for generating fuselage (interface between P4 and HLS C/C++).
"""

import argparse, os.path, re
from collections import OrderedDict

def main():
  """
  Main function
  """
  print('Fuselage Factory')
  print('================\n')

  parser = argparse.ArgumentParser()
  parser.add_argument('stubFilename', help = 'Verilog external function stub')
  parser.add_argument('fuselageFilename', help = 'Output fuselage file')
  parser.add_argument('headerFilename', help = 'Output HLS C/C++ header')
  parser.add_argument('hlsFilename', help = 'Output HLS C/C++ external function stub')
  args = parser.parse_args()

  parseInfo = parseStub(args.stubFilename)
  generateFuselage(parseInfo, args.fuselageFilename)
  generateHeader(parseInfo, args.headerFilename)
  print('Your fuselage has been completed.  Be aware that it is not airworthy yet!')

  if (args.hlsFilename != None):
    generateStub(parseInfo, args.hlsFilename, args.headerFilename)

def parseStub(filename):
  print('Checking pilot license...')
  with open(filename, 'rt') as stubFile:
    content = stubFile.read()
  result = re.search(r'module (\S+) \(\n(.*?)\n\);', content, re.MULTILINE | re.DOTALL)
  parseInfo = {'module': result.group(1), 'ports': result.group(2)}
  parseInfo['io'] = re.search(r'(^input clk_line.*wire.*?$)', content, re.MULTILINE | re.DOTALL).group(1)
  extractTuples(parseInfo, content)
  parseInfo['function'] = re.match(r'(\S+)_.*_.*', parseInfo['module']).group(1)
  return parseInfo

def extractTuples(parseInfo, content):
  for direction in ['in', 'out']:
    tuples = OrderedDict()
    for line in parseInfo['io'].split('\n'):
      result = re.match(r'\S+ \[(\S+):0\] (tuple_' + direction + '_\S+)_DATA', line)
      if result != None:
        name = result.group(2)
        width = int(result.group(1)) + 1
        tuples[name] = OrderedDict([('width', width)])
    for tuple in tuples:
      pattern = r'/\* Tuple format for ' + direction + 'put: ' + tuple + '\n(.*?)\n\n\*/'
      result = re.search(pattern, content, re.MULTILINE | re.DOTALL)
      if result == None:
        continue
      lines = result.group(1)
      fields = OrderedDict()
      for line in lines.split('\n'):
        result = re.match('\s+\[(\S+):\S+\]\s+:\s+(\S+)', line)
        fields[result.group(2)] = int(result.group(1)) + 1
      offset = 0
      for name, width in reversed(list(fields.items())):
        fields[name] -= offset
        offset = width
      tuples[tuple]['fields'] = fields
    parseInfo[direction + 'put_tuples'] = tuples

def generateFuselage(parseInfo, filename):
  print('Please wait while a fuselage is built...')

  with open(filename, "wt") as outputFile:
    outputFile.write('// Code generated by the Fuselage Factory\n\n')
    outputFile.write('// WE DISCOURAGE MODIFYING THIS FILE DIRECTLY!!!\n\n')

    outputFile.write('`timescale 1 ps / 1 ps\n\n')

    outputFile.write('module ' + parseInfo['module'] + ' (\n')
    outputFile.write(parseInfo['ports'] + ',\n')
    outputFile.write('\tbackpressure_in,\n')
    outputFile.write('\tbackpressure_out\n')
    outputFile.write(');\n\n')

    outputFile.write(parseInfo['io'] + '\n\n')

    writeWires(parseInfo, outputFile)

    writeFunction(parseInfo, outputFile)

    writePacketFIFO(outputFile)

    for tuple in parseInfo['input_tuples'].keys():
      writeTupleFIFO(tuple, parseInfo['input_tuples'][tuple], outputFile)

    writeLogic(outputFile)

def writeWires(parseInfo, outputFile):
  for tuple, info in parseInfo['input_tuples'].items():
    outputFile.write('wire [' + str(info['width'] - 1) + ':0] ' + tuple + '_dout;\n')
    outputFile.write('wire ' + tuple + '_empty;\n')
    outputFile.write('wire ' + tuple + '_read;\n')
  outputFile.write('wire [70:0] packet_fifo_din;\n\n')
  outputFile.write('wire [70:0] packet_fifo_dout;\n')
  outputFile.write('wire packet_fifo_rd_en;\n')
  outputFile.write('wire packet_fifo_empty;\n')
  outputFile.write('wire [70:0] packet_out;\n')
  outputFile.write('wire packet_out_ap_vld;\n')

def writeFunction(parseInfo, outputFile):
  outputFile.write(parseInfo['function'] + ' ' + parseInfo['function'] + '_inst\n')
  outputFile.write('(\n')
  outputFile.write('  .ap_clk(clk_line),\n')
  outputFile.write('  .ap_rst(rst),\n')
  outputFile.write('  .ap_start(1),\n')
  outputFile.write('  .ap_done(),\n')
  outputFile.write('  .ap_idle(),\n')
  outputFile.write('  .ap_ready(),\n')
  for tuple in parseInfo['input_tuples'].keys():
    outputFile.write('  .' + tuple + '_V_dout(' + tuple + '_dout),\n')
    outputFile.write('  .' + tuple + '_V_empty_n(~' + tuple + '_empty),\n')
    outputFile.write('  .' + tuple + '_V_read(' + tuple + '_read),\n')
  for tuple in parseInfo['output_tuples'].keys():
    outputFile.write('  .' + tuple + '_V(tuple_out_' + tuple + '_DATA),\n')
    outputFile.write('  .' + tuple + '_V_ap_vld(tuple_out_' + tuple + '_VALID),\n')
    outputFile.write('  .' + tuple + '_V_ap_ack(1),\n')
  outputFile.write('  .packet_in_V_dout(packet_fifo_dout),\n')
  outputFile.write('  .packet_in_V_empty_n(~packet_fifo_empty),\n')
  outputFile.write('  .packet_in_V_read(packet_fifo_rd_en),\n')
  outputFile.write('  .packet_out_V(packet_out),\n')
  outputFile.write('  .packet_out_V_ap_vld(packet_out_ap_vld),\n')
  outputFile.write('  .packet_out_V_ap_ack(~backpressure_in),\n')
  outputFile.write(');\n\n')

def writeTupleFIFO(tuple, dataWidth, outputFile):
  outputFile.write('defparam tuple_fifo.WRITE_DATA_WIDTH = ' + str(dataWidth) + ';\n');
  outputFile.write('defparam tuple_fifo.FIFO_WRITE_DEPTH = 512;\n');
  outputFile.write('defparam tuple_fifo.PROG_FULL_THRESH = 287;\n');
  outputFile.write('defparam tuple_fifo.PROG_EMPTY_THRESH = 287;\n');
  outputFile.write('defparam tuple_fifo.READ_MODE = "fwft";\n');
  outputFile.write('defparam tuple_fifo.WR_DATA_COUNT_WIDTH = 9;\n');
  outputFile.write('defparam tuple_fifo.RD_DATA_COUNT_WIDTH = 9;\n');
  outputFile.write('defparam tuple_fifo.DOUT_RESET_VALUE = "0";\n');
  outputFile.write('defparam tuple_fifo.FIFO_MEMORY_TYPE = "bram";\n\n');
  outputFile.write('xpm_fifo_sync tuple_in_' + tuple + '_fifo (\n')
  outputFile.write('\t.wr_en(tuple_in_' + tuple + '_VALID),\n')
  outputFile.write('\t.din(tuple_in_' + tuple + '_DATA),\n')
  outputFile.write('\t.rd_en(' + tuple + '_read),\n')
  outputFile.write('\t.sleep(1\'b0),\n')
  outputFile.write('\t.injectsbiterr(),\n')
  outputFile.write('\t.injectdbiterr(),\n')
  outputFile.write('\t.prog_empty(),\n')
  outputFile.write('\t.dout(' + tuple + '_dout), \n')
  outputFile.write('\t.empty(' + tuple + '_empty), \n')
  outputFile.write('\t.prog_full(),\n')
  outputFile.write('\t.full(),\n')
  outputFile.write('\t.rd_data_count(),\n')
  outputFile.write('\t.wr_data_count(),\n') 
  outputFile.write('\t.wr_rst_busy(),\n')
  outputFile.write('\t.rd_rst_busy(),\n') 
  outputFile.write('\t.overflow(),\n')
  outputFile.write('\t.underflow(),\n')
  outputFile.write('\t.sbiterr(),\n')
  outputFile.write('\t.dbiterr(),\n') 
  outputFile.write('\t.wr_clk(clk_line),\n')
  outputFile.write('\t.rst(rst)\n')
  outputFile.write(');\n\n')

def writePacketFIFO(outputFile):
  outputFile.write('defparam tuple_fifo.WRITE_DATA_WIDTH = 71;\n');
  outputFile.write('defparam tuple_fifo.FIFO_WRITE_DEPTH = 512;\n');
  outputFile.write('defparam tuple_fifo.PROG_FULL_THRESH = 287;\n');
  outputFile.write('defparam tuple_fifo.PROG_EMPTY_THRESH = 287;\n');
  outputFile.write('defparam tuple_fifo.READ_MODE = "fwft";\n');
  outputFile.write('defparam tuple_fifo.WR_DATA_COUNT_WIDTH = 9;\n');
  outputFile.write('defparam tuple_fifo.RD_DATA_COUNT_WIDTH = 9;\n');
  outputFile.write('defparam tuple_fifo.DOUT_RESET_VALUE = "0";\n');
  outputFile.write('defparam tuple_fifo.FIFO_MEMORY_TYPE = "bram";\n\n');
  outputFile.write('xpm_fifo_sync packet_fifo (\n')
  outputFile.write('\t.wr_en(packet_in_packet_in_VAL),\n')
  outputFile.write('\t.din(packet_fifo_din),\n')
  outputFile.write('\t.rd_en(packet_fifo_rd_en),\n')
  outputFile.write('\t.sleep(1\'b0),\n')
  outputFile.write('\t.injectsbiterr(),\n')
  outputFile.write('\t.injectdbiterr(),\n')
  outputFile.write('\t.prog_empty(),\n')
  outputFile.write('\t.dout(packet_fifo_dout), \n')
  outputFile.write('\t.empty(packet_fifo_empty), \n')
  outputFile.write('\t.prog_full(backpressure_out),\n')
  outputFile.write('\t.full(),\n')
  outputFile.write('\t.rd_data_count(),\n')
  outputFile.write('\t.wr_data_count(),\n') 
  outputFile.write('\t.wr_rst_busy(),\n')
  outputFile.write('\t.rd_rst_busy(),\n') 
  outputFile.write('\t.overflow(),\n')
  outputFile.write('\t.underflow(),\n')
  outputFile.write('\t.sbiterr(),\n')
  outputFile.write('\t.dbiterr(),\n') 
  outputFile.write('\t.wr_clk(clk_line),\n')
  outputFile.write('\t.rst(rst)\n')
  outputFile.write(');\n\n')

def writeLogic(outputFile):
  outputFile.write('assign packet_fifo_din = {packet_in_packet_in_SOF, packet_in_packet_in_EOF, packet_in_packet_in_DAT,\n')
  outputFile.write('                          packet_in_packet_in_CNT, packet_in_packet_in_ERR};\n')
  outputFile.write('assign {packet_out_packet_out_SOF, packet_out_packet_out_EOF, packet_out_packet_out_DAT,\n')
  outputFile.write('        packet_out_packet_out_CNT, packet_out_packet_out_ERR} = packet_out;\n')
  outputFile.write('assign packet_out_packet_out_VAL = dec_packet_out_ap_vld & ~backpressure_in;\n')

def generateStub(parseInfo, hlsFilename, headerFilename):
  with open(hlsFilename, "wt") as outputFile:
    outputFile.write('// Code generated by the Fuselage Factory\n\n')
    outputFile.write('#include <' + os.path.basename(headerFilename) + '>\n\n')
    outputFile.write('#include <hls_stream.h>\n\n')
    outputFile.write('void ' + parseInfo['function'])
    outputFile.write('(\n')
    for direction in ['in', 'out']:
      for tuple in parseInfo[direction + 'put_tuples'].keys():
        outputFile.write('  hls::stream<' + tuple + '_type> & ' + tuple + ',\n')
    outputFile.write('  hls::stream<packet_type> & packet_in,\n')
    outputFile.write('  hls::stream<packet_type> & packet_out\n')
    outputFile.write(')\n')
    outputFile.write('{\n')
    for direction in ['in', 'out']:
      for tuple in parseInfo[direction + 'put_tuples'].keys():
        outputFile.write('#pragma HLS DATA_PACK variable=' + tuple + '\n')
    outputFile.write('#pragma HLS DATA_PACK variable=packet_in\n')
    outputFile.write('#pragma HLS DATA_PACK variable=packet_out\n')
    for direction in ['in', 'out']:
      for tuple in parseInfo[direction + 'put_tuples'].keys():
        outputFile.write('#pragma HLS INTERFACE ap_fifo port=' + tuple + '\n')
    outputFile.write('#pragma HLS INTERFACE ap_fifo port=packet_in\n')
    outputFile.write('#pragma HLS INTERFACE ap_hs port=packet_out\n\n')
    outputFile.write('  /* Fill in your code here. */\n')
    outputFile.write('}\n')

def generateHeader(parseInfo, filename):
  with open(filename, "wt") as outputFile:
    outputFile.write('// Code generated by the Fuselage Factory\n\n')
    outputFile.write('// WE DISCOURAGE MODIFYING THIS FILE DIRECTLY!!!\n')
    outputFile.write('// Changes to P4 code that do not affect the external function signature in P4\n')
    outputFile.write('// may still result in different variable widths.\n\n')
    outputFile.write('#ifndef FUSELAGE_HEADER_INCLUDED\n')
    outputFile.write('#define FUSELAGE_HEADER_INCLUDED\n\n')
    outputFile.write('#include <ap_int.h>\n\n')
    for direction in ['in', 'out']:
      for tuple, info in parseInfo[direction + 'put_tuples'].items():
        outputFile.write('typedef struct\n')
        outputFile.write('{\n')
        fields = info.get('fields')
        if fields != None:
          offset = 0
          for name, width in fields.items():
            outputFile.write('  ap_uint<' + str(width) + '> ' + name + ';\n')
        else:
          outputFile.write('  ap_uint<' + str(info['width']) + '> ' + tuple + ';\n')
        outputFile.write('} ' + tuple + '_type\n\n')
    outputFile.write('#endif\n')

if __name__ == '__main__':
  main()

