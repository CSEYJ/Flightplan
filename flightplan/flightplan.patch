diff --git a/CMakeLists.txt b/CMakeLists.txt
index 6b1123c..36d01a2 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -30,16 +30,18 @@ set (CMAKE_USE_RELATIVE_PATHS 1)
 
 OPTION (ENABLE_DOCS "Build the documentation" OFF)
 OPTION (ENABLE_GTESTS "Enable building and running GTest unit tests" ON)
-OPTION (ENABLE_BMV2 "Build the BMV2 backend (required for the full test suite)" ON)
-OPTION (ENABLE_EBPF "Build the EBPF backend (required for the full test suite)" ON)
+OPTION (ENABLE_BMV2 "Build the BMV2 backend (required for the full test suite)" OFF)
+OPTION (ENABLE_EBPF "Build the EBPF backend (required for the full test suite)" OFF)
 OPTION (ENABLE_P4TEST "Build the P4Test backend (required for the full test suite)" ON)
 OPTION (ENABLE_P4C_GRAPHS "Build the p4c-graphs backend" ON)
-OPTION (ENABLE_PROTOBUF_STATIC "Link against Protobuf statically" ON)
-OPTION (ENABLE_GC "Use libgc" ON)
+OPTION (ENABLE_PROTOBUF_STATIC "Link against Protobuf statically" OFF)
+#OPTION (ENABLE_GC "Use libgc" ON)
+OPTION (ENABLE_GC "Use libgc" OFF)
 OPTION (ENABLE_MULTITHREAD "Use multithreading" OFF)
 
 if (NOT CMAKE_BUILD_TYPE)
-  set (CMAKE_BUILD_TYPE "RELEASE")
+#  set (CMAKE_BUILD_TYPE "RELEASE")
+set (CMAKE_BUILD_TYPE "DEBUG")
 endif()
 
 if (NOT $ENV{P4C_VERSION} STREQUAL "")
diff --git a/frontends/CMakeLists.txt b/frontends/CMakeLists.txt
index 970b100..c24224c 100644
--- a/frontends/CMakeLists.txt
+++ b/frontends/CMakeLists.txt
@@ -12,6 +12,31 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+set (FLIGHTPLAN_SRCS
+  p4/flightplan.cpp
+  p4/flightplan_dot.cpp
+  p4/flightplan_ext.cpp
+  p4/flightplan_preanalysis.cpp
+  p4/flightplan_analysis.cpp
+  p4/flightplan_stmt.cpp
+  p4/flightplan_annotate.cpp
+  p4/flightplan_externs.cpp
+  p4/flightplan_annotator.cpp
+  p4/flightplan_context_analysis.cpp
+  )
+
+set (FLIGHTPLAN_HDRS
+  p4/flightplan.h
+  p4/flightplan_stmt.h
+  p4/flightplan_convert.h
+  p4/flightplan_convert_extra.h
+  p4/flightplan_annotate.h
+  p4/flightplan_preanalysis.h
+  p4/flightplan_externs.h
+  p4/flightplan_annotator.h
+  p4/flightplan_context_analysis.h
+  )
+
 set (P4_FRONTEND_SRCS
   p4/actionsInlining.cpp
   p4/callGraph.cpp
@@ -227,6 +252,7 @@ add_parser(p4)
 set (FRONTEND_SOURCES
   ${COMMON_FRONTEND_SRCS}
   ${PARSERS_SRCS}
+  ${FLIGHTPLAN_SRCS}
   ${P4_FRONTEND_SRCS}
   ${V1_FRONTEND_SRCS}
   ${p4PARSER_GEN_SRCS}
@@ -239,7 +265,7 @@ set_source_files_properties(${v1PARSER_GEN_SRCS} PROPERTIES GENERATED TRUE)
 set_source_files_properties(${p4PARSER_GEN_SRCS} PROPERTIES GENERATED TRUE)
 
 set (FRONTEND_CPPLINT_FILES
-  ${P4_FRONTEND_SRCS} ${P4_FRONTEND_HDRS}
+  ${P4_FRONTEND_SRCS} ${P4_FRONTEND_HDRS} ${FLIGHTPLAN_HDRS}
   ${COMMON_FRONTEND_SRCS} ${COMMON_FRONTEND_HDRS}
   ${V1_FRONTEND_SRCS} ${V1_FRONTEND_HDRS}
   ${PARSERS_SRCS} ${PARSERS_HDRS})
diff --git a/frontends/common/options.cpp b/frontends/common/options.cpp
index 37a24f4..1cb13b9 100644
--- a/frontends/common/options.cpp
+++ b/frontends/common/options.cpp
@@ -183,6 +183,118 @@ CompilerOptions::CompilerOptions() : Util::Options(defaultMessage) {
                   "  sourceFile:level,...,sourceFile:level\n"
                   "where 'sourceFile' is a compiler source file and\n"
                   "'level' is the verbosity level for LOG messages in that file");
+    registerOption("--flightplan", nullptr,
+                    [this](const char*) { flightplan = true; return true; },
+                    "Activate the Flightplan pass");
+    registerOption("--flightplan_dest", "folder",
+                   [this](const char* arg) { flightplanFolder = arg; return true; },
+                   "Folder where P4 programs generated by Flightplan are written to\n");
+    registerOption("--flightplan_dots", nullptr,
+                    [this](const char*) { flightplan_DOT_output = true; return true; },
+                    "Generate DOT file showing split P4 program");
+    registerOption("--flightplan_mode", "{annotate|split}",
+                    [this](const char* arg) {
+                     if (!strcmp(arg, "split")) {
+                        flightplan_mode = FlightplanMode::Split;
+                     } else if (!strcmp(arg, "annotate")) {
+                        flightplan_mode = FlightplanMode::Annotate;
+                     } else {
+                        ::error("Unrecognised Flightplan mode %1%", arg);
+                        return false;
+                     }
+                     return true; },
+                    "Flightplan mode.");
+    registerOption("--flightplan_annotation_mode", "{eager_offload|inertial_offload|chain}",
+                    [this](const char* arg) {
+                     if (!strcmp(arg, "eager_offload")) {
+                        flightplan_annotation_mode = FlightplanAnnotationMode::EagerOffload;
+                     } else if (!strcmp(arg, "inertial_offload")) {
+                        flightplan_annotation_mode = FlightplanAnnotationMode::InertialOffload;
+                     } else if (!strcmp(arg, "chain")) {
+                        flightplan_annotation_mode = FlightplanAnnotationMode::Chain;
+                     } else if (!strcmp(arg, "features")) {
+                        flightplan_annotation_mode = FlightplanAnnotationMode::Features;
+                     } else {
+                        ::error("Unrecognised Flightplan mode %1%", arg);
+                        return false;
+                     }
+                     return true; },
+                    "Flightplan annotation mode.");
+    registerOption("--flightplan_headered", nullptr,
+                    [this](const char*) { flightplan_headered = true; return true; },
+                    "Generate a Flightplan header");
+
+    registerOption("--flightplan_pinned_extern", "extern name",
+                    [this](const char* arg) {
+
+                    assert (flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::EagerOffload ||
+                            flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::InertialOffload ||
+                            flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::Chain);
+
+                       auto copy = strdup(arg);
+                       flightplan_exclusions.insert(copy);
+                     return true; },
+                    "Externs that must be called from FlightStart.");
+
+    registerOption("--flightplan_bunch_externs", "extern1,extern2[,extern3]",
+                   [this](const char* arg) {
+
+                       assert (flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::EagerOffload ||
+                               flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::InertialOffload ||
+                               flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::Chain);
+
+                       auto copy = strdup(arg);
+                       std::set<std::string> bunch;
+                       while (auto name = strsep(&copy, ",")) {
+                           bunch.insert(name);
+                       }
+                       flightplan_bunched.insert(bunch);
+                       return true;
+                   },
+                   "Externs that may be called while on the same segment\n");
+
+    registerOption("--flightplan_excluded_blocks", "name1[,name2]",
+                   [this](const char* arg) {
+                       assert(flightplan_focus_block == "");
+                       auto copy = strdup(arg);
+                       while (auto name = strsep(&copy, ",")) {
+                           flightplan_excluded_blocks.insert(name);
+                       }
+                       return true;
+                   },
+                   "Names of control blocks to exclude from analysis\n");
+    registerOption("--flightplan_focus_block", "name",
+                   [this](const char* arg) {
+                       assert(flightplan_excluded_blocks.size() == 0);
+                       assert(flightplan_focus_block == "");
+                       flightplan_focus_block = strdup(arg);
+                       return true;
+                   },
+                   "Name of the control blocks to focus the analysis on exclusively\n");
+    registerOption("--flightplan_offload_tables", "table1[,table2]",
+                   [this](const char* arg) {
+
+                       assert (flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::Features);
+
+                       auto copy = strdup(arg);
+                       while (auto name = strsep(&copy, ",")) {
+                           flightplan_table_offload.insert(name);
+                       }
+                       return true;
+                   },
+                   "Names of tables to be offloaded.\n");
+    registerOption("--flightplan_offload_headers", "type1[,type2]",
+                   [this](const char* arg) {
+
+                       assert (flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::Features);
+
+                       auto copy = strdup(arg);
+                       while (auto name = strsep(&copy, ",")) {
+                           flightplan_header_offload.insert(name);
+                       }
+                       return true;
+                   },
+                   "Header types to be offloaded.\n");
 }
 
 void CompilerOptions::setInputFile() {
diff --git a/frontends/common/options.h b/frontends/common/options.h
index 124c29d..b0dc834 100644
--- a/frontends/common/options.h
+++ b/frontends/common/options.h
@@ -80,6 +80,32 @@ class CompilerOptions : public Util::Options {
     // Dump and undump the IR tree
     bool debugJson = false;
 
+    // Activate the Flightplan pass
+    bool flightplan = false;
+    // Flightplan outputs are written in this folder
+    cstring flightplanFolder = ".";
+    // Produce DOT output for each program fragment.
+    bool flightplan_DOT_output = false;
+
+    enum class FlightplanMode {Undefined, Annotate, Split};
+    // What mode is Flightplan running in.
+    FlightplanMode flightplan_mode = FlightplanMode::Undefined;
+
+    enum class FlightplanAnnotationMode {Undefined, EagerOffload, InertialOffload, Chain, Features};
+    // If in annotation mode, what kind of annotation mode to use.
+    FlightplanAnnotationMode flightplan_annotation_mode = FlightplanAnnotationMode::Undefined;
+
+    bool flightplan_headered = false;
+
+    std::unordered_set<std::string> flightplan_exclusions;
+    std::set<std::set<std::string>> flightplan_bunched;
+
+    std::unordered_set<std::string> flightplan_table_offload;
+    std::unordered_set<std::string> flightplan_header_offload;
+
+    std::set<std::string> flightplan_excluded_blocks;
+    std::string flightplan_focus_block;
+
     // Write a P4Runtime control plane API description to the specified file.
     cstring p4RuntimeFile = nullptr;
 
diff --git a/frontends/common/resolveReferences/referenceMap.cpp b/frontends/common/resolveReferences/referenceMap.cpp
index 73c080e..b065685 100644
--- a/frontends/common/resolveReferences/referenceMap.cpp
+++ b/frontends/common/resolveReferences/referenceMap.cpp
@@ -34,6 +34,7 @@ void ReferenceMap::setDeclaration(const IR::Path* path, const IR::IDeclaration*
     CHECK_NULL(path);
     CHECK_NULL(decl);
     LOG1("Resolved " << path << " to " << decl);
+//std::cout << "Resolved " << path << " to " << decl << std::endl;    
     auto previous = get(pathToDeclaration, path);
     if (previous != nullptr && previous != decl)
         BUG("%1% already resolved to %2% instead of %3%",
@@ -77,8 +78,15 @@ const IR::IDeclaration* ReferenceMap::getDeclaration(const IR::Path* path, bool
     else
         LOG1("Looking up " << path << " found nothing");
 
-    if (notNull)
+//    // FIXME hack!     
+//    if (std::string(path->toString()) == std::string("flyto")) {
+//    	return new IR::Method(IR::ID("flyto", nullptr), new IR::Type_Method(IR::Type_Void::get(), new IR::ParameterList()));
+//    }
+
+//    if (std::string(path->toString()) != std::string("flyto")) {
+      if (notNull)
         BUG_CHECK(result != nullptr, "Cannot find declaration for %1%", path);
+//    }
     return result;
 }
 
diff --git a/frontends/p4/flightplan.cpp b/frontends/p4/flightplan.cpp
new file mode 100644
index 0000000..348dad7
--- /dev/null
+++ b/frontends/p4/flightplan.cpp
@@ -0,0 +1,548 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#include <assert.h>
+#include <iostream>
+#include <fstream>
+#include <chrono>
+#include <ctime>
+#include <math.h>
+
+#include "externInstance.h"
+
+#include "ir/ir.h"
+#include "ir/visitor.h"
+#include "lib/nullstream.h"
+#include "lib/path.h"
+#include "toP4/toP4.h"
+
+#include "flightplan.h"
+#include "flightplan_annotate.h"
+#include "flightplan_preanalysis.h"
+#include "flightplan_annotator.h"
+#include "flightplan_context_analysis.h"
+
+#define NOTSWITCH
+
+namespace P4 {
+
+Split* Split::curr_split = nullptr;
+std::set<Split*> Split::Splits;
+
+auto now = std::chrono::system_clock::now();
+std::time_t now_time = std::chrono::system_clock::to_time_t(now);
+const std::string FlightplanConfig::header_comment = "// Flightplan output\n// Now = " + std::string(std::ctime(&now_time));
+const std::string FlightplanConfig::landing_type_name = "Landing";
+const std::string FlightplanConfig::flyto_fn = "flyto";
+const std::set<std::string> FlightplanConfig::landing_API = {FlightplanConfig::flyto_fn};
+const std::string FlightplanConfig::landing_start = "FlightStart";
+//std::set<Split*> Flightplan::splits;
+unsigned FlightplanConfig::dot_id = 0;
+FStmt* FlightplanImpl::main = nullptr;
+const IR::P4Program* FlightplanConfig::p4_program = nullptr;
+IR::PathExpression* FlightplanConfig::flyto_expr = nullptr;
+
+ReferenceMap* FlightplanConfig::FP_refMap;
+TypeMap* FlightplanConfig::FP_typeMap;
+CompilerOptions FlightplanConfig::FP_options;
+
+std::string FlightplanConfig::adjusted_input_filename;
+
+void FlightplanImpl::end_apply(const IR::Node* node) {
+    if (options.flightplan_mode == CompilerOptions::FlightplanMode::Split) {
+        Split::mark_split(main);
+    }
+
+    if (node->is<IR::P4Program>()) {
+        this->hook_end();
+    }
+
+    Inspector::end_apply();
+}
+
+void FlightplanImpl::print_ctxt() const {
+    std::cout << "Ctxt (" << ctxt.size() << "): ";
+    for (auto elem : ctxt) {
+        std::cout << elem->toString() << " ";
+    }
+    std::cout << std::endl;
+}
+
+bool FlightplanImpl::preorder(const IR::P4Program* p) {
+    FlightplanConfig::p4_program = p;
+    std::cout << "Program main: " << p->main << std::endl;
+
+    original_prog = p;
+
+//    auto main_decl = p->getDeclByName(p->main);
+    auto main_decl = p->getDeclsByName(p->main)->toVector()->at(0);
+#if 0
+    std::cout << "Program main contents: " <<
+        main_decl->getNode()->node_type_name()
+        << std::endl;
+#endif
+
+    auto di = main_decl->getNode()->to<IR::Declaration_Instance>();
+
+    for (auto a : *di->arguments) {
+#if 0
+        std::cout << "Arg: " << a->toString() << std::endl;
+        std::cout << "    " << a->getNode()->node_type_name() << std::endl;
+#endif
+
+//        auto decl = p->getDeclByName(a->toString());
+        auto decl = p->getDeclsByName(a->toString())->toVector()->at(0);
+
+        bool interesting_control_block = false;
+
+        if (decl->getNode()->is<IR::P4Control>()) {
+            if (FlightplanConfig::FP_options.flightplan_focus_block != "") {
+               if (FlightplanConfig::FP_options.flightplan_focus_block == std::string(a->toString())) {
+                  interesting_control_block = true;
+               }
+            } else if (FlightplanConfig::FP_options.flightplan_excluded_blocks.find(std::string(a->toString())) == FlightplanConfig::FP_options.flightplan_excluded_blocks.end()) {
+               interesting_control_block = true;
+            }
+        }
+
+        std::cout << "Arg: " << decl->toString();
+        std::cout << " : " << decl->getNode()->node_type_name();
+        if (interesting_control_block) {
+            control = &decl->getNode()->as<IR::P4Control>();
+            control_ID = decl->getName(); // FIXME redundant
+            std::cout << " (*)";
+        }
+        std::cout << std::endl;
+
+        if (interesting_control_block)
+            visit(decl->getNode());
+    }
+
+    return false;
+}
+
+bool FlightplanImpl::preorder(const IR::PathExpression* expr) {
+    // This is used to accummulate context
+    // FIXME this isn't being done in a principle manner. For one thing,
+    //       the direction of gathering isn't being set appropriately
+    //       (we want a backward analysis).
+    ctxt.insert(expr);
+    return false;
+}
+
+bool FlightplanImpl::preorder(const IR::P4Control* s) {
+    // It's assumed that this is the main P4Control block (not the deparser).
+    std::cout << "P4Control: " << s->externalName() << std::endl;
+
+    for (auto decl : *s->getDeclarations()) {
+        control_decls.push_back(decl);
+    }
+
+#if 0   
+    visit(s->body);
+#endif
+    main = StmtConvert::encapsulate(nullptr, std::string(options.flightplanFolder), s->body, nullptr, nullptr);
+
+//    steps.push_back(main);
+#if 0
+    for (auto split : main->splits) { // FIXME hack? overlaps with Split::Splits?
+//        Flightplan::splits.insert(split);
+        Split::Splits.insert(split);
+    }
+#endif
+    return false;
+}
+
+bool FlightplanImpl::preorder(const IR::P4Parser*) {
+    // We don't go into parsers
+    return false;
+}
+
+Flightplan::Flightplan(ReferenceMap* refMap, TypeMap* typeMap, const CompilerOptions& options) {
+    CHECK_NULL(refMap);
+    CHECK_NULL(typeMap);
+    setName("Flightplan");
+
+    FlightplanConfig::FP_refMap = refMap;
+    FlightplanConfig::FP_typeMap = typeMap;
+    FlightplanConfig::FP_options = options;
+
+    FlightplanConfig::adjusted_input_filename = std::string(options.file);
+    std::replace( FlightplanConfig::adjusted_input_filename.begin(),
+     FlightplanConfig::adjusted_input_filename.end(), '/', '_');
+
+    if (options.flightplan) {
+        std::cout << "Starting Flightplan" << std::endl;
+//        passes.emplace_back(new FlightplanTransf(refMap, typeMap, options));
+
+        std::cout << "Input file: " << options.file << std::endl;
+        // Check our configuration.
+        switch (options.flightplan_mode) {
+            case CompilerOptions::FlightplanMode::Annotate:
+                std::cout << "Mode: Annotate" << std::endl;
+
+                switch (options.flightplan_annotation_mode) {
+                    case CompilerOptions::FlightplanAnnotationMode::EagerOffload:
+                        std::cout << "  Sub-Mode: EagerOffload" << std::endl;
+                        break;
+                    case CompilerOptions::FlightplanAnnotationMode::InertialOffload:
+                        std::cout << "  Sub-Mode: InertialOffload" << std::endl;
+                        break;
+                    case CompilerOptions::FlightplanAnnotationMode::Chain:
+                        std::cout << "  Sub-Mode: Chain" << std::endl;
+                        break;
+                    case CompilerOptions::FlightplanAnnotationMode::Features:
+                        std::cout << "  Sub-Mode: Features" << std::endl;
+                        break;
+                    case CompilerOptions::FlightplanAnnotationMode::Undefined:
+                        throw std::logic_error("Flightplan: must specify Annotation sub-mode");
+                    default:
+                        throw std::logic_error("Flightplan: unrecognised Annotation sub-mode");
+                }
+
+                break;
+            case CompilerOptions::FlightplanMode::Split:
+                std::cout << "Mode: Split" << std::endl;
+
+                switch (options.flightplan_annotation_mode) {
+                    case CompilerOptions::FlightplanAnnotationMode::Undefined:
+                        break;
+                    default:
+                        throw std::logic_error("Flightplan: Annotation sub-mode is meaningless in Split mode");
+                }
+
+                break;
+            case CompilerOptions::FlightplanMode::Undefined:
+                throw std::logic_error("Flightplan: must specify mode");
+            default:
+                throw std::logic_error("Flightplan: unrecognised mode");
+        }
+        std::cout << "Headered: ";
+        if (options.flightplan_headered) {
+            std::cout << "True" << std::endl;
+        } else {
+            std::cout << "False" << std::endl;
+        }
+
+        FlightplanAnnotate::Initialise();
+        auto fpi = new FlightplanImpl(refMap, typeMap, options);
+        passes.emplace_back(fpi);
+    }
+}
+
+// Return width of the type in bytes -- make sure that type is serialisable (ask programmer to make it so otherwise)
+unsigned int sumBits(std::set<const IR::Expression*> set) {
+    unsigned int total = 0;
+    for (const IR::Expression* expr : set) {
+        const IR::Type* ty = FlightplanConfig::FP_typeMap->getType(expr->getNode());
+        if (ty->is<IR::Type_Bits>()) {
+            const IR::Type_Bits* ty_bits = &ty->as<IR::Type_Bits>();
+            total += ty_bits->size;
+	} else {
+            // FIXME struct/header
+            //std::cout << "Could not sumBits non-bit type (" << ty << ") of " << expr << std::endl;
+            std::cout << "Could not sumBits non-bit type (" << ty->node_type_name() << ") of " << expr << std::endl;
+        }
+    }
+    return total;
+}
+
+std::set<const IR::Expression*> filter_location_variables(std::set<const IR::Expression*> set) {
+    std::set<const IR::Expression*> result;
+    for (const IR::Expression* expr : set) {
+        const IR::Type* ty = FlightplanConfig::FP_typeMap->getType(expr->getNode());
+        if (ty->is<IR::Type_Bits>()) {
+            const IR::Type_Bits* ty_bits = &ty->as<IR::Type_Bits>();
+	    if (ty_bits->size != 1337/*FIXME const*/) {
+                result.insert(expr);
+            }
+        } else {
+            // FIXME should filter non-bit types here?
+            result.insert(expr);
+	}
+    }
+    return result;
+}
+
+std::set<const IR::Expression*> deduplicate(ReferenceMap* refMap, std::set<const IR::Expression*> set) {
+    std::set<const IR::Expression*> result;
+    for (auto e1 : set) {
+        bool found = false;
+#if 0
+        if (e1->is<IR::PathExpression>()) { // FIXME currently ignoring other types of expresisons
+            const IR::IDeclaration* d1 = refMap->getDeclaration(e1->as<IR::PathExpression>().path, true);
+            for (auto e2 : result) {
+                const IR::IDeclaration* d2 = refMap->getDeclaration(e2->as<IR::PathExpression>().path, true);
+                if (d1 == d2) {
+    	            found = true;
+    	            break;
+                }
+            }
+            if (!found) {
+                result.insert(e1);
+            }
+        }
+#endif
+        for (auto e2 : result) {
+            if (std::string(e1->toString()) == std::string(e2->toString())) {
+    	        found = true;
+    	        break;
+            }
+        }
+        if (!found) {
+            result.insert(e1);
+        }
+    }
+    return result;
+}
+
+unsigned int bytesForBits(unsigned int bits) {
+    double bits_d = bits;
+    return (unsigned int)(ceil(bits_d / 8));
+}
+
+void FlightplanImpl::hook_end() {
+    std::cout << "Split summary:" << std::endl;
+    for (auto split : Split::Splits) {
+        std::cout << "  split->name: " << split->name << std::endl;
+        std::cout << "  split->output_file: " << split->output_file << std::endl;
+        std::cout << "  split->beginning: " << split->beginning << std::endl;
+        std::cout << std::endl;
+    }
+
+  if (FlightplanConfig::FP_options.flightplan_mode == CompilerOptions::FlightplanMode::Annotate) {
+    assert(Split::Splits.size() == 1);
+    auto newsplits = Split::Splits;
+    newsplits.clear();
+    for (auto split : Split::Splits) {
+
+        P4::FStmt* main = (P4::FStmt*)split->getBeginning();
+
+        AnalysisState as;
+        ForwardStatementGatherer fsg;
+        fsg.process(main, &as);
+        if (FlightplanConfig::FP_options.flightplan_DOT_output) {
+            as.saveDOTfile();
+        }
+        as.EmitResults();
+
+        Flightplan_Annotator dc(&as);
+        FlightplanAnnotate::Tippy* annotation_state = FlightplanAnnotate::Tippy::Initial();
+        auto newprog = dc.process(main, annotation_state);
+        auto newsplit = new Split(std::string(FlightplanConfig::FP_options.flightplanFolder), std::string(FlightplanConfig::FP_options.flightplanFolder) + "/" + FlightplanConfig::adjusted_input_filename + ".p4", newprog);
+        newsplits.insert(newsplit);
+    }
+    Split::Splits = newsplits;
+
+    FlightplanAnnotate::EmitResults();
+  }
+
+/*
+FIXME For each FStmt do we remember which split we think it's in?
+  currently doesn't seem to be the case, but there's the "splits" set for this purpose? why isn't it working?
+*/
+
+FlyAnalysisState fas;
+Fly_Analyser ca(FlightplanConfig::FP_typeMap, FlightplanConfig::FP_refMap);
+ca.process(FlightplanImpl::main, &fas);
+std::cout << "Fly location mappings:" << std::endl;
+// FIXME use these mappings to clean up the flyto's in the splits, so they'll mention actual Landings and not tmp_0 etc.
+for (auto &p : fas) {
+  std::cout << "  " << p.first << " |-> " << p.second << std::endl;
+}
+
+  // FIXME  if (options.flightplan_mode == CompilerOptions::FlightplanMode::Split) {   
+        std::cout << "Output files (" << Split::Splits.size() << "): ";
+        for (auto item : Split::Splits) {
+            std::cout << item->output_file << " ";
+        }
+        std::cout << std::endl;
+//        std::cout << "Splits: " << Flightplan::splits.size() << std::endl;
+        print_ctxt();
+
+        std::cout << "Program declarations: " << std::endl;
+//        for (auto decl : original_prog->declarations) {
+        for (auto decl : *original_prog->getDeclarations()) {
+//            std::cout << decl->toString();
+            std::cout << "  * (" << decl->node_type_name() << ") " << decl->getNode()->toString() << std::endl;
+        }
+
+        std::cout << "Main-block declarations: " << std::endl;
+        for (auto decl : control_decls) {
+            std::cout << "  * (" << decl->node_type_name() << ") " << decl->getNode()->toString() << std::endl;
+        }
+
+        std::cout << "Main-block ID: " << control_ID.name << std::endl;
+
+        std::map<const cstring, IR::BlockStatement> step_map;
+        std::cout << "Emitting splits";
+//        for (auto split : Flightplan::splits) {
+        int split_count = 0;
+        for (auto split : Split::Splits) {
+            std::cout << "Split " << std::to_string(split_count) << std::endl;
+            ++split_count;
+
+            if (step_map.find(split->output_file) != step_map.end()) {
+#if 0 // FIXME this code needs reworking, reimplementing toStatement();       
+                step->toStatement(&step_map[step->get_destination()]);
+#endif
+                std::logic_error("Unexpected");
+            } else {
+                IR::BlockStatement bs;
+#if 0 // FIXME this code needs reworking, reimplementing toStatement();       
+                step->toStatement(&bs);
+#endif
+
+// This is crucial, we need to split before we can getCleaved()
+if (options.flightplan_mode == CompilerOptions::FlightplanMode::Split) {
+                Split::effect_split(split);
+                bs.push_back(split->getCleaved()->toStatement());
+
+                // find out set of read & written variables in each segment   
+                ContextAnalysisState cas;
+                Context_Analyser ca(FlightplanConfig::FP_typeMap, FlightplanConfig::FP_refMap);
+                ca.process((FStmt*)split->getCleaved(), &cas);
+		cas.reads = deduplicate(FlightplanConfig::FP_refMap, filter_location_variables(cas.reads));
+		cas.writes = deduplicate(FlightplanConfig::FP_refMap, filter_location_variables(cas.writes));
+                std::cout << "  reads : " << cas.readsString() << std::endl;
+		// FIXME factor reads & writes by same expressions -- the sets appear to contain repeated references (but different pointers) to the same expressions
+                std::cout << "    total bytes = " << std::to_string(bytesForBits(sumBits(cas.reads))) << std::endl;
+                std::cout << "  writes: " << cas.writesString() << std::endl;
+                std::cout << "    total bytes = " << std::to_string(bytesForBits(sumBits(cas.writes))) << std::endl;
+
+} else {
+                bs.push_back(split->getBeginning()->toStatement());
+}
+                step_map[split->output_file] = bs;
+
+                if (options.flightplan_DOT_output) {
+                    const cstring destination = std::string(split->output_file) + ".dot";
+                    std::cout << "Writing DOT file:" << destination << std::endl;
+                    if (!destination.isNullOrEmpty()) {
+                        Util::PathName path(destination);
+                        std::ostream *ost = new std::ofstream(path.toString(), std::ios_base::app);
+                        *ost << FlightplanConfig::header_comment << std::endl << std::endl;
+if (options.flightplan_mode == CompilerOptions::FlightplanMode::Split) {
+//                        Split::effect_split(split);
+                        std::cout << "Generating DOT" << std::endl;
+                        Split::to_dot(ost, split);
+}
+#if 0
+                        *ost << "digraph G {" << std::endl;
+                        *ost << "compound=true;" << std::endl;
+
+//                        step->set_prev(new EntryPoint(step));
+                        EntryPoint ep(std::string(options.flightplanFolder), nullptr);
+                        //ep.set_next(step);
+                        *ost << ep.toDOT() << std::endl;
+                        *ost << ep.DOTid() + " -> " + split->getBeginning()->entryDOTid() + ";" << std::endl;
+
+                        *ost << split->getBeginning()->toDOT() << std::endl;
+                        *ost << "}" << std::endl;
+#endif
+                    } else {
+                        ::error("Null filename?");
+                    }
+                }
+            }
+        }
+        std::cout << std::endl;
+
+        // Show dependencies between splits
+        for (auto split : Split::Splits) {
+#if 0
+            auto split_beginning = split->getCleaved();
+            assert(split_beginning != nullptr);
+            std::set<const FStmt*> ts = StmtFlow::transfers(StmtFlow::TransitClos(split_beginning));
+            for (auto next_stmt : ts) {
+                std::cout << "    " << next_stmt->toString() << std::endl;
+            }
+#endif
+            std::cout << "split = " << split->output_file;
+            std::set<Split*> ts = split->successor_splits;
+            std::cout << " (" << ts.size() << ")" << std::endl;
+            for (auto next_split : ts) {
+//                std::cout << "  * " << next_split->getCleaved()->toString() << std::endl;
+                std::cout << "  * " << next_split->output_file << std::endl;
+            }
+        }
+
+if (options.flightplan_mode == CompilerOptions::FlightplanMode::Split) {
+        // Draw split-level topology
+        if (options.flightplan_DOT_output) {
+            const cstring destination = options.flightplanFolder + "/" + "split-topology.dot";
+            std::cout << "Writing split-level topology:" << destination << std::endl;
+            if (!destination.isNullOrEmpty()) {
+                Util::PathName path(destination);
+                std::ostream *ost = new std::ofstream(path.toString(), std::ios_base::app);
+                *ost << FlightplanConfig::header_comment << std::endl << std::endl;
+                Split::splits_dot(ost);
+            }
+        }
+
+        // FIXME experimental    
+        if (options.flightplan_DOT_output) {
+            const cstring destination = options.flightplanFolder + "/" + "cfg.dot";
+            std::cout << "Writing CFG file:" << destination << std::endl;
+            if (!destination.isNullOrEmpty()) {
+                Util::PathName path(destination);
+                std::ostream *ost = new std::ofstream(path.toString(), std::ios_base::app);
+                *ost << FlightplanConfig::header_comment << std::endl << std::endl;
+                *ost << "digraph G {" << std::endl;
+                std::set<const FStmt*> visited;
+                StmtFlow::cfg_dot(ost, FlightplanImpl::main, visited);
+                *ost << "}" << std::endl;
+            } else {
+                ::error("Null filename?");
+            }
+        }
+}
+
+        std::cout << "Writing files:" << std::endl;
+        for (auto step : step_map) {
+            std::cout << "  * " << step.first << " (";
+            IR::BlockStatement bs = step.second;
+            int size = 0;
+            for (auto c : bs.components) {
+                size += 1;
+            }
+            std::cout << size << ")" << std::endl;
+
+            IR::P4Control newctrl = IR::P4Control(control_ID, control->type, control->controlLocals, /*control->body*/&bs);
+            IR::IndexedVector<IR::Node> declarations;
+
+//            for (auto decl : original_prog->declarations) {
+            for (auto decl : *original_prog->getDeclarations()) {
+                // Preserve order of declarations
+                if (decl->is<IR::IDeclaration>() && decl->as<IR::IDeclaration>().getName() == control_ID)
+                    declarations.push_back(&newctrl);
+                else
+                    declarations.push_back(decl->getNode());
+            }
+
+            IR::P4Program prog = IR::P4Program(declarations);
+            prog.validate();
+
+            FStmt::toFile(FlightplanConfig::adjusted_input_filename, step.first, &prog);
+        }
+
+        std::string received_file = options.flightplanFolder + "/" + FlightplanConfig::adjusted_input_filename + "_received";
+        std::cout << "Writing received file:" << received_file << std::endl;
+        /*FIXME DRY principle from the previous block*/
+        IR::P4Control newctrl = IR::P4Control(control_ID, control->type, control->controlLocals, /*control->body*/(IR::BlockStatement*)/*FIXME hack*/FlightplanImpl::main->toStatement());
+        IR::IndexedVector<IR::Node> declarations;
+        for (auto decl : *original_prog->getDeclarations()) {
+            // Preserve order of declarations
+            if (decl->is<IR::IDeclaration>() && decl->as<IR::IDeclaration>().getName() == control_ID)
+                declarations.push_back(&newctrl);
+            else
+                declarations.push_back(decl->getNode());
+        }
+        IR::P4Program prog = IR::P4Program(declarations);
+        prog.validate();
+        FStmt::toFile(FlightplanConfig::adjusted_input_filename, received_file, &prog);
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan.h b/frontends/p4/flightplan.h
new file mode 100644
index 0000000..3e7fca8
--- /dev/null
+++ b/frontends/p4/flightplan.h
@@ -0,0 +1,229 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+
+NOTE must be executed after RemoveReturns, since we assume they've been removed.
+*/
+
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_H_
+
+#include <stdexcept>
+#include <string>
+#include <vector>
+
+#include "../common/options.h"
+#include "ir/ir.h"
+#include "frontends/p4/typeChecking/typeChecker.h"
+#include "frontends/common/resolveReferences/resolveReferences.h"
+
+#include "toP4/toP4.h"
+
+namespace P4 {
+
+class Split;
+
+class Flightplan : public PassManager {
+ public:
+    Flightplan(ReferenceMap* refMap, TypeMap* typeMap, const CompilerOptions&);
+};
+
+namespace FlightplanConfig {
+    extern const std::string header_comment;
+    extern const std::string landing_type_name;
+    extern const std::string flyto_fn;
+    extern const std::set<std::string> landing_API;
+    extern const std::string landing_start;
+    extern unsigned dot_id;
+//    static std::set<Split*> splits;
+
+    extern ReferenceMap* FP_refMap;
+    extern TypeMap* FP_typeMap;
+    extern CompilerOptions FP_options;
+    extern const IR::P4Program* p4_program;
+    extern IR::PathExpression* flyto_expr;
+
+    extern std::string adjusted_input_filename;
+}
+
+class FStmt;
+
+class Split final {
+    FStmt *beginning = nullptr;
+    FStmt *cleaved = nullptr;
+
+    friend class FlightplanImpl;
+
+    Split(std::string name, cstring output_file, FStmt *beginning) : output_file(output_file), beginning(beginning), name(name) {}
+
+    static Split* curr_split;
+
+ public:
+    cstring output_file = nullptr;
+    std::string name;
+    std::set<Split*> successor_splits;
+//    static std::vector<Split*> Splits;
+    static std::set<Split*> Splits;
+    static Split* new_split(std::string dest_path, std::string landing_name, FStmt *beginning) {
+        std::string result = dest_path + "/" + landing_name + ".p4";
+        curr_split = new Split(landing_name, result, beginning); // FIXME automatically deleted on deconstruction?
+        Splits.insert(curr_split);
+        return curr_split;
+    }
+    static Split* current_split(std::string dest_path, FStmt *current) {
+        if (curr_split == nullptr) {
+            curr_split = new_split(dest_path, FlightplanConfig::landing_start, current);
+        }
+        return curr_split;
+    }
+
+    const FStmt* getBeginning() const {
+        return beginning;
+    }
+
+#if 0
+some of these could go in StmtFlow
+
+    const FStmt* getNext(const FStmt* st) const 
+
+    bool isIncluded(FStmt* st) const 
+      true unless st isn't reacheable from this statement via getNext until a TransferPoint or the end of the program.
+
+    unsigned size() const 
+      total number of statements, where "if" = 1 + true + false; similar for "switch"
+      to make it easier, define static class called StmtSize, and call its methods
+
+    IR::Statement* toStatement() const 
+      until a transfer point; stitch together remainder of blocks, including from if/switch.
+
+    static lift -- change Stmt to TransferPoint 
+
+    std::map<name,type> calculateInitialContext() const 
+       FIXME backwards analysis
+#endif
+
+    // FIXME for handover between splits, need to calculate context for latter split in advance, to be carried by the former.
+    static int mark_split(FStmt* main);
+    static void mark_split(FStmt* stmt, Split* split, std::set<const FStmt*> visited);
+    static void to_dot(std::ostream *ost, Split *split);
+    static FStmt* effect_split(Split *split);
+    static bool continue_split(Split *split, FStmt* prev, FStmt* stmt, std::set<FStmt*> &visited, bool pre_cloned, bool ascend);
+    static bool ascend_split(Split *split, FStmt* prev, FStmt* stmt, std::set<FStmt*> &visited);
+
+#if 0
+    // Which splits follow or precede a split; need to know this to work out what state will need tranferring for eventual use.
+    static std::set<Split *> successors(Split *split);
+    static std::set<Split *> predecessors(Split *split);
+#endif
+    // Show how splits connect to one another.
+    static void splits_dot(std::ostream *ost);
+
+#if 0
+    std::set<Split*>* successors();
+#endif
+
+    const FStmt* getCleaved() const {
+        return cleaved;
+    }
+
+// FIXME      
+//    map from split to declarations
+//    map from split to free variables
+//fix code emission in each split                                         
+//
+//free variables must come from earlier splits along the way
+//  from where the variable was last updated
+
+/*
+variables: read vs write
+    read: "in", parameters, RHS to assign
+    write: "out", LHS to assign
+*/
+
+};
+
+class DOT {
+ protected:
+    unsigned dot_id;
+    std::string* clust_id = nullptr;
+ public:
+    DOT(unsigned id) : dot_id(id) {}
+    virtual std::string toDOT() const = 0;
+    virtual std::string DOTid() const {
+        return "n" + std::to_string(dot_id);
+    }
+    virtual std::string* getClustID() const {
+        return clust_id;
+    }
+    virtual std::string entryDOTid() const {
+        return DOTid();
+    }
+};
+
+class FlightplanImpl : public Inspector {
+    ReferenceMap*   refMap;
+    TypeMap*        typeMap;
+    const CompilerOptions options;
+
+    static FStmt* main;
+
+ //   std::vector<FStmt*> steps;
+    const IR::P4Program* original_prog = nullptr;
+    std::set<const IR::PathExpression*> ctxt;
+
+    // FIXME there's redundancy here
+    IR::ID control_ID;
+    const IR::P4Control* control = nullptr;
+    std::vector<const IR::IDeclaration*> control_decls;
+
+ public:
+    explicit FlightplanImpl(ReferenceMap* refMap, TypeMap* typeMap, const CompilerOptions& options) :
+            refMap(refMap), typeMap(typeMap), options(options)
+    {
+        setName("FlightplanImpl");
+    }
+
+    void end_apply(const IR::Node*) override;
+
+    void hook_end();
+
+#if 0
+    bool preorder(const IR::MethodCallStatement* s) override;
+    bool preorder(const IR::BlockStatement* s) override;
+    bool preorder(const IR::AssignmentStatement* s) override;
+    bool preorder(const IR::IfStatement* s) override;
+    bool preorder(const IR::SwitchStatement* s) override;
+#endif
+
+    bool preorder(const IR::PathExpression* expr) override;
+    bool preorder(const IR::P4Control* s) override;
+    bool preorder(const IR::P4Parser* s) override;
+    bool preorder(const IR::P4Program* p) override;
+
+    void print_ctxt() const;
+
+    static const FStmt* getMain() {
+        return main;
+    }
+};
+
+class FlightplanTransf : public Transform {
+    ReferenceMap*   refMap;
+    TypeMap*        typeMap;
+    const CompilerOptions options;
+ public:
+    explicit FlightplanTransf(ReferenceMap* refMap, TypeMap* typeMap, const CompilerOptions& options) :
+            refMap(refMap), typeMap(typeMap), options(options)
+    {
+        setName("FlightplanTransf");
+    }
+
+    const IR::Node* preorder(IR::Type_Declaration* t) override;
+    const IR::Node* preorder(IR::Method* t) override;
+    const IR::Node* preorder(IR::MethodCallStatement* mcs) override;
+};
+
+}  // namespace P4
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_H_ */
diff --git a/frontends/p4/flightplan_analysis.cpp b/frontends/p4/flightplan_analysis.cpp
new file mode 100644
index 0000000..90da269
--- /dev/null
+++ b/frontends/p4/flightplan_analysis.cpp
@@ -0,0 +1,251 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#include <assert.h>
+#include <iostream>
+#include <fstream>
+#include <queue>
+
+#include "externInstance.h"
+
+#include "../common/options.h"
+#include "ir/ir.h"
+#include "ir/visitor.h"
+#include "lib/nullstream.h"
+#include "lib/path.h"
+#include "toP4/toP4.h"
+
+#include "flightplan.h"
+
+namespace P4 {
+
+void Split::mark_split(FStmt* stmt, Split* split, std::set<const FStmt*> visited) {
+    for (auto next : StmtFlow::step(StmtFlow::Direction::Forward, stmt, visited)) {
+        const TransferPoint *tp = dynamic_cast<const TransferPoint*>(stmt);
+        if (tp != nullptr) {
+            stmt->splits.clear();
+            split = new_split(std::string(FlightplanConfig::FP_options.flightplanFolder), tp->transfer_to, stmt);
+            mark_split((FStmt*)/*FIXME type hack*/next, split, visited);
+        } else {
+            stmt->splits.insert(split);
+            mark_split((FStmt*)/*FIXME type hack*/next, split, visited);
+        }
+    }
+}
+
+int Split::mark_split(FStmt* main) {
+    for (auto split : main->splits) {
+        std::set<const FStmt*> visited;
+        mark_split(main, split, visited);
+    }
+    return Split::Splits.size();
+}
+
+bool Split::ascend_split(Split *split, FStmt* prev, FStmt* stmt, std::set<FStmt*> &visited) {
+#if 0
+    std::cout << "Ascending..." << std::endl;
+#endif
+    if (stmt == nullptr || stmt->getContainer() == nullptr) {
+        return false;
+    }
+
+    if (stmt->getContainer()->get_next() != nullptr) {
+        return continue_split(split, prev, (FStmt*)/*FIXME type hack*/stmt->getContainer()->get_next(), visited, false, true/*If we have ascended, we shall continue to ascend*/);
+    } else {
+        return ascend_split(split, prev, (FStmt*)/*FIXME type hack*/stmt->getContainer(), visited);
+    }
+}
+
+bool Split::continue_split(Split *split, FStmt* prev, FStmt* stmt, std::set<FStmt*> &visited, bool pre_cloned, bool ascend) {
+#if 0
+    std::cout << "Continuing..." << std::endl;
+#endif
+    if (stmt == nullptr) {
+        return false;
+    }
+
+//the clone is being lost, since prev is initially null
+//indicate if we've pre-cloned
+
+    // We are guaranteed that stmt!=nullptr at this point
+    stmt->keep_split(split);
+
+    FStmt* stmt_cp = nullptr;
+    if (!pre_cloned) {
+        stmt_cp = stmt->clone();
+        stmt = nullptr;
+    } else {
+        stmt_cp = (FStmt *)/*FIXME type hack*/stmt;
+        stmt = nullptr;
+    }
+    if (prev != nullptr) {
+        prev->set_next(stmt_cp);
+    }
+    stmt_cp->set_prev(prev);
+
+    if (StmtFlow::transfer_stmt(stmt_cp)) {
+        stmt_cp->set_next(nullptr);
+        // FIXME set_next to null be default?
+        auto next_split = StmtFlow::transfers_to(stmt_cp);
+        std::cout << "TRANSFER! -> " << next_split->output_file << std::endl;
+//        std::cout << "          -> " << stmt_cp->toString() << std::endl;
+        split->successor_splits.insert(next_split);
+        return true;
+    }
+
+    BlockStmt *bs = dynamic_cast<BlockStmt*>(stmt_cp);
+    if (bs != nullptr) {
+        assert(bs->getEntry() != nullptr);
+        assert(visited.find(bs) == visited.end());
+        std::cout << "...Block" << std::endl;
+        visited.insert(bs);
+        bs->setEntry(bs->getEntry()->clone());
+//        if (continue_split(bs->getEntry(), bs->getEntry()->get_next(), visited)) {
+        if (continue_split(split, nullptr, bs->getEntry(), visited, true, ascend)) {
+            return true;
+        }
+    }
+    IfStmt *ifst = dynamic_cast<IfStmt*>(stmt_cp);
+    if (ifst != nullptr) {
+//        assert(visited.find(ifst) == visited.end());     
+        visited.insert(ifst);
+        std::cout << "...If" << std::endl;
+
+        assert(ifst->get_ifTrue() != nullptr);
+        int total_branches = 2; // Even if there isn't a "false" branch, it's implicitly there but does nothing (importantly, it doesn't transfer)
+        int total_transfers = 0;
+        ifst->set_ifTrue(ifst->get_ifTrue()->clone());
+//        if (continue_split(ifst->get_ifTrue(), ifst->get_ifTrue()->get_next(), visited)) {
+        if (continue_split(split, nullptr, ifst->get_ifTrue(), visited, true, ascend)) {
+            total_transfers += 1;
+        }
+
+        if (ifst->get_ifFalse() != nullptr) {
+            total_branches += 1;
+
+            ifst->set_ifFalse(ifst->get_ifFalse()->clone());
+//            if (continue_split(ifst->get_ifFalse(), ifst->get_ifFalse()->get_next(), visited)) {
+            if (continue_split(split, nullptr, ifst->get_ifFalse(), visited, true, ascend)) {
+                total_transfers += 1;
+            }
+        }
+
+        if (total_branches == total_transfers) {
+            return true;
+        }
+    }
+    SwitchStmt *swst = dynamic_cast<SwitchStmt*>(stmt_cp);
+    if (swst != nullptr) {
+        assert(visited.find(swst) == visited.end());
+        visited.insert(swst);
+        std::cout << "...Switch" << std::endl;
+
+        int total_branches = swst->getCases().size();
+        int total_transfers = 0;
+
+        for (auto c : swst->getCases()) {
+            std::cout << "...Case" << std::endl;
+            if (continue_split(split, nullptr, c.get_fstmt(), visited, true, ascend)) {
+                total_transfers += 1;
+            }
+        }
+
+        if (total_branches == total_transfers) {
+            return true;
+        }
+    }
+
+    if (stmt_cp->get_next() != nullptr) {
+        return continue_split(split, stmt_cp, (FStmt*)/*FIXME type hack*/stmt_cp->get_next(), visited, false, ascend);
+    } else {
+        if (stmt_cp->getContainer() != nullptr &&
+                visited.find((FStmt *)/*FIXME type hack*/stmt_cp->getContainer()) == visited.end()) {
+            if (ascend) {
+                // Computes CFG
+                return ascend_split(split, stmt_cp, stmt_cp, visited);
+            } else {
+                // Computes subgraph of AST
+                return false;
+            }
+        } else {
+            return false;
+        }
+    }
+}
+
+FStmt* Split::effect_split(Split *split) {
+    // Cache the split code, to avoid redoing the splitting if this function is called again?
+    if (split->cleaved != nullptr) {
+        return split->cleaved;
+    } else {
+        std::cout << "Splitting..." << std::endl;
+        std::set<FStmt *> visited;
+        FStmt* pre_result = split->beginning->clone();
+        pre_result->set_prev(nullptr);
+#if 0
+        continue_split(pre_result, pre_result->get_next(), visited, false);
+// FIXME doesn't work if we start at a Transfer node!    
+//        continue_split(nullptr, pre_result, visited, true);
+#endif
+
+        if (StmtFlow::transfer_stmt(pre_result)) {
+            pre_result->keep_split(split);
+            // Otherwise it terminates immediately
+            continue_split(split, pre_result, (FStmt*)/*FIXME type hack*/pre_result->get_next(), visited, false, true);
+        } else {
+            // This must be the "main" entry point
+            continue_split(split, nullptr, pre_result, visited, true, false);
+        }
+
+        FStmt* result = pre_result;
+        const BlockStmt *bs = dynamic_cast<const BlockStmt*>(pre_result);
+        if (bs == nullptr) {
+            result = new BlockStmt (nullptr, std::string(FlightplanConfig::FP_options.flightplanFolder), pre_result, nullptr, nullptr);
+        }
+        split->cleaved = result;
+        std::cout << "Done splitting" << std::endl;
+        return result;
+    }
+}
+
+#if 0
+// Return subset of statements that consist of TransferPoints
+std::set<const FStmt*> StmtFlow::transfers(std::set<const FStmt*> stmts) {
+    std::set<const FStmt*> result;
+    for (auto stmt : stmts) {
+        if (StmtFlow::transfer_stmt(stmt)) {
+                result.insert(stmt);
+        }
+    }
+
+    return result;
+}
+
+// Compute transitive closure of getNext
+std::set<const FStmt*> StmtFlow::TransitClos(const FStmt* stmt) {
+    std::set<const FStmt*> result;
+    std::set<const FStmt*> visited;
+    std::vector<const FStmt*> to_visit = {stmt};
+
+    while (!to_visit.empty()) {
+        stmt = to_visit.front();
+        to_visit.pop_back();
+
+        for (auto new_stmt : StmtFlow::getNext(stmt, visited)) {
+            std::cout << ".";
+            result.insert(new_stmt);
+            if (!StmtFlow::transfer_stmt(stmt)) {
+                // We don't pursue transfers further, since that's pursued inside their splits
+                to_visit.push_back(new_stmt);
+            }
+        }
+    }
+    std::cout << std::endl;
+
+    return result;
+}
+#endif
+
+}
diff --git a/frontends/p4/flightplan_annotate.cpp b/frontends/p4/flightplan_annotate.cpp
new file mode 100644
index 0000000..d26a647
--- /dev/null
+++ b/frontends/p4/flightplan_annotate.cpp
@@ -0,0 +1,189 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+*/
+
+#include <iostream>
+#include <fstream>
+
+#include "lib/path.h"
+#include "lib/cstring.h"
+
+#include "flightplan.h"
+#include "flightplan_annotate.h"
+
+namespace P4 {
+
+std::map<std::string, std::unordered_set<std::string>> FlightplanAnnotate::SegExternMap;
+std::map<std::string, int> FlightplanAnnotate::SegLines;
+std::map<std::string, int> FlightplanAnnotate::AnnotLines;
+int FlightplanAnnotate::ProgLines = 0;
+std::map<std::string, std::string> FlightplanAnnotate::ExternIndex;
+int FlightplanAnnotate::NoJumps = 0;
+bool FlightplanAnnotate::FlyBack = false;
+std::set<std::pair<std::string,std::string>> FlightplanAnnotate::Links;
+std::string FlightplanAnnotate::segment_annotated_control_block;
+std::map<const FStmt*, std::unordered_set<std::string>> FlightplanAnnotate::statement_segment_map;
+
+
+void FlightplanAnnotate::Initialise() {
+  FlightplanAnnotate::add_segment(FlightplanConfig::landing_start);
+}
+
+int FlightplanAnnotate::NoSegments() {
+   return SegExternMap.size();
+}
+
+void FlightplanAnnotate::link(std::string from, std::string to) {
+  FlightplanAnnotate::Links.insert(std::pair<std::string,std::string>(from, to));
+}
+
+void FlightplanAnnotate::EmitResults() {
+  std::cout << "==[ Annotator ]==================" << std::endl;
+  std::cout << "FlightplanAnnotate::NoSegments " << FlightplanAnnotate::NoSegments() << std::endl;
+  std::cout << "FlightplanAnnotate::NoJumps " << FlightplanAnnotate::NoJumps << std::endl;
+  std::cout << "FlightplanAnnotate::ProgLines " << FlightplanAnnotate::ProgLines << std::endl;
+  std::cout << "|FlightplanAnnotate::statement_segment_map| " << FlightplanAnnotate::statement_segment_map.size() << std::endl;
+#if 0
+  for (auto p : FlightplanAnnotate::statement_segment_map) {
+    std::cout << "    " << p.first->toP4String() << std::endl;
+    std::cout << "    ";
+    for (auto segment_name : p.second) {
+        std::cout << " " << segment_name;
+    }
+    std::cout << std::endl;
+  }
+#endif
+  std::cout << "Segment sizes: " << std::endl;
+  int total_prog_lines = 0;
+  int total_annot_lines = 0;
+  for (auto &segline : SegLines) {
+      std::cout << "    Segment " << segline.first << ": Orig lines=" << segline.second << " Annot lines=" << AnnotLines[segline.first] << std::endl;
+      total_prog_lines += segline.second;
+      total_annot_lines += AnnotLines[segline.first];
+  }
+  std::cout << "Total Prog lines " << total_prog_lines << std::endl;
+  std::cout << "Total Annot lines " << total_annot_lines << std::endl;
+
+  std::cout << "Segment arities: " << std::endl;
+  for (auto &segmap : SegExternMap) {
+      std::string segment_name = segmap.first;
+      int from = 0;
+      int to = 0;
+      for (std::pair<std::string,std::string> edge : Links) {
+          if (edge.first == segment_name) {
+              from++;
+          }
+          if (edge.second == segment_name) {
+              to++;
+          }
+      }
+      std::cout << "    Segment " << segment_name << ": from=" << from << " to=" << to << std::endl;
+  }
+
+  if (FlightplanConfig::FP_options.flightplan_DOT_output) {
+      const cstring destination = std::string(FlightplanConfig::FP_options.flightplanFolder + "/" + FlightplanConfig::adjusted_input_filename) + "_annotated.dot";
+      std::cout << "Annotator: writing DOT file:" << destination << std::endl;
+      if (!destination.isNullOrEmpty()) {
+          Util::PathName path(destination);
+          std::ostream *ost = new std::ofstream(path.toString(), std::ios_base::app);
+          *ost << FlightplanAnnotate::toDOT() << std::endl;
+      } else {
+          ::error("Null filename?");
+      }
+  }
+
+  const cstring destination = std::string(FlightplanConfig::FP_options.flightplanFolder + "/" + FlightplanConfig::adjusted_input_filename) + "_annotated.p4";
+  std::cout << "Annotator: writing annotated control-block code:" << destination << std::endl;
+  if (!destination.isNullOrEmpty()) {
+      Util::PathName path(destination);
+      std::ostream *ost = new std::ofstream(path.toString(), std::ios_base::app);
+      *ost << FlightplanAnnotate::segment_annotated_control_block << std::endl;
+  } else {
+      ::error("Null filename?");
+  }
+
+  std::cout << "=================================" << std::endl;
+}
+
+std::string FlightplanAnnotate::toDOT() {
+  std::string result = "digraph G {\ncompound=true;\n";
+  result += FlightplanConfig::landing_start + " [label=\"" + FlightplanConfig::landing_start + "\",color=white,fontcolor=blue];\n";
+  for (const auto& p : FlightplanAnnotate::Links) {
+    result += p.first + " -> " + p.second + ";\n";
+  }
+
+  for (const auto& p : FlightplanAnnotate::SegExternMap) {
+    if (p.first == FlightplanConfig::landing_start) {
+      continue;
+    }
+    result += "subgraph cluster_" + p.first + " {\n";
+    result += p.first + " [label=\"" + p.first + "\",color=white];\n";
+    result += "style=solid;\ncolor=lightgray;\nfontcolor=green;\n";
+
+    result += "subgraph cluster_" + p.first + " {\n";
+    result += "label=\"\";\nstyle=dotted;\ncolor=lightgray;\n";
+
+    for (const auto& extern_name : p.second) {
+      result += extern_name + " [label=\"" + extern_name + "\",color=white];\n";
+    }
+    result += "}\n}\n";
+  }
+
+  result += "}";
+  return result;
+}
+
+void FlightplanAnnotate::add_segment(std::string segment_name) {
+  if (FlightplanAnnotate::SegExternMap.find(segment_name) == FlightplanAnnotate::SegExternMap.end()) {
+      FlightplanAnnotate::SegExternMap.insert(std::pair<std::string,std::unordered_set<std::string>>(segment_name, std::unordered_set<std::string>()));
+      FlightplanAnnotate::SegLines.insert(std::pair<std::string,int>(segment_name, 0));
+      FlightplanAnnotate::AnnotLines.insert(std::pair<std::string,int>(segment_name, 0));
+  } else {
+    throw std::logic_error("add_segment for a segment that already exists");
+  }
+
+}
+
+std::string* FlightplanAnnotate::segment_of_extern(std::string extern_name) {
+  if ( FlightplanAnnotate::ExternIndex.find(extern_name) == FlightplanAnnotate::ExternIndex.end() ) {
+    return nullptr;
+  } else {
+    return &FlightplanAnnotate::ExternIndex[extern_name];
+  }
+}
+
+void FlightplanAnnotate::add_segment_extern(std::string segment_name, std::string extern_name) {
+  FlightplanAnnotate::SegExternMap[segment_name].insert(extern_name);
+  FlightplanAnnotate::ExternIndex.insert(std::pair<std::string,std::string>(extern_name, segment_name));
+}
+
+
+IR::MethodCallStatement* FlightplanAnnotate::flyto(std::string where_to) {
+    if (FlightplanConfig::flyto_expr == nullptr) {
+        auto params = new IR::IndexedVector<IR::Parameter>();
+        auto param = new IR::Parameter(IR::ID("dest", nullptr), IR::Direction::In,
+                                                new IR::Type_InfInt());
+        FlightplanConfig::FP_typeMap->setType(param, param->type);
+        params->push_back(param);
+        auto method_type = new IR::Type_Method(IR::Type_Void::get(), new IR::ParameterList(*params));
+        FlightplanConfig::flyto_expr = new IR::PathExpression(IR::ID(Util::SourceInfo(), FlightplanConfig::flyto_fn));
+
+        auto path = FlightplanConfig::flyto_expr->path;
+        auto decl = new IR::Method(IR::ID(FlightplanConfig::flyto_fn, nullptr), method_type);
+        FlightplanConfig::FP_refMap->setDeclaration(path, decl);
+        FlightplanConfig::FP_typeMap->setType(FlightplanConfig::flyto_expr, method_type);
+    }
+
+    auto landing = new IR::PathExpression(IR::ID(Util::SourceInfo(), where_to));
+    auto args = new IR::Vector<IR::Argument>();
+    auto landing_arg = new IR::Argument(landing);
+    args->push_back(landing_arg);
+    auto mc = new IR::MethodCallExpression(Util::SourceInfo(), FlightplanConfig::flyto_expr, args);
+    auto result = new IR::MethodCallStatement(mc->srcInfo, mc);
+
+    FlightplanConfig::FP_typeMap->setType(result, IR::Type_Void::get());
+    return result;
+}
+
+}
diff --git a/frontends/p4/flightplan_annotate.h b/frontends/p4/flightplan_annotate.h
new file mode 100644
index 0000000..9f0a891
--- /dev/null
+++ b/frontends/p4/flightplan_annotate.h
@@ -0,0 +1,208 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+
+NOTE must be executed after RemoveReturns, since we assume they've been removed.
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_ANNOTATE_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_ANNOTATE_H_
+
+#include <utility>
+#include <stdexcept>
+#include <string>
+#include <vector>
+#include <map>
+#include <unordered_set>
+
+#include "flightplan_externs.h"
+
+namespace P4 {
+
+namespace FlightplanAnnotate {
+   // Mapping from Segment to set of Externs
+   extern std::map<std::string, std::unordered_set<std::string>> SegExternMap;
+   extern int ProgLines;
+   extern std::map<std::string, int> SegLines;
+   extern std::map<std::string, int> AnnotLines;
+   // Mapping from Extern to the Segment in which it has been placed.
+   // NOTE an extern is mapped to a single segment.
+   extern std::map<std::string, std::string> ExternIndex;
+   // No. of jumps made so far.
+   extern int NoJumps;
+   // Whether we should fly back to FlightStart at the end of the program.
+   extern bool FlyBack;
+   // Graph of links between segments.
+   extern std::set<std::pair<std::string,std::string>> Links;
+   // Contains the main control-block code annotated with which segments are "active".
+   extern std::string segment_annotated_control_block;
+
+  //Mapping from statements to the set ofsegments they feature in
+   extern std::map<const FStmt*, std::unordered_set<std::string>> statement_segment_map;
+
+   int NoSegments();
+
+   // Generates P4 AST for flyto a particular Segment.
+   IR::MethodCallStatement* flyto(std::string where_to);
+
+   // Run this once to bring FlightplanAnnotate data structures into initial state.
+   void Initialise();
+
+   // Produce stats related to the annotated program (e.g., number of links).
+   void EmitResults();
+
+   // Link two segments. (This is directed.)
+   void link(std::string from, std::string to);
+
+   // Generate DOT representation of the topology of segments.
+   std::string toDOT();
+
+   // Add a new segment.
+   void add_segment(std::string segment_name);
+
+   // Resolve the Segment to which an extern has been mapped.
+   std::string* segment_of_extern(std::string extern_name);
+
+   // Add an extern to an existing Segment.
+   void add_segment_extern(std::string segment_name, std::string extern_name);
+
+   class Tippy {
+      int generation = 0;
+      int jumps_so_far = 0;
+      Tippy* parent = nullptr;
+      std::vector<Tippy*> children;
+      using SegExternMap = std::map<std::string, std::string>;
+      // The set of Segments we currently might be in, and the last extern that was
+      // called in each one. We use the latter info to find out whether we can "bunch".
+      SegExternMap map;
+      Tippy() {}
+      bool active = true;
+      void deactive() {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          active = false;
+          for (Tippy* child : children) {
+             delete child;
+          }
+          children.clear();
+      }
+    public:
+      void incrementJump() {
+         jumps_so_far++;
+      }
+      int getJumps() const {
+         return jumps_so_far;
+      }
+      bool isActive() {
+         return active;
+      }
+      void widen_tip(std::string segment_name, std::string extern_name) {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          map.insert(std::pair<std::string,std::string>(segment_name, extern_name));
+      }
+      void clear() {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          map.clear();
+      }
+      void retip(std::string segment_name, std::string extern_name) {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          clear();
+          widen_tip(segment_name, extern_name);
+      }
+      void retip_externonly(std::string extern_name) {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          for (auto &tip : map) {
+              map[tip.first] = extern_name;
+          }
+      }
+      void retip_flightstart() {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          retip(FlightplanConfig::landing_start, "");
+      }
+      static Tippy* Initial() {
+          Tippy* t = new Tippy();
+          t->retip_flightstart();
+          return t;
+      }
+      Tippy* sprout() {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          Tippy* t = new Tippy();
+          t->parent = this;
+          t->map = map;
+          t->generation = generation + 1;
+          t->jumps_so_far = jumps_so_far;
+          children.push_back(t);
+          return t;
+      }
+      std::vector<Tippy*> sprout(int n) {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          std::vector<Tippy*> result;
+          for (int i = 0; i < n; ++i) {
+             result.push_back(sprout());
+          }
+          return result;
+      }
+      void fuse() {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          for (auto &tip : map) {
+             parent->widen_tip(tip.first, tip.second);
+             if (jumps_so_far > parent->jumps_so_far) {
+                 parent->jumps_so_far = jumps_so_far;
+             }
+          }
+	  deactive();
+      }
+      void chop() {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+	  deactive();
+      }
+      bool are_definitely_on_FlightStart() {
+        if ((map.size() == 1) && (map.find(FlightplanConfig::landing_start) != map.end())) {
+              // FIXME assert(FlightplanAnnotate::SegExternMap[FlightplanConfig::landing_start] == std::string(""));
+              return true;
+        }
+        return false;
+      }
+      SegExternMap getTip() {
+          return map;
+      }
+      std::string toString() {
+          std::string result;
+          result += " (" + std::to_string(generation) + ") ";
+          result += "{";
+          for (auto &p : map) {
+              result += p.first + "|->" + p.second + " ";
+          }
+          return result + "}";
+      }
+      int getGeneration() {
+          return generation;
+      }
+   };
+
+   void Occur(const FStmt* fstmt, Tippy* state);
+
+} // namespace FlightplanAnnotate
+
+}  // namespace P4
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_ANNOTATE_H_ */
diff --git a/frontends/p4/flightplan_annotator.cpp b/frontends/p4/flightplan_annotator.cpp
new file mode 100644
index 0000000..f570f1f
--- /dev/null
+++ b/frontends/p4/flightplan_annotator.cpp
@@ -0,0 +1,658 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+*/
+
+#include "flightplan_preanalysis.h"
+#include "flightplan_annotator.h"
+
+namespace P4 {
+
+bool calls_table_lookup(const IR::MethodCallStatement* mcs) {
+    const IR::MethodCallExpression* mce = mcs->methodCall;
+    auto mi = P4::MethodInstance::resolve(mce, FlightplanConfig::FP_refMap, FlightplanConfig::FP_typeMap);
+    if (mi->is<P4::ApplyMethod>()) {
+        auto application = mi->to<P4::ApplyMethod>();
+        return application->isTableApply();
+    } else {
+        return false;
+    }
+}
+
+std::string table_lookup_string(const IR::MethodCallStatement* mcs) {
+    const IR::MethodCallExpression* mce = mcs->methodCall;
+    auto mi = P4::MethodInstance::resolve(mce, FlightplanConfig::FP_refMap, FlightplanConfig::FP_typeMap);
+    if (mi->is<P4::ApplyMethod>()) {
+        auto application = mi->to<P4::ApplyMethod>();
+        if (application->isTableApply()) {
+            return std::string(mce->toString());
+        }
+    }
+    throw std::logic_error("table_lookup_string() called on non-table-lookup");
+}
+
+// FIXME there are opportunities to use this function more frequently in the code of Flightplan_Annotator::visit functions
+FStmt* fly_before_stmt(std::string destination, FStmt* fstmt, FlightplanAnnotate::Tippy* state, bool in_place = false) {
+    // Jump BEFORE the statement
+    FStmt* stmt_copy = nullptr;
+    if (!in_place) {
+      stmt_copy = fstmt->clone();
+    } else {
+      stmt_copy = fstmt;
+    }
+    assert(stmt_copy != nullptr);
+    auto dest_path = std::string(FlightplanConfig::FP_options.flightplanFolder);
+    state->incrementJump();
+    FStmt* jump = new Stmt (fstmt->getContainer(), dest_path, FlightplanAnnotate::flyto(destination), nullptr, stmt_copy);
+    if (in_place) {
+      if (stmt_copy->get_prev() != nullptr) {
+        stmt_copy->get_prev()->set_next(jump);
+      }
+      jump->set_prev(stmt_copy->get_prev());
+      jump->set_next(stmt_copy);
+      stmt_copy->set_prev(jump);
+    } else {
+      stmt_copy->set_prev(jump);
+      stmt_copy->set_next(nullptr);
+    }
+    for (const auto& p : state->getTip()) {
+      FlightplanAnnotate::link(p.first, destination);
+      FlightplanAnnotate::AnnotLines[p.first] += 1;
+    }
+    state->retip_flightstart();
+    return new BlockStmt (fstmt->getContainer(), dest_path, jump, fstmt->get_prev(), fstmt->get_next());
+}
+
+FStmt* fly_FlightStart_before_stmt(FStmt* fstmt, FlightplanAnnotate::Tippy* state) {
+    // Jump BEFORE the statement
+    FStmt* stmt_copy = fstmt->clone();
+    auto dest_path = std::string(FlightplanConfig::FP_options.flightplanFolder);
+    state->incrementJump();
+    FStmt* jump = new Stmt (fstmt->getContainer(), dest_path, FlightplanAnnotate::flyto(FlightplanConfig::landing_start), nullptr, stmt_copy);
+    stmt_copy->set_prev(jump);
+    stmt_copy->set_next(nullptr);
+    for (const auto& p : state->getTip()) {
+      FlightplanAnnotate::link(p.first, FlightplanConfig::landing_start);
+      FlightplanAnnotate::AnnotLines[p.first] += 1;
+    }
+    state->retip_flightstart();
+    return new BlockStmt (fstmt->getContainer(), dest_path, jump, fstmt->get_prev(), fstmt->get_next());
+}
+
+FStmt* fly_FlightStart_after_stmt(FStmt* fstmt, FlightplanAnnotate::Tippy* state) {
+    // Jump AFTER the statement
+    FStmt* stmt_copy = fstmt->clone();
+    auto dest_path = std::string(FlightplanConfig::FP_options.flightplanFolder);
+    state->incrementJump();
+    FStmt* jump = new Stmt (fstmt->getContainer(), dest_path, FlightplanAnnotate::flyto(FlightplanConfig::landing_start), stmt_copy, nullptr);
+    stmt_copy->set_prev(nullptr);
+    stmt_copy->set_next(jump);
+    for (const auto& p : state->getTip()) {
+      FlightplanAnnotate::link(p.first, FlightplanConfig::landing_start);
+      FlightplanAnnotate::AnnotLines[p.first] += 1;
+    }
+    state->retip_flightstart();
+    return new BlockStmt (fstmt->getContainer(), dest_path, stmt_copy, fstmt->get_prev(), fstmt->get_next());
+}
+
+void append_indentation(FlightplanAnnotate::Tippy* state) {
+    for (int i = 0; i < state->getGeneration(); ++i) {
+      FlightplanAnnotate::segment_annotated_control_block += "  ";
+    }
+}
+
+void append_analysis_metadata(FlightplanAnnotate::Tippy* state) {
+    FlightplanAnnotate::segment_annotated_control_block += "// width=" +
+	    std::to_string(state->getTip().size()) + ": " + state->toString() + "\n";
+}
+
+void FlightplanAnnotate::Occur(const FStmt* fstmt, FlightplanAnnotate::Tippy* state) {
+    if (FlightplanAnnotate::statement_segment_map.find(fstmt) == FlightplanAnnotate::statement_segment_map.end()) {
+        std::unordered_set<std::string> emptyset;
+        FlightplanAnnotate::statement_segment_map.insert(std::pair<const FStmt*, std::unordered_set<std::string>>(fstmt, emptyset));
+    }
+
+    for (auto &tip : state->getTip()) {
+        FlightplanAnnotate::statement_segment_map[fstmt].insert(tip.first);
+    }
+}
+
+FStmt* Flightplan_Annotator::visit(Stmt* fstmt, FlightplanAnnotate::Tippy* state) {
+    Occur(fstmt, state);
+
+    FlightplanAnnotate::ProgLines += 1;
+
+    StatementAnalysisMetadata metadata(fstmt, getAnalysisState(), state);
+
+    append_indentation(state);
+    append_analysis_metadata(state);
+    append_indentation(state);
+    FlightplanAnnotate::segment_annotated_control_block += metadata.toString();
+    append_indentation(state);
+    FlightplanAnnotate::segment_annotated_control_block += fstmt->toP4String();
+    FlightplanAnnotate::segment_annotated_control_block += " /* " + fstmt->original->getSourceInfo().toPositionString() + " */\n";
+
+    //Check statement for expression involving metadata (ingress/egress ports)
+    if (!FlightplanConfig::FP_options.flightplan_headered) {
+        if (metadata.jumps != 0 && metadata.ingress) {
+            throw std::logic_error("Unsplittable: cannot access ingress post-jump -- " + fstmt->original->getSourceInfo().toPositionString());
+        }
+        if (metadata.egress || metadata.ingress) {
+          if (!FlightplanExterns::excepted_subset(metadata.remaining_externs).empty()) {
+            throw std::logic_error("Unsplittable: cannot access ingress/egress pre-extern -- " + fstmt->original->getSourceInfo().toPositionString());
+          } else {
+              if (state->are_definitely_on_FlightStart()) {
+                  std::cout << "Annotator: already in FlightStart at metadata-changing: " << fstmt->toP4String() << std::endl;
+                  for (auto &tip : state->getTip()) {
+                      FlightplanAnnotate::SegLines[tip.first] += 1;
+                  }
+                  return fstmt->clone();
+              } else {
+                  std::cout << "Annotator: flyto(FlightStart) because of metadata-changing: " << fstmt->toP4String() << std::endl;
+                  FlightplanAnnotate::SegLines[FlightplanConfig::landing_start] += 1;
+                  return fly_FlightStart_before_stmt(fstmt, state);
+              }
+          }
+        }
+    } else {
+        if (metadata.egress) {
+             FlightplanAnnotate::FlyBack = true;
+        }
+    }
+
+    auto pre_statement = fstmt->original;
+    if (pre_statement->is<IR::Declaration>()) {
+        for (auto &tip : state->getTip()) {
+            FlightplanAnnotate::SegLines[tip.first] += 1;
+        }
+        return fstmt->clone();
+    } else if (pre_statement->is<IR::Statement>()) {
+        auto stmt = &pre_statement->as<IR::Statement>();
+
+        if (stmt->is<IR::MethodCallStatement>()) {
+            auto mcs = &stmt->as<IR::MethodCallStatement>();
+
+            if (calls_table_lookup(mcs)) {
+                if (FlightplanConfig::FP_options.flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::Features) {
+                  // Check if this table lookup is one of the features we've been asked to offload
+                  for (std::string table_name : FlightplanConfig::FP_options.flightplan_table_offload) {
+//                      if (table_name + ".apply" == table_lookup_string(mcs)) {
+                      if (table_name + "." + IR::IApply::applyMethodName == table_lookup_string(mcs)) {
+                          std::cout << "Annotator: feature offload: table " << table_name << std::endl;
+                           std::string segment_name = "Offload"/*FIXME const*/;
+                          FlightplanAnnotate::add_segment(segment_name);
+                          //return fly_FlightStart_after_stmt((FStmt*)((BlockStmt*)fly_before_stmt("Offload", fstmt, state))->getLast(), state);   
+
+                          // FIXME gather both flyto's into the same block, currently it looks a bit odd (but it's semantically fine).
+                          auto pre_result = fly_before_stmt(segment_name, fstmt, state, true);
+                          return fly_FlightStart_after_stmt((FStmt*)pre_result, state);
+                      }
+                  }
+#if 0
+#endif
+                } else {
+                  if (state->are_definitely_on_FlightStart()) {
+                      std::cout << "Annotator: already in FlightStart at table lookup: " << table_lookup_string(mcs) << std::endl;
+                      for (auto &tip : state->getTip()) {
+                          FlightplanAnnotate::SegLines[tip.first] += 1;
+                      }
+                      return fstmt->clone();
+                  } else {
+                      std::cout << "Annotator: flyto(FlightStart) because of table lookup: " << table_lookup_string(mcs) << std::endl;
+                      FlightplanAnnotate::SegLines[FlightplanConfig::landing_start] += 1;
+                      return fly_FlightStart_before_stmt(fstmt, state);
+                  }
+                }
+            }
+
+            auto dest_path = std::string(FlightplanConfig::FP_options.flightplanFolder);
+            auto container = fstmt->container;
+            auto prev = fstmt->get_prev();
+            auto next = fstmt->get_next();
+            std::string segment_name;
+
+            if (FlightplanExterns::calls_extern_function(mcs)) {
+                auto extern_name = FlightplanExterns::extern_function_name(mcs);
+                if (FlightplanConfig::FP_options.flightplan_exclusions.find(extern_name) != FlightplanConfig::FP_options.flightplan_exclusions.end()) {
+                    if (state->are_definitely_on_FlightStart()) {
+                        std::cout << "Annotator: already in FlightStart at excluded extern: " << extern_name << std::endl;
+                        for (auto &tip : state->getTip()) {
+                            FlightplanAnnotate::SegLines[tip.first] += 1;
+                        }
+                        return fstmt->clone();
+                    } else {
+                        std::cout << "Annotator: flyto(FlightStart) because of excluded extern: " << extern_name << std::endl;
+                        for (auto &tip : state->getTip()) {
+                            FlightplanAnnotate::AnnotLines[tip.first] += 1;
+                        }
+                        FlightplanAnnotate::SegLines[FlightplanConfig::landing_start] += 1;
+                        return fly_FlightStart_before_stmt(fstmt, state);
+                    }
+                }
+
+                // Check for bunching
+                bool can_bunch = true;
+                bool not_vacuous = false;
+                for (auto &tip : state->getTip()) {
+                    std::string previous_E = tip.second;
+                    bool bunchable = false;
+                    for (auto &bunch : FlightplanConfig::FP_options.flightplan_bunched) {
+                        not_vacuous = true;
+                        if (bunch.find(extern_name) != bunch.end() && bunch.find(previous_E) != bunch.end()) {
+                            bunchable = true;
+                        } else {
+                            bunchable = false;
+                        }
+
+                        if (!bunchable) {
+                            can_bunch = false;
+                            break;
+                        }
+                    }
+                    if (!can_bunch) {
+                        break;
+                    }
+                }
+
+                if (can_bunch && not_vacuous) {
+                    std::cout << "Annotator: bunching the call to " << extern_name << std::endl;
+                    for (auto &tip : state->getTip()) {
+                        FlightplanAnnotate::SegLines[tip.first] += 1;
+                        FlightplanAnnotate::add_segment_extern(tip.first, extern_name);
+                    }
+                    state->retip_externonly(extern_name);
+                    return fstmt->clone();
+                }
+
+                auto orig_stmt = new Stmt (container, dest_path, mcs, prev, next);
+                auto suffix = std::to_string(FlightplanAnnotate::NoSegments());
+                auto looked_up = FlightplanAnnotate::segment_of_extern(extern_name);
+                if (nullptr == looked_up) {
+                  segment_name = "Segment_" + suffix;
+                } else {
+                  segment_name = *looked_up;
+                }
+
+                switch (FlightplanConfig::FP_options.flightplan_annotation_mode) {
+                    case CompilerOptions::FlightplanAnnotationMode::Features:
+                        {
+                            return fstmt->clone();
+                        }
+                    case CompilerOptions::FlightplanAnnotationMode::EagerOffload:
+                        {
+                            state->incrementJump();
+                            auto flyto_segment_stmt = new Stmt (container, dest_path, FlightplanAnnotate::flyto(segment_name), prev, orig_stmt);
+                            orig_stmt->set_prev(flyto_segment_stmt);
+
+                            orig_stmt->set_next(nullptr);
+                            flyto_segment_stmt->set_next(orig_stmt);
+                            flyto_segment_stmt->set_prev(nullptr);
+
+                            state->incrementJump();
+                            orig_stmt->set_next(new Stmt (container, dest_path, FlightplanAnnotate::flyto(FlightplanConfig::landing_start), orig_stmt, nullptr));
+
+                            if (nullptr == looked_up) {
+                              FlightplanAnnotate::add_segment(segment_name);
+                              FlightplanAnnotate::add_segment_extern(segment_name, extern_name);
+                              std::cout << "New segment " << segment_name << " |-> " << extern_name << std::endl;
+                            }
+
+                            for (const auto& p : state->getTip()) {
+                              FlightplanAnnotate::link(p.first, segment_name);
+                              FlightplanAnnotate::AnnotLines[p.first] += 1;
+                            }
+                            state->retip(segment_name, extern_name);
+                            FlightplanAnnotate::NoJumps += 1;
+                            FlightplanAnnotate::SegLines[segment_name] += 1;
+                            FlightplanAnnotate::link(segment_name, FlightplanConfig::landing_start);
+                            state->retip_flightstart();
+                            FlightplanAnnotate::NoJumps += 1;
+                            FlightplanAnnotate::AnnotLines[segment_name] += 1;
+
+                            return new BlockStmt (container, dest_path, flyto_segment_stmt, prev, next);
+                        }
+                    case CompilerOptions::FlightplanAnnotationMode::InertialOffload:
+                        {
+                            FStmt* jump_to_flightstart = nullptr;
+                            if (!state->are_definitely_on_FlightStart()) {
+                                std::cout << "Annotator: flyto(FlightStart) just before inertial offload" << std::endl;
+
+                                FlightplanAnnotate::NoJumps += 1;
+
+                                auto dest_path = std::string(FlightplanConfig::FP_options.flightplanFolder);
+                                state->incrementJump();
+                                jump_to_flightstart = new Stmt (fstmt->getContainer(), dest_path, FlightplanAnnotate::flyto(FlightplanConfig::landing_start), nullptr, nullptr);
+                                for (const auto& p : state->getTip()) {
+                                  FlightplanAnnotate::link(p.first, FlightplanConfig::landing_start);
+                                  FlightplanAnnotate::AnnotLines[p.first] += 1;
+                                }
+                                state->retip_flightstart();
+                            }
+
+                            FStmt* block_start = nullptr;
+                            FStmt* flyto_segment_stmt = nullptr;
+			    if (jump_to_flightstart != nullptr) {
+                                   block_start = jump_to_flightstart;
+                                   state->incrementJump();
+				   flyto_segment_stmt = new Stmt (container, dest_path, FlightplanAnnotate::flyto(segment_name), jump_to_flightstart, orig_stmt);
+                                   jump_to_flightstart->set_next(flyto_segment_stmt);
+			    } else {
+                                   state->incrementJump();
+				   flyto_segment_stmt = new Stmt (container, dest_path, FlightplanAnnotate::flyto(segment_name), nullptr, orig_stmt);
+                                   block_start = flyto_segment_stmt;
+			    }
+
+                            orig_stmt->set_prev(flyto_segment_stmt);
+                            orig_stmt->set_next(nullptr);
+                            flyto_segment_stmt->set_next(orig_stmt);
+
+                            FlightplanAnnotate::NoJumps += 1;
+                            FlightplanAnnotate::AnnotLines[FlightplanConfig::landing_start] += 1;
+
+                            if (nullptr == looked_up) {
+                              FlightplanAnnotate::add_segment(segment_name);
+                              FlightplanAnnotate::add_segment_extern(segment_name, extern_name);
+                              std::cout << "New segment " << segment_name << " |-> " << extern_name << std::endl;
+                            }
+                            FlightplanAnnotate::SegLines[segment_name] += 1;
+
+                            FlightplanAnnotate::link(FlightplanConfig::landing_start, segment_name);
+                            state->retip(segment_name, extern_name);
+
+                            return new BlockStmt (container, dest_path, block_start, prev, next);
+                        }
+                    case CompilerOptions::FlightplanAnnotationMode::Chain:
+                        {
+                            state->incrementJump();
+                            auto flyto_segment_stmt = new Stmt (container, dest_path, FlightplanAnnotate::flyto(segment_name), prev, orig_stmt);
+                            orig_stmt->set_prev(flyto_segment_stmt);
+
+                            orig_stmt->set_next(nullptr);
+                            flyto_segment_stmt->set_next(orig_stmt);
+                            flyto_segment_stmt->set_prev(nullptr);
+
+                            if (nullptr == looked_up) {
+                              FlightplanAnnotate::add_segment(segment_name);
+                              FlightplanAnnotate::add_segment_extern(segment_name, extern_name);
+                              std::cout << "New segment " << segment_name << " |-> " << extern_name << std::endl;
+                            }
+                            FlightplanAnnotate::NoJumps += 1;
+                            FlightplanAnnotate::SegLines[segment_name] += 1;
+
+                            for (const auto& p : state->getTip()) {
+                              FlightplanAnnotate::link(p.first, segment_name);
+                              FlightplanAnnotate::AnnotLines[p.first] += 1;
+                            }
+                            state->retip(segment_name, extern_name);
+
+                            return new BlockStmt (container, dest_path, flyto_segment_stmt, prev, next);
+                        }
+                    default:
+                        throw std::logic_error("Impossible");
+                }
+
+
+                state->incrementJump();
+                auto flyto_segment_stmt = new Stmt (container, dest_path, FlightplanAnnotate::flyto(segment_name), prev, orig_stmt);
+                orig_stmt->set_prev(flyto_segment_stmt);
+
+                orig_stmt->set_next(nullptr);
+                flyto_segment_stmt->set_next(orig_stmt);
+                flyto_segment_stmt->set_prev(nullptr);
+
+                state->incrementJump();
+                orig_stmt->set_next(new Stmt (container, dest_path, FlightplanAnnotate::flyto(FlightplanConfig::landing_start), orig_stmt, nullptr));
+
+                if (nullptr == looked_up) {
+                  FlightplanAnnotate::add_segment(segment_name);
+                  FlightplanAnnotate::add_segment_extern(segment_name, extern_name);
+                  std::cout << "New segment " << segment_name << " |-> " << extern_name << std::endl;
+                }
+                FlightplanAnnotate::NoJumps += 2;
+
+                for (const auto& p : state->getTip()) {
+                  FlightplanAnnotate::link(p.first, segment_name);
+                }
+                state->retip(segment_name, extern_name);
+                FlightplanAnnotate::link(segment_name, FlightplanConfig::landing_start);
+                state->retip_flightstart();
+
+                return new BlockStmt (container, dest_path, flyto_segment_stmt, prev, next);
+            }
+
+            return new Stmt (container, dest_path, mcs, prev, next);
+        } else if (stmt->is<IR::ReturnStatement>() || stmt->is<IR::ExitStatement>() || ForwardStatementGatherer::sets_hasReturned(stmt)) {
+            append_indentation(state);
+            FlightplanAnnotate::segment_annotated_control_block += "// End of path\n";
+            if (!state->are_definitely_on_FlightStart() &&
+                    (FlightplanAnnotate::FlyBack ||
+                     FlightplanConfig::FP_options.flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::EagerOffload ||
+                     FlightplanConfig::FP_options.flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::InertialOffload)) {
+                    std::cout << "Annotator: returning to FlightStart because of Offload mode or FlyBack" << std::endl;
+                    for (auto &tip : state->getTip()) {
+                        FlightplanAnnotate::AnnotLines[tip.first] += 1;
+                    }
+                    FlightplanAnnotate::SegLines[FlightplanConfig::landing_start] += 1;
+                    auto result = fly_FlightStart_before_stmt(fstmt, state);
+                    state->chop();
+                    return result;
+            } else {
+                for (auto &tip : state->getTip()) {
+                    FlightplanAnnotate::SegLines[tip.first] += 1;
+                }
+                state->chop();
+                return fstmt->clone();
+            }
+        } else {
+            for (auto &tip : state->getTip()) {
+                FlightplanAnnotate::SegLines[tip.first] += 1;
+            }
+            return fstmt->clone();
+        }
+    }
+
+    throw std::logic_error("Impossible");
+}
+
+bool is_sought_header_type_guard(const IR::Expression* expr) {
+    if (expr->is<IR::MethodCallExpression>()) {
+       auto mce = &expr->as<IR::MethodCallExpression>();
+       if (mce->method->is<IR::Member>()) {
+           auto member = &mce->method->as<IR::Member>();
+
+           if (std::string(member->member.originalName) == std::string(IR::Type_Header::isValid)) {
+               if (member->expr->is<IR::ArrayIndex>()) {
+                   auto ai = &member->expr->as<IR::ArrayIndex>();
+
+                   if (ai->type->is<IR::Type_Header>()) {
+                       auto tyh = &ai->type->as<IR::Type_Header>();
+
+                       for (std::string header_type : FlightplanConfig::FP_options.flightplan_header_offload) {
+                           if (header_type == std::string(tyh->getName().originalName)) {
+                               return true;
+                           }
+                       }
+                   }
+               }
+           }
+       }
+    }
+    return false;
+}
+
+FStmt* Flightplan_Annotator::visit(BlockStmt* fstmt, FlightplanAnnotate::Tippy* state) {
+    Occur(fstmt, state);
+    BlockStmt* result = (BlockStmt*)fstmt->clone();
+
+    FStmt* cursor = fstmt->getEntry();
+    FStmt* prev = nullptr;
+    result->setEntry(nullptr);
+
+    auto this_state = state->sprout();
+
+    append_indentation(state);
+    FlightplanAnnotate::segment_annotated_control_block += "{\n";
+
+    //rewrite prev + next as we go along
+    while (cursor != nullptr) {
+        FStmt* subresult = process(cursor, this_state);
+        subresult->set_next(nullptr);
+        subresult->container = result;
+        if (result->getEntry() == nullptr) {
+            result->setEntry(subresult);
+            assert(prev == nullptr);
+            //assert(subresult->get_prev() == nullptr);
+            subresult->set_prev(nullptr);
+        } else {
+            assert(prev != nullptr);
+            prev->set_next(subresult);
+            subresult->set_prev(prev);
+        }
+
+        if (!this_state->isActive()) {
+            break;
+        }
+
+        prev = subresult;
+        cursor = cursor->next;
+    }
+
+    if (this_state->isActive()) {
+        this_state->fuse();
+    }
+
+    append_indentation(state);
+    FlightplanAnnotate::segment_annotated_control_block += "}\n";
+
+    // Do the post-program process (i.e., after the last line of the program)
+    if (state->getGeneration() == 0) {
+        assert(fstmt->get_next() == nullptr);
+        std::cout << "Annotator: calling end-of-program handler" << std::endl;
+        FlightplanAnnotate::segment_annotated_control_block += "// Ending the program";
+
+        switch (FlightplanConfig::FP_options.flightplan_annotation_mode) {
+            case CompilerOptions::FlightplanAnnotationMode::Features:
+            case CompilerOptions::FlightplanAnnotationMode::EagerOffload:
+            {
+              assert(state->are_definitely_on_FlightStart());
+              break;
+            }
+            case CompilerOptions::FlightplanAnnotationMode::InertialOffload:
+            {
+              if (state->are_definitely_on_FlightStart()) {
+                  std::cout << "Annotator: already in FlightStart at end-of-program." << std::endl;
+                  break;
+              } else {
+                  std::cout << "Annotator: flyto(FlightStart) at end-of-program" << std::endl;
+                  return fly_FlightStart_after_stmt(result, state);
+              }
+            }
+            case CompilerOptions::FlightplanAnnotationMode::Chain:
+            {
+              if (FlightplanAnnotate::FlyBack) {
+                if (state->are_definitely_on_FlightStart()) {
+                    std::cout << "Annotator: already in FlightStart at end-of-program." << std::endl;
+                } else {
+                    std::cout << "Annotator: flyto(FlightStart) at end-of-program" << std::endl;
+                    return fly_FlightStart_after_stmt(result, state);
+                }
+              }
+              break;
+            }
+            default:
+                throw std::logic_error("Impossible");
+        }
+
+    }
+
+    return result;
+}
+
+FStmt* Flightplan_Annotator::visit(IfStmt* fstmt, FlightplanAnnotate::Tippy* state) {
+    Occur(fstmt, state);
+    if (is_sought_header_type_guard(fstmt->getCondition())) {
+        std::cout << "Annotator: feature offload: header " << FStmt::toP4String(fstmt->getCondition()) << std::endl;
+        // FIXME look instead fstmt to find out of the offload can indeed occur -- e.g., must not reference state that cannot easily be moved to the other target.  
+        std::string segment_name = "Offload"/*FIXME const*/;
+        FlightplanAnnotate::add_segment(segment_name);
+        // FIXME gather both flyto's into the same block, currently it looks a bit odd (but it's semantically fine).
+        auto pre_result = fly_before_stmt(segment_name, fstmt, state, true);
+        return fly_FlightStart_after_stmt((FStmt*)pre_result, state);
+    }
+
+    IfStmt* result = (IfStmt*)fstmt->clone();
+    std::vector<FlightplanAnnotate::Tippy*> this_state = state->sprout(2);
+
+    FlightplanAnnotate::segment_annotated_control_block += "\n";
+    append_indentation(state);
+    append_analysis_metadata(state);
+    append_indentation(state);
+    FlightplanAnnotate::segment_annotated_control_block += "if (";
+    FlightplanAnnotate::segment_annotated_control_block += FStmt::toP4String(fstmt->getCondition());
+    FlightplanAnnotate::segment_annotated_control_block += ")\n";
+
+    assert (result->ifTrue != nullptr);
+    result->ifTrue = process(fstmt->ifTrue, this_state[0]);
+
+    if (result->ifFalse != nullptr) {
+        append_indentation(state);
+        FlightplanAnnotate::segment_annotated_control_block += "else\n";
+        result->ifFalse = process(fstmt->ifFalse, this_state[1]);
+    }
+
+    state->clear();
+
+    for (auto &branch_state : this_state) {
+        if (branch_state->isActive()) {
+            branch_state->fuse();
+        }
+    }
+
+    return result;
+}
+
+FStmt* Flightplan_Annotator::visit(SwitchStmt* fstmt, FlightplanAnnotate::Tippy* state) {
+    Occur(fstmt, state);
+    SwitchStmt* result = (SwitchStmt*)fstmt->clone();
+    std::vector<SwitchStmt::Case> cases = fstmt->getCases();
+    std::vector<FlightplanAnnotate::Tippy*> this_state = state->sprout(cases.size());
+
+    FlightplanAnnotate::segment_annotated_control_block += "\n";
+    append_indentation(state);
+    append_analysis_metadata(state);
+    append_indentation(state);
+    FlightplanAnnotate::segment_annotated_control_block += "switch (";
+    FlightplanAnnotate::segment_annotated_control_block += FStmt::toP4String(fstmt->getExpression());
+    FlightplanAnnotate::segment_annotated_control_block += ") {\n";
+
+    for (unsigned int i = 0; i < cases.size(); ++i) {
+        append_indentation(state);
+        FlightplanAnnotate::segment_annotated_control_block += "case ";
+        FlightplanAnnotate::segment_annotated_control_block += FStmt::toP4String(cases[i].getLabel());
+        FlightplanAnnotate::segment_annotated_control_block += ":\n";
+        result->setCaseStatement(i, process((FStmt*)cases[i].get_fstmt(), this_state[i]));
+    }
+
+    append_indentation(state);
+    FlightplanAnnotate::segment_annotated_control_block += "}\n";
+
+    state->clear();
+
+    for (auto &branch_state : this_state) {
+        if (branch_state->isActive()) {
+            branch_state->fuse();
+        }
+    }
+
+    return result;
+}
+
+FStmt* Flightplan_Annotator::visit(EntryPoint*, FlightplanAnnotate::Tippy*) {
+    throw std::logic_error("Unsupported");
+}
+
+FStmt* Flightplan_Annotator::visit(TransferPoint*, FlightplanAnnotate::Tippy*) {
+    throw std::logic_error("Unsupported");
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan_annotator.h b/frontends/p4/flightplan_annotator.h
new file mode 100644
index 0000000..da5aeee
--- /dev/null
+++ b/frontends/p4/flightplan_annotator.h
@@ -0,0 +1,390 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_ANNOTATOR_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_ANNOTATOR_H_
+
+#include <queue>
+#include <string>
+#include <vector>
+
+#include "flightplan_annotate.h"
+#include "flightplan_convert.h"
+
+namespace P4 {
+class AnalysisState {
+ private:
+  bool self_created_relation = false;
+  unsigned long num_of_statements = 0;
+  unsigned long num_of_paths = 1;
+  std::map<const FStmt*, unsigned long>* path_occurrences;
+ public:
+  using seq_relation = std::map<const FStmt*, std::set<const FStmt*>>;
+  seq_relation* relation;
+
+  std::set<const FStmt*>* pending;
+
+  AnalysisState() {
+    relation = new std::map<const FStmt*, std::set<const FStmt*>>();
+    path_occurrences = new std::map<const FStmt*, unsigned long>();
+    self_created_relation = true;
+    this->relation = relation;
+    pending = new std::set<const FStmt*>();
+  }
+  AnalysisState(seq_relation* relation) {
+    this->relation = relation;
+    pending = new std::set<const FStmt*>();
+    path_occurrences = new std::map<const FStmt*, unsigned long>();
+  }
+  AnalysisState(seq_relation* relation, std::set<const FStmt*>* pending) {
+    this->relation = relation;
+    this->pending = pending;
+  }
+  ~AnalysisState() {
+    if (self_created_relation) {
+        delete relation;
+        delete path_occurrences;
+    }
+    delete pending;
+  }
+  AnalysisState* clone() {
+    AnalysisState* as = new AnalysisState(relation);
+    as->path_occurrences = this->path_occurrences;
+    as->num_of_paths = this->num_of_paths; // Paths continue to flow
+    as->num_of_statements = 0; // Count of statements is reset, to avoid double-counting statements after a branch.
+    for (auto &from_pending : *this->pending) {
+      as->pending->insert(from_pending);
+    }
+    return as;
+  }
+  void incrementStatements() {
+    this->num_of_statements++;
+  }
+  void incrementPaths() {
+    this->num_of_paths++;
+  }
+  void resetNumOfPaths() {
+    // This is called before a set of merges from nested statements (i.e., if or switch)
+    this->num_of_paths = 0;
+  }
+  void Occur(const FStmt* fstmt) {
+    assert(path_occurrences->find(fstmt) == path_occurrences->end());
+    path_occurrences->insert(std::pair<const FStmt*, unsigned long>(fstmt, num_of_paths));
+  }
+  unsigned long NoOccurances(const FStmt* fstmt) {
+    return (*path_occurrences)[fstmt];
+  }
+  void merge(AnalysisState* from) {
+    assert(from->relation == this->relation);
+    this->num_of_paths += from->num_of_paths;
+    this->num_of_statements += from->num_of_statements;
+    for (auto &from_pending : *from->pending) {
+      this->pending->insert(from_pending);
+    }
+  }
+  std::set<const FStmt*> transitive_closure(const FStmt* fstmt) {
+    std::set<const FStmt*> result;
+    std::queue<const FStmt*> pending;
+    std::set<const FStmt*> visited;
+
+    pending.push(fstmt);
+    while (!pending.empty()) {
+      const FStmt* elem = pending.front();
+      pending.pop();
+
+      if (visited.find(elem) == visited.end()) {
+        // We'll already have visited a node if it follows a convergence
+        // between different paths -- e.g., after an if-branch.
+        visited.insert(elem);
+      }
+
+      std::set<const FStmt*> nexts = (*relation)[elem];
+      for (const FStmt* next : nexts) {
+        if (visited.find(next) == visited.end()) {
+           // No need to consider a node if we've already visited it.
+           pending.push(next);
+        }
+      }
+      if (elem != fstmt) {
+        result.insert(elem);
+      }
+    }
+    return result;
+  }
+  std::string toDOT() {
+    int idx = 0;
+    std::string result = "digraph G {\n";
+    std::map<const FStmt*, std::string> map;
+
+    for (const auto& p : *relation) {
+      if (map.find(p.first) == map.end()) {
+        map.insert(std::pair<const FStmt*, std::string>(p.first, "n" + std::to_string(idx)));
+        idx++;
+      }
+
+      result += map[p.first] + " [label=\"" + p.first->toP4String() + "\",color=white,fontcolor=blue];\n";
+    }
+
+    for (const auto& p : *relation) {
+      for (const auto& to : p.second) {
+        result += map[p.first] + " -> " + map[to] + ";\n";
+      }
+    }
+
+    result += "}";
+    return result;
+  }
+    void saveDOTfile() {
+      const cstring destination = std::string(FlightplanConfig::FP_options.flightplanFolder + "/" + FlightplanConfig::adjusted_input_filename) + "_control_flow.dot";
+      std::cout << "AnalysisState: writing DOT file:" << destination << std::endl;
+      if (!destination.isNullOrEmpty()) {
+          Util::PathName path(destination);
+          std::ostream *ost = new std::ofstream(path.toString(), std::ios_base::app);
+          *ost << this->toDOT() << std::endl;
+      } else {
+          ::error("Null filename?");
+      }
+    }
+    void EmitResults() {
+      std::cout << "==[ AnalysisState ]==================" << std::endl;
+      std::cout << "num_of_statements " << num_of_statements << std::endl;
+      std::cout << "num_of_paths " << num_of_paths << std::endl;
+      std::cout << "|relation| " << relation->size() << std::endl;
+      std::cout << "|pending| " << pending->size() << std::endl;
+      if (pending->size() > 0) {
+        for (const FStmt* fstmt : *pending) {
+            std::cout << "    " << fstmt->toP4String() << std::endl;
+        }
+      }
+      std::cout << "|path_occurrences| " << path_occurrences->size() << std::endl;
+#if 0
+      for (std::pair<const FStmt*, unsigned long> p : *path_occurrences) {
+          std::cout << "    " << p.first->toP4String() << " : " << p.second << std::endl;
+      }
+#endif
+      std::cout << "=====================================" << std::endl;
+    }
+};
+
+class Flightplan_Annotator : public FStmtAnalyse<FStmt*, FlightplanAnnotate::Tippy*> {
+ private:
+    AnalysisState* analysis_state = nullptr;
+ public:
+    Flightplan_Annotator(AnalysisState* analysis_state) : analysis_state(analysis_state) {}
+    AnalysisState* getAnalysisState() {
+      return analysis_state;
+    }
+    FStmt* visit(Stmt* fstmt, FlightplanAnnotate::Tippy* state) override;
+    FStmt* visit(BlockStmt* fstmt, FlightplanAnnotate::Tippy* state) override;
+    FStmt* visit(IfStmt* fstmt, FlightplanAnnotate::Tippy* state) override;
+
+    FStmt* visit(SwitchStmt* fstmt, FlightplanAnnotate::Tippy* state) override;
+
+    // We shouldn't encounter these during annotation.
+    FStmt* visit(EntryPoint* fstmt, FlightplanAnnotate::Tippy* state) override;
+    FStmt* visit(TransferPoint* fstmt, FlightplanAnnotate::Tippy* state) override;
+};
+
+class ExpressionAnalyser : public Inspector {
+ private:
+    int ingress = 0;
+    int egress = 0;
+ public:
+    int getIngress() const {
+        return ingress;
+    }
+    int getEgress() const {
+        return egress;
+    }
+    explicit ExpressionAnalyser() {
+        setName("ExpressionAnalyser");
+    }
+#if 0
+    bool preorder(const IR::PathExpression* p) override {
+        std::string s = std::string(p->toString());
+        if (s == "ingress") {
+          ingress++;
+        } else if (s == "egress") {
+          egress++;
+        }
+        return false;
+    }
+#else
+    bool preorder(const IR::Member* p) override {
+        std::string s = std::string(p->member.toString());
+        if (s == "ingress_port") {
+          ingress++;
+        } else if (s == "egress_port") {
+          egress++;
+        }
+        return false;
+    }
+#endif
+    static std::pair<int, int> check_metadata(const IR::Node* node) {
+        auto ea = new ExpressionAnalyser();
+        ea->init_apply(node);
+        ea->apply_visitor(node);
+        ea->end_apply(node);
+        int ingress = ea->getIngress();
+        int egress = ea->getEgress();
+        delete ea;
+        return std::pair<int, int>(ingress, egress);
+    }
+};
+
+struct StatementAnalysisMetadata {
+   int ingress = 0;
+   int egress = 0;
+   int statements_left = 0;
+   int externs_remaining = 0;
+   int unexcepted_externs_remaining = 0;
+   int jumps = 0;
+   std::set<const FStmt*> remaining_externs;
+   std::set<const FStmt*> unexcepted_remaining_externs;
+   StatementAnalysisMetadata (Stmt* fstmt, AnalysisState* analysis_state, FlightplanAnnotate::Tippy* state) {
+     std::pair<int, int> result = ExpressionAnalyser::check_metadata(fstmt->original->getNode());
+     std::set<const FStmt*> tc = analysis_state->transitive_closure(fstmt);
+     ingress = result.first;
+     egress = result.second;
+     statements_left = tc.size();
+     remaining_externs = FlightplanExterns::extern_subset(tc);
+     externs_remaining = remaining_externs.size();
+     unexcepted_remaining_externs = FlightplanExterns::excepted_subset(remaining_externs);
+     unexcepted_externs_remaining = unexcepted_remaining_externs.size();
+     jumps = state->getJumps(); // FIXME this isn't immutable. Could create a map then use it for lookups thereafter  
+     remaining_externs = FlightplanExterns::extern_subset(tc);
+   }
+   std::string toString() {
+     std::string result;
+     result += "// Ingress=" + std::to_string(ingress) + " Egress=" + std::to_string(egress) + " StatementsLeft=" + std::to_string(statements_left) + " ExternsRemaining={";
+     for (const FStmt* fstmt : remaining_externs) {
+         result += FlightplanExterns::name_of_caller(fstmt) + " ";
+     }
+     result += "}";
+     result += " UnexceptedExternsRemaining={";
+     for (const FStmt* fstmt : unexcepted_remaining_externs) {
+         result += FlightplanExterns::name_of_caller(fstmt) + " ";
+     }
+     result += "}";
+     result += " Jumps=" + std::to_string(jumps) + "\n";
+     return result;
+   }
+};
+
+class ExternScanner : public FStmtAnalyse<void, int*> {
+ public:
+    void visit(Stmt* fstmt, int* count) override {
+        auto pre_statement = fstmt->original;
+        if (pre_statement->is<IR::Statement>()) {
+            auto stmt = &pre_statement->as<IR::Statement>();
+            if (stmt->is<IR::MethodCallStatement>()) {
+                auto mcs = &stmt->as<IR::MethodCallStatement>();
+                if (FlightplanExterns::calls_extern_function(mcs)) {
+                    *count += 1;
+                }
+            }
+        }
+    }
+};
+
+class ForwardStatementGatherer : public FStmtAnalyse<void, AnalysisState*> {
+ public:
+    // "return" and "exit" are removed during early program transformation
+    // by the compiler.
+    static bool sets_hasReturned(const IR::Statement* stmt) {
+        const IR::AssignmentStatement *assign_stmt = dynamic_cast<const IR::AssignmentStatement*>(stmt);
+        if (assign_stmt != nullptr) {
+          if (assign_stmt->left->is<IR::PathExpression>() &&
+              assign_stmt->right->is<IR::BoolLiteral>()) {
+            std::string definiens = std::string(assign_stmt->left->as<IR::PathExpression>().toString());
+            auto literal = assign_stmt->right->as<IR::BoolLiteral>();
+            if (literal.value && definiens == std::string("hasReturned"/*FIXME const*/)) {
+              return true;
+            }
+          }
+        }
+        return false;
+    }
+    static bool sets_hasReturned(const IR::StatOrDecl* stmt_or_decl) {
+        if (stmt_or_decl->is<IR::Statement>()) {
+            return sets_hasReturned(&stmt_or_decl->as<IR::Statement>());
+        }
+        return false;
+    }
+    void visit(Stmt* fstmt, AnalysisState* state) override {
+        state->Occur(fstmt);
+        state->incrementStatements();
+        std::set<const FStmt*> fstmt_next;
+        state->relation->insert(std::pair<const FStmt*, std::set<const FStmt*>>(fstmt, fstmt_next));
+        for (const FStmt* from : *state->pending) {
+           (*state->relation)[from].insert(fstmt);
+        }
+        state->pending->clear();
+        // Check if this is the end of a path -- if so then this statement doesn't
+        // precede any more statements.
+        if (!sets_hasReturned(fstmt->original)) {
+            // FIXME could also check if fstmt is a Return or Exit statement.
+            state->pending->insert(fstmt);
+        }
+    }
+    void visit(BlockStmt* fstmt, AnalysisState* state) override {
+        state->Occur(fstmt);
+        state->incrementStatements();
+        FStmt* cursor = fstmt->getEntry();
+        while (cursor != nullptr) {
+            process(cursor, state);
+            cursor = (FStmt*)cursor->get_next();
+        }
+    }
+    void visit(IfStmt* fstmt, AnalysisState* state) override {
+        state->Occur(fstmt);
+        state->incrementStatements();
+        AnalysisState* sub_state1 = state->clone();
+        AnalysisState* sub_state2 = state->clone();
+        assert(fstmt->get_ifTrue() != nullptr);
+        process((FStmt*)fstmt->get_ifTrue(), sub_state1);
+
+        // FIXME check condition expression for references to metadata
+
+        if (fstmt->get_ifFalse() != nullptr) {
+            process((FStmt*)fstmt->get_ifFalse(), sub_state2);
+        }
+        state->pending->clear();
+        state->resetNumOfPaths();
+        state->merge(sub_state1);
+        state->merge(sub_state2);
+        delete sub_state1;
+        delete sub_state2;
+    }
+    void visit(SwitchStmt* fstmt, AnalysisState* state) override {
+        state->Occur(fstmt);
+        state->incrementStatements();
+        // FIXME check condition expression for references to metadata
+        std::vector<SwitchStmt::Case> cases = fstmt->getCases();
+        std::vector<AnalysisState*> sub_states;
+        for (int i = 0; i < cases.size(); ++i) {
+            AnalysisState* sub_state = state->clone();
+            sub_states.push_back(sub_state);
+            process((FStmt*)cases[i].get_stmt(), sub_state);
+        }
+
+        state->pending->clear();
+        state->resetNumOfPaths();
+        for (int i = 0; i < cases.size(); ++i) {
+            state->merge(sub_states[i]);
+            delete sub_states[i];
+        }
+    }
+    void visit(EntryPoint*, AnalysisState*) override {
+       throw std::logic_error("Unsupported");
+    }
+    void visit(TransferPoint*, AnalysisState*) override {
+       throw std::logic_error("Unsupported");
+    }
+};
+
+}  // namespace P4
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_ANNOTATOR_H_ */
diff --git a/frontends/p4/flightplan_context_analysis.cpp b/frontends/p4/flightplan_context_analysis.cpp
new file mode 100644
index 0000000..d7e7c7c
--- /dev/null
+++ b/frontends/p4/flightplan_context_analysis.cpp
@@ -0,0 +1,268 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+*/
+
+#include <queue>
+#include <string>
+#include <vector>
+
+#include "flightplan_context_analysis.h"
+
+namespace P4 {
+
+void Fly_Analyser::visit(Stmt* fstmt, FlyAnalysisState* state) {
+   const IR::StatOrDecl* stmt = fstmt->original;
+   if (stmt->is<IR::AssignmentStatement>()) {
+     const IR::AssignmentStatement* ass_stmt = &stmt->as<IR::AssignmentStatement>();
+     if (ass_stmt->left->is<IR::PathExpression>()) {
+       const IR::PathExpression* varname = &ass_stmt->left->as<IR::PathExpression>();
+       auto ty = typeMap->getType(varname->getNode());
+       if (ty->is<IR::Type_Bits>()) {
+         const IR::Type_Bits* ty_bits = &ty->as<IR::Type_Bits>();
+           if (ty_bits->size == 1337/*FIXME const*/) {
+             std::cout << "location temp variable: " << varname->path->toString() << std::endl;
+             //std::cout << "  TY: " << ty << std::endl;
+             const IR::IDeclaration* lhs_decl = refMap->getDeclaration(((const IR::PathExpression*)ass_stmt->left)->path);
+             const IR::IDeclaration* rhs_decl = refMap->getDeclaration(((const IR::PathExpression*)ass_stmt->right)->path);
+             if (rhs_decl == nullptr || state->find(rhs_decl) == state->end()) {
+               // LHS is directly equated to RHS
+               std::cout << "  RHS: " << ass_stmt->right << std::endl;
+               state->insert(std::pair<const IR::IDeclaration*, const IR::Expression*>(lhs_decl, ass_stmt->right));
+             } else {
+               // LHS is indirectly equated to RHS, via another assignment
+               std::cout << "  (RHS): " << (*state)[rhs_decl] << std::endl;
+               state->insert(std::pair<const IR::IDeclaration*, const IR::Expression*>(lhs_decl, (*state)[rhs_decl]));
+             }
+           }
+       }
+     }
+   }
+}
+
+void Fly_Analyser::visit(BlockStmt* fstmt, FlyAnalysisState* state)  {
+    FStmt* cursor = fstmt->getEntry();
+
+    while (cursor != nullptr) {
+        process(cursor, state);
+        cursor = cursor->get_next();
+    }
+}
+
+void Fly_Analyser::visit(IfStmt* fstmt, FlyAnalysisState* state)  {
+    assert (fstmt->get_ifTrue() != nullptr);
+    process(fstmt->get_ifTrue(), state);
+
+    if (fstmt->get_ifFalse() != nullptr) {
+        process(fstmt->get_ifFalse(), state);
+    }
+}
+
+void Fly_Analyser::visit(SwitchStmt* fstmt, FlyAnalysisState* state) {
+    for (auto cas : fstmt->getCases()) {
+        process((FStmt*)cas.get_fstmt(), state);
+    }
+}
+
+void Fly_Analyser::visit(EntryPoint*, FlyAnalysisState*) {
+    throw std::logic_error("Unsupported");
+}
+
+void Fly_Analyser::visit(TransferPoint*, FlyAnalysisState*) {
+    // Nothing to be done.
+}
+
+void Context_Analyser::visit(BlockStmt* fstmt, ContextAnalysisState* state)  {
+    FStmt* cursor = fstmt->getEntry();
+
+    while (cursor != nullptr) {
+        process(cursor, state);
+        cursor = cursor->get_next();
+    }
+}
+
+void Context_Analyser::visit(IfStmt* fstmt, ContextAnalysisState* state)  {
+    assert (fstmt->get_ifTrue() != nullptr);
+    process(fstmt->get_ifTrue(), state);
+
+    if (fstmt->get_ifFalse() != nullptr) {
+        process(fstmt->get_ifFalse(), state);
+    }
+}
+
+void Context_Analyser::visit(SwitchStmt* fstmt, ContextAnalysisState* state) {
+    for (auto cas : fstmt->getCases()) {
+        process((FStmt*)cas.get_fstmt(), state);
+    }
+}
+
+void Context_Analyser::visit(EntryPoint*, ContextAnalysisState*) {
+    throw std::logic_error("Unsupported");
+}
+
+void Context_Analyser::visit(TransferPoint*, ContextAnalysisState*) {
+    // Nothing to be done here.
+}
+
+void Context_Analyser::visit(Stmt* fstmt, ContextAnalysisState* state) {
+    visit(fstmt->original, state);
+}
+
+void Context_Analyser::visit(const IR::AssignmentStatement* stmt, ContextAnalysisState* state) {
+    state->writes.insert(stmt->left);
+    visit(stmt->right, state);
+}
+
+void Context_Analyser::visit(const IR::MethodCallStatement* stmt, ContextAnalysisState* state) {
+    visit(stmt->methodCall, state);
+}
+
+void Context_Analyser::visit(const IR::BlockStatement* bstmt, ContextAnalysisState* state) {
+    for (auto stmt : bstmt->components) {
+       visit(stmt, state);
+    }
+}
+
+void Context_Analyser::visit(const IR::StatOrDecl* sod, ContextAnalysisState* state) {
+    if (sod->is<IR::Statement>()) {
+       visit(&sod->as<IR::Statement>(), state);
+    } else if (sod->is<IR::Declaration>()) {
+       visit(&sod->as<IR::Declaration>(), state);
+    }
+}
+
+void Context_Analyser::visit(const IR::Statement* stmt, ContextAnalysisState* state) {
+    if (stmt->is<IR::AssignmentStatement>()) {
+       visit(&stmt->as<IR::AssignmentStatement>(), state);
+    } else if (stmt->is<IR::MethodCallStatement>()) {
+       visit(&stmt->as<IR::MethodCallStatement>(), state);
+    }
+}
+
+void Context_Analyser::visit(const IR::Declaration* decl, ContextAnalysisState* state) {
+    // No need to change writes, since the declaration is local to a segment.
+    // FIXME check if need to update reads, if declaration has a definition.
+    std::cout << "Declaration::: " << decl->toString() << std::endl;
+
+}
+
+void Context_Analyser::visit(const IR::IfStatement* ifstmt, ContextAnalysisState* state) {
+    visit(ifstmt->ifTrue, state);
+    if (ifstmt->ifFalse != nullptr) {
+      visit(ifstmt->ifFalse, state);
+    }
+}
+
+void Context_Analyser::visit(const IR::Expression* expression, ContextAnalysisState* state) {
+    if (expression->is<IR::MethodCallExpression>()) {
+       visit(&expression->as<IR::MethodCallExpression>(), state);
+    } else if (expression->is<IR::PathExpression>()) {
+       visit(&expression->as<IR::PathExpression>(), state);
+    } else if (expression->is<IR::Operation_Binary>()) {
+       visit(&expression->as<IR::Operation_Binary>(), state);
+    } else if (expression->is<IR::Member>()) {
+       visit(&expression->as<IR::Member>(), state);
+    } else if (expression->is<IR::Operation_Unary>()) {
+       visit(&expression->as<IR::Operation_Unary>(), state);
+    } else if (expression->is<IR::TypeNameExpression>()) {
+       visit(&expression->as<IR::TypeNameExpression>(), state);
+    }
+}
+
+const IR::P4Table* attempt_resolve_table(const IR::Expression* expression, ReferenceMap* refMap, TypeMap* typeMap) {
+    auto mce = expression->to<IR::MethodCallExpression>();
+    auto mi = P4::MethodInstance::resolve(mce, refMap, typeMap);
+    if (!mi->isApply()) {
+        return nullptr;
+    }
+    auto am = mi->to<P4::ApplyMethod>();
+    if (!am->object->is<IR::P4Table>()) {
+        return nullptr;
+    }
+    return am->object->to<IR::P4Table>();
+}
+
+const IR::P4Action* attempt_resolve_action_body(const IR::Expression* expression, ReferenceMap* refMap, TypeMap* typeMap) {
+    auto mce = expression->to<IR::MethodCallExpression>();
+    auto mi = P4::MethodInstance::resolve(mce, refMap, typeMap);
+
+    if (auto ac = mi->to<ActionCall>()) {
+        return ac->action;
+    }
+
+    return nullptr;
+}
+
+void Context_Analyser::visit(const IR::MethodCallExpression* expression, ContextAnalysisState* state) {
+    const IR::P4Table* tbl = attempt_resolve_table(expression, refMap, typeMap);
+    //std::cout << "Table? " << FStmt::toP4String(expression) << std::endl;   
+    if (tbl != nullptr) {
+        //std::cout << "Found table: " << tbl->name << std::endl;   
+        const IR::ActionList* actions = tbl->getActionList();
+        for (const IR::ActionListElement* action : actions->actionList) {
+            const IR::P4Action* p4action = attempt_resolve_action_body(action->expression, refMap, typeMap);
+            visit(p4action->body, state);
+            // Need to remove action parameters, since these come from the lookup's result.
+            std::queue<std::string> to_purge_pre; // FIXME crude: using names without checking for scope, type etc.
+            for (auto param : *p4action->getParameters()) {
+                to_purge_pre.push(std::string(param->getName().toString()));
+	    }
+
+            std::queue<const IR::Expression*> to_purge;
+            while (!to_purge_pre.empty()) {
+                const std::string expr_s = to_purge_pre.front();
+		to_purge_pre.pop();
+                for (const IR::Expression* expr : state->reads) {
+                    if (expr_s == std::string(expr->toString())) {
+                        to_purge.push(expr);
+                    }
+	        }
+	    }
+
+            while (!to_purge.empty()) {
+                const IR::Expression* expr = to_purge.front();
+		to_purge.pop();
+                if (state->reads.find(expr) != state->reads.end()) {
+                    state->reads.erase(expr);
+                }
+                if (state->writes.find(expr) != state->writes.end()) {
+                    state->writes.erase(expr);
+                }
+	    }
+        }
+
+        const IR::Key* key = tbl->getKey();
+        for (const IR::KeyElement* ke : key->keyElements) {
+            visit(ke->expression, state);
+        }
+    }
+
+
+    for (auto &arg : *expression->arguments) {
+      visit(arg->expression, state);
+    }
+}
+
+void Context_Analyser::visit(const IR::PathExpression* p, ContextAnalysisState* state) {
+    state->reads.insert(p);
+}
+
+void Context_Analyser::visit(const IR::Operation_Binary* b, ContextAnalysisState* state) {
+    visit(b->left, state);
+    visit(b->right, state);
+}
+
+void Context_Analyser::visit(const IR::Operation_Unary* u, ContextAnalysisState* state) {
+    visit(u->expr, state);
+}
+
+void Context_Analyser::visit(const IR::TypeNameExpression* e, ContextAnalysisState* state) {
+    // FIXME unsure what this consists of
+    throw std::logic_error("Unsupported: TypeNameExpression");
+}
+
+void Context_Analyser::visit(const IR::Member* e, ContextAnalysisState* state) {
+    state->reads.insert(e); // FIXME unsure about this
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan_context_analysis.h b/frontends/p4/flightplan_context_analysis.h
new file mode 100644
index 0000000..87796ab
--- /dev/null
+++ b/frontends/p4/flightplan_context_analysis.h
@@ -0,0 +1,112 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_CONTEXT_ANALYSIS_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_CONTEXT_ANALYSIS_H_
+
+#include "flightplan_annotator.h"
+#include "tableApply.h"
+
+namespace P4 {
+
+using FlyAnalysisState = std::map<const IR::IDeclaration*, const IR::Expression*>;
+
+class Fly_Analyser : public FStmtAnalyse<void, FlyAnalysisState*> {
+    TypeMap* typeMap = nullptr;
+    ReferenceMap* refMap = nullptr;
+ public:
+    Fly_Analyser(TypeMap* typeMap, ReferenceMap* refMap) : typeMap(typeMap), refMap(refMap) {}
+    void visit(Stmt* fstmt, FlyAnalysisState* state) override;
+    void visit(BlockStmt* fstmt, FlyAnalysisState* state) override;
+    void visit(IfStmt* fstmt, FlyAnalysisState* state) override;
+    void visit(SwitchStmt* fstmt, FlyAnalysisState* state) override;
+    void visit(EntryPoint* fstmt, FlyAnalysisState* state) override;
+    void visit(TransferPoint* fstmt, FlyAnalysisState* state) override;
+};
+
+struct ContextAnalysisState {
+  std::set<const IR::Expression*> reads;
+  std::set<const IR::Expression*> writes;
+  std::string setString(std::set<const IR::Expression*> set) {
+    std::string result = "{";
+    bool started = false;
+    for (const IR::Expression* x : set) {
+      if (!started) result += x->toString();
+      else result += " " + x->toString();
+      started = true;
+    }
+    return result + "}";
+  }
+  std::string readsString() {
+    return setString(reads);
+  }
+  std::string writesString() {
+    return setString(writes);
+  }
+};
+
+class Context_Analyser : public FStmtAnalyse<void, ContextAnalysisState*> {
+    TypeMap* typeMap = nullptr;
+    ReferenceMap* refMap = nullptr;
+ public:
+    Context_Analyser(TypeMap* typeMap, ReferenceMap* refMap) : typeMap(typeMap), refMap(refMap) {}
+    void visit(Stmt* fstmt, ContextAnalysisState* state) override;
+    void visit(BlockStmt* fstmt, ContextAnalysisState* state) override;
+    void visit(IfStmt* fstmt, ContextAnalysisState* state) override;
+    void visit(SwitchStmt* fstmt, ContextAnalysisState* state) override;
+    void visit(EntryPoint* fstmt, ContextAnalysisState* state) override;
+    void visit(TransferPoint* fstmt, ContextAnalysisState* state) override;
+
+    void visit(const IR::AssignmentStatement* stmt, ContextAnalysisState* state);
+    void visit(const IR::MethodCallStatement* stmt, ContextAnalysisState* state);
+    void visit(const IR::BlockStatement* stmt, ContextAnalysisState* state);
+    void visit(const IR::StatOrDecl* stmt, ContextAnalysisState* state);
+    void visit(const IR::Statement* stmt, ContextAnalysisState* state);
+    void visit(const IR::Declaration* stmt, ContextAnalysisState* state);
+    void visit(const IR::IfStatement* stmt, ContextAnalysisState* state);
+
+    void visit(const IR::Expression* c, ContextAnalysisState* state);
+
+//    void visit(const IR::Constant* c, ContextAnalysisState* state);
+//    void visit(const IR::Slice* slice, ContextAnalysisState* state);
+//    void visit(const IR::BoolLiteral* b, ContextAnalysisState* state);
+//    void visit(const IR::StringLiteral* s, ContextAnalysisState* state);
+    void visit(const IR::PathExpression* p, ContextAnalysisState* state);
+//    void visit(const IR::Cast* c, ContextAnalysisState* state);
+    void visit(const IR::Operation_Binary* b, ContextAnalysisState* state);
+    void visit(const IR::Operation_Unary* u, ContextAnalysisState* state);
+//    void visit(const IR::ArrayIndex* a, ContextAnalysisState* state);
+    void visit(const IR::TypeNameExpression* e, ContextAnalysisState* state);
+//    void visit(const IR::ConstructorCallExpression* e, ContextAnalysisState* state);
+    void visit(const IR::Member* e, ContextAnalysisState* state);
+//    void visit(const IR::SelectCase* e, ContextAnalysisState* state);
+//    void visit(const IR::SelectExpression* e, ContextAnalysisState* state);
+//    void visit(const IR::ListExpression* e, ContextAnalysisState* state);
+//    void visit(const IR::StructInitializerExpression* e, ContextAnalysisState* state);
+    void visit(const IR::MethodCallExpression* e, ContextAnalysisState* state);
+//    void visit(const IR::DefaultExpression* e, ContextAnalysisState* state);
+//    void visit(const IR::This* e, ContextAnalysisState* state);
+
+//    void visit(const IR::Vector<IR::ActionListElement>* v, ContextAnalysisState* state);
+//    void visit(const IR::Vector<IR::Annotation>* v, ContextAnalysisState* state);
+//    void visit(const IR::Vector<IR::Entry>* v, ContextAnalysisState* state);
+//    void visit(const IR::Vector<IR::Expression>* v, ContextAnalysisState* state);
+//    void visit(const IR::Vector<IR::Argument>* v, ContextAnalysisState* state);
+//    void visit(const IR::Vector<IR::KeyElement>* v, ContextAnalysisState* state);
+//    void visit(const IR::Vector<IR::Method>* v, ContextAnalysisState* state);
+//    void visit(const IR::Vector<IR::Node>* v, ContextAnalysisState* state);
+//    void visit(const IR::Vector<IR::SelectCase>* v, ContextAnalysisState* state);
+//    void visit(const IR::Vector<IR::SwitchCase>* v, ContextAnalysisState* state);
+//    void visit(const IR::Vector<IR::Type>* v, ContextAnalysisState* state);
+//    void visit(const IR::IndexedVector<IR::Declaration_ID>* v, ContextAnalysisState* state);
+//    void visit(const IR::IndexedVector<IR::Declaration>* v, ContextAnalysisState* state);
+//    void visit(const IR::IndexedVector<IR::Node>* v, ContextAnalysisState* state);
+//    void visit(const IR::IndexedVector<IR::ParserState>* v, ContextAnalysisState* state);
+//    void visit(const IR::IndexedVector<IR::StatOrDecl>* v, ContextAnalysisState* state);
+};
+
+}  // namespace P4
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_CONTEXT_ANALYSIS_H_ */
diff --git a/frontends/p4/flightplan_convert.h b/frontends/p4/flightplan_convert.h
new file mode 100644
index 0000000..9d5751d
--- /dev/null
+++ b/frontends/p4/flightplan_convert.h
@@ -0,0 +1,286 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_CONVERT_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_CONVERT_H_
+
+#include "flightplan.h"
+#include "flightplan_stmt.h"
+#include "flightplan_annotate.h"
+#include "flightplan_externs.h"
+
+namespace P4 {
+
+class StmtConvert {
+ public:
+    static FStmt* encapsulate (const FStmt* container, std::string dest_path, const IR::AssignmentStatement* stmt, FStmt* prev, FStmt* next) {
+        return new Stmt (container, dest_path, stmt, prev, next);
+    }
+    static FStmt* encapsulate (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* stmt, FStmt* prev, FStmt* next);
+    static FStmt* encapsulate (const FStmt* container, std::string dest_path, const IR::BlockStatement* stmt, FStmt* prev, FStmt* next) {
+        return new BlockStmt (container, dest_path, stmt, prev, next);
+    }
+
+    static FStmt* encapsulate (const FStmt* container, std::string dest_path, const IR::StatOrDecl* stmt, FStmt* prev, FStmt* next) {
+        if (stmt->is<IR::Declaration>()) {
+            return encapsulate(container, dest_path, &stmt->as<IR::Declaration>(), prev, next);
+        } else if (stmt->is<IR::Statement>()) {
+            return encapsulate(container, dest_path, &stmt->as<IR::Statement>(), prev, next);
+        } else {
+            throw std::logic_error("Unrecognised statement type");
+        }
+    }
+    static FStmt* encapsulate (const FStmt* container, std::string dest_path, const IR::Statement* stmt, FStmt* prev, FStmt* next) {
+        if (stmt->is<IR::AssignmentStatement>()) {
+            return new Stmt (container, dest_path, &stmt->as<IR::AssignmentStatement>(), prev, next);
+        } else if (stmt->is<IR::MethodCallStatement>()) {
+            return encapsulate (container, dest_path, &stmt->as<IR::MethodCallStatement>(), prev, next);
+        } else if (stmt->is<IR::BlockStatement>()) {
+            return new BlockStmt (container, dest_path, &stmt->as<IR::BlockStatement>(), prev, next);
+        } else if (stmt->is<IR::IfStatement>()) {
+            return new IfStmt (container, dest_path, &stmt->as<IR::IfStatement>(), prev, next);
+        } else if (stmt->is<IR::SwitchStatement>()) {
+            return new SwitchStmt (container, dest_path, &stmt->as<IR::SwitchStatement>(), prev, next);
+        } else {
+            throw std::logic_error("Unrecognised statement type");
+        }
+    }
+    static FStmt* encapsulate (const FStmt* container, std::string dest_path, const IR::Declaration* stmt, FStmt* prev, FStmt* next) {
+        return new Stmt (container, dest_path, stmt, prev, next);
+    }
+
+    static FStmt* encapsulate (const FStmt* container, std::string dest_path, const IR::IfStatement* stmt, FStmt* prev, FStmt* next) {
+        return new IfStmt (container, dest_path, stmt, prev, next);
+    }
+};
+
+template <class Out, class State>
+class FStmtAnalyse {
+ public:
+#if 0
+    T visit(const FStmt* fstmt, const IR::AssignmentStatement* stmt);  
+    T visit(const FStmt* fstmt, const IR::MethodCallStatement* stmt);  
+    T visit(const FStmt* fstmt, const IR::BlockStatement* stmt);  
+    T visit(const FStmt* fstmt, const IR::StatOrDecl* stmt);  
+    T visit(const FStmt* fstmt, const IR::Statement* stmt);  
+    T visit(const FStmt* fstmt, const IR::Declaration* stmt);  
+    T visit(const FStmt* fstmt, const IR::IfStatement* stmt);  
+#endif
+
+    virtual Out visit(EntryPoint* fstmt, State state) = 0;
+    virtual Out visit(TransferPoint* fstmt, State state) = 0;
+    virtual Out visit(Stmt* fstmt, State state) = 0;
+
+    virtual Out visit(BlockStmt* fstmt, State state) = 0;
+    virtual Out visit(IfStmt* fstmt, State state) = 0;
+    virtual Out visit(SwitchStmt* fstmt, State state) = 0;
+
+    virtual Out process(FStmt* fstmt, State state) {
+        CHECK_NULL(fstmt);
+        switch (FStmt::classify(fstmt)) {
+            case FStmt::Kind::EntryPoint:
+            return visit((EntryPoint*)fstmt, state);
+            case FStmt::Kind::TransferPoint:
+            return visit((TransferPoint*)fstmt, state);
+            case FStmt::Kind::Stmt:
+            return visit((Stmt*)fstmt, state);
+            case FStmt::Kind::BlockStmt:
+            return visit((BlockStmt*)fstmt, state);
+            case FStmt::Kind::IfStmt:
+            return visit((IfStmt*)fstmt, state);
+            case FStmt::Kind::SwitchStmt:
+            return visit((SwitchStmt*)fstmt, state);
+            default:
+            throw std::logic_error("Unrecognised FStmt");
+        }
+    }
+};
+
+class FStmtDeepClone : public FStmtAnalyse<FStmt*, FStmt*> {
+ public:
+    FStmt* visit(EntryPoint* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+        return fstmt->clone();
+    }
+
+    FStmt* visit(TransferPoint* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+        return fstmt->clone();
+    }
+
+    FStmt* visit(Stmt* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+        return fstmt->clone();
+    }
+
+    FStmt* visit(BlockStmt* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+
+        BlockStmt* result = (BlockStmt*)fstmt->clone();
+
+        FStmt* cursor = fstmt->getEntry();
+        FStmt* prev = nullptr;
+        result->setEntry(nullptr);
+
+        //rewrite prev + next as we go along
+        while (cursor != nullptr) {
+            FStmt* subresult = process(cursor, cursor);
+            subresult->set_next(nullptr);
+            subresult->container = result;
+            if (result->getEntry() == nullptr) {
+                result->setEntry(subresult);
+                assert(prev == nullptr);
+                //assert(subresult->get_prev() == nullptr);
+                subresult->set_prev(nullptr);
+            } else {
+                assert(prev != nullptr);
+                prev->set_next(subresult);
+                subresult->set_prev(prev);
+            }
+            prev = subresult;
+            cursor = cursor->next;
+        }
+
+        return result;
+    }
+
+    FStmt* visit(IfStmt* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+
+        IfStmt* result = (IfStmt*)fstmt->clone();
+
+        if (result->ifTrue != nullptr) {
+            result->ifTrue = process(fstmt->ifTrue, fstmt->ifTrue);
+        }
+
+        if (result->ifFalse != nullptr) {
+            result->ifFalse = process(fstmt->ifFalse, fstmt->ifFalse);
+        }
+
+        return result;
+    }
+
+    FStmt* visit(SwitchStmt* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+
+        SwitchStmt* result = (SwitchStmt*)fstmt->clone();
+
+        result->cases.clear();
+        for (SwitchStmt::Case& cas : fstmt->cases) {
+            SwitchStmt::Case cas2 = SwitchStmt::Case(cas.label, process(cas.stmt, cas.stmt));
+            result->cases.push_back(cas2);
+        }
+
+        return result;
+    }
+};
+
+class Annotator {
+ private:
+    virtual FStmt* private_annotate();
+ protected:
+    FStmt* result = nullptr;
+    Stmt* orig_stmt = nullptr;
+    std::string extern_name;
+    std::string suffix;
+    std::string segment_name;
+    std::string* looked_up = nullptr;
+
+ public:
+    const FStmt* container = nullptr;
+    std::string dest_path;
+    const IR::MethodCallStatement* mcs = nullptr;
+    FStmt* prev = nullptr;
+    FStmt* next = nullptr;
+
+     Annotator (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* mcs, FStmt* prev, FStmt* next);
+
+    FStmt* annotate() {
+        if (result != nullptr) { // FIXME factor out      
+            return result;
+        } else {
+            return private_annotate();
+        }
+    };
+};
+
+class EagerOffload : public Annotator {
+  private:
+    FStmt* private_annotate() override;
+  public:
+    EagerOffload (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* mcs, FStmt* prev, FStmt* next) : Annotator(container, dest_path, mcs, prev, next) {}
+};
+
+class ProtoAnnotate : public FStmtDeepClone {
+ public:
+    FStmt* visit(TransferPoint*, FStmt*) override {
+        throw std::logic_error("Unrecognised FStmt");
+    }
+
+    FStmt* visit(Stmt* fstmt, FStmt* value) override {
+        auto pre_statement = fstmt->original;
+        if (pre_statement->is<IR::Declaration>()) {
+            return FStmtDeepClone::visit(fstmt, value);
+        } else if (pre_statement->is<IR::Statement>()) {
+            auto stmt = &pre_statement->as<IR::Statement>();
+            if (stmt->is<IR::MethodCallStatement>()) {
+#if 1
+//                Annotator ann(fstmt->container, std::string(FlightplanConfig::FP_options.flightplanFolder), &stmt->as<IR::MethodCallStatement>(), fstmt->prev, fstmt->next);
+                EagerOffload ann(fstmt->container, std::string(FlightplanConfig::FP_options.flightplanFolder), &stmt->as<IR::MethodCallStatement>(), fstmt->prev, fstmt->next);
+                return ann.annotate();
+//                return Annotator(fstmt->container, std::string(FlightplanConfig::FP_options.flightplanFolder), &stmt->as<IR::MethodCallStatement>(), fstmt->prev, fstmt->next).annotate();
+#else
+                return annotate(fstmt->container, std::string(FlightplanConfig::FP_options.flightplanFolder), &stmt->as<IR::MethodCallStatement>(), fstmt->prev, fstmt->next);
+#endif
+            } else  {
+                return FStmtDeepClone::visit(fstmt, value);
+            }
+        } else {
+            throw std::logic_error("Impossible");
+        }
+    }
+
+    FStmt* annotate(const FStmt* container, std::string dest_path, const IR::MethodCallStatement* mcs, FStmt* prev, FStmt* next);
+};
+
+template <class Ann>
+class ProtoAnnotateGeneric : public FStmtDeepClone {
+ public:
+    FStmt* visit(TransferPoint* fstmt, FStmt* value) override {
+        throw std::logic_error("Unrecognised FStmt");
+    }
+
+    FStmt* visit(Stmt* fstmt, FStmt* value) override {
+        auto pre_statement = fstmt->original;
+        if (pre_statement->is<IR::Declaration>()) {
+            return FStmtDeepClone::visit(fstmt, value);
+        } else if (pre_statement->is<IR::Statement>()) {
+            auto stmt = &pre_statement->as<IR::Statement>();
+            if (stmt->is<IR::MethodCallStatement>()) {
+                Annotator* ann = nullptr;
+
+                switch (FlightplanConfig::FP_options.flightplan_annotation_mode) {
+                    case CompilerOptions::FlightplanAnnotationMode::EagerOffload:
+                        ann = new EagerOffload(fstmt->container, std::string(FlightplanConfig::FP_options.flightplanFolder), &stmt->as<IR::MethodCallStatement>(), fstmt->prev, fstmt->next);
+                        break;
+                    default:
+                        throw std::logic_error("Unsupported annotation sub-mode");
+                }
+
+                return ann->annotate();
+            } else  {
+                return FStmtDeepClone::visit(fstmt, value);
+            }
+        } else {
+            throw std::logic_error("Impossible");
+        }
+    }
+
+    FStmt* annotate(const FStmt* container, std::string dest_path, const IR::MethodCallStatement* mcs, FStmt* prev, FStmt* next);
+};
+
+}  // namespace P4
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_CONVERT_H_ */
diff --git a/frontends/p4/flightplan_convert_extra.h b/frontends/p4/flightplan_convert_extra.h
new file mode 100644
index 0000000..07be403
--- /dev/null
+++ b/frontends/p4/flightplan_convert_extra.h
@@ -0,0 +1,147 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_CONVERT_EXTRA_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_CONVERT_EXTRA_H_
+
+#include "flightplan_convert.h"
+
+namespace P4 {
+
+class Cleary : public FStmtDeepClone {
+ public:
+    FStmt* visit(TransferPoint* fstmt, FStmt* value) override {
+        throw std::logic_error("Unrecognised FStmt");
+    }
+
+#if 0
+    FStmt* visit(Stmt* fstmt, FStmt* value) override {
+std::cout << "CLEAR!" << std::endl;      
+//        return new Stmt (nullptr, "bla", new IR::EmptyStatement(), nullptr, nullptr);
+
+//        return new EntryPoint (std::string("bla"), nullptr);
+
+        auto pre_statement = fstmt->original;
+        if (pre_statement->is<IR::Declaration>()) {
+            return FStmtDeepClone::visit(fstmt, value);   
+            return new EntryPoint (std::string("bla"), nullptr);
+        } else if (pre_statement->is<IR::Statement>()) {
+            return new EntryPoint (std::string("bla"), nullptr);   
+            return FStmtDeepClone::visit(fstmt, value);
+        }
+    }
+#endif
+
+    FStmt* visit(IfStmt* fstmt, FStmt* value) override {
+#if 0
+std::cout << "CLEAR!" << std::endl;      
+#endif
+        return new EntryPoint (std::string("bla"), nullptr);
+    }
+};
+
+class Dleary : public FStmtDeepClone {
+ public:
+    FStmt* visit(EntryPoint* fstmt, FStmt* value) override {
+#if 0
+std::cout << "dVISIT:EntryPoint" << std::endl;      
+#endif
+        assert(fstmt == value);
+        return fstmt->clone();
+    }
+
+    FStmt* visit(TransferPoint* fstmt, FStmt* value) override {
+#if 0
+std::cout << "dVISIT:TransferPoint" << std::endl;      
+#endif
+        assert(fstmt == value);
+        return fstmt->clone();
+    }
+
+    FStmt* visit(Stmt* fstmt, FStmt* value) override {
+#if 0
+std::cout << "dVISIT:Stmt" << std::endl;      
+std::cout << fstmt->toStatement()->toString() << std::endl;      
+#endif
+        assert(fstmt == value);
+        return fstmt->clone();
+    }
+
+    FStmt* visit(BlockStmt* fstmt, FStmt* value) override {
+#if 0
+std::cout << "dVISIT:BlockStmt" << std::endl;      
+#endif
+        assert(fstmt == value);
+
+        BlockStmt* result = (BlockStmt*)fstmt->clone();
+
+        FStmt* cursor = fstmt->getEntry();
+        FStmt* prev = nullptr;
+        result->setEntry(nullptr);
+
+        //rewrite prev + next as we go along
+        while (cursor != nullptr) {
+#if 0
+std::cout << "1" << std::endl;      
+#endif
+//if (FStmt::classify(cursor) != FStmt::Kind::IfStmt) {   
+            FStmt* subresult = process(cursor, cursor);
+            subresult->set_next(nullptr);
+            subresult->container = result;
+            if (result->getEntry() == nullptr) {
+                result->setEntry(subresult);
+                assert(prev == nullptr);
+                //assert(subresult->get_prev() == nullptr);
+                subresult->set_prev(nullptr);
+            } else {
+                if (prev != nullptr) {
+                  prev->set_next(subresult);
+                }
+                subresult->set_prev(prev);
+                prev = subresult;
+            }
+//}   
+            cursor = cursor->next;
+#if 0
+std::cout << "2" << std::endl;      
+#endif
+        }
+#if 0
+std::cout << "OUT" << std::endl;      
+#endif
+
+        return result;
+    }
+
+    FStmt* visit(SwitchStmt* fstmt, FStmt* value) override {
+#if 0
+std::cout << "dVISIT:SwitchStmt" << std::endl;      
+#endif
+        assert(fstmt == value);
+
+        SwitchStmt* result = (SwitchStmt*)fstmt->clone();
+
+        result->cases.clear();
+        for (SwitchStmt::Case& cas : fstmt->cases) {
+            SwitchStmt::Case cas2 = SwitchStmt::Case(cas.label, process(cas.stmt, cas.stmt));
+            result->cases.push_back(cas2);
+        }
+
+        return result;
+    }
+
+
+
+    FStmt* visit(IfStmt* fstmt, FStmt* value) override {
+#if 0
+std::cout << "DLEAR!" << std::endl;      
+#endif
+        return new EntryPoint (std::string("bla"), nullptr);
+    }
+};
+
+}  // namespace P4
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_CONVERT_EXTRA_H_
diff --git a/frontends/p4/flightplan_dot.cpp b/frontends/p4/flightplan_dot.cpp
new file mode 100644
index 0000000..4f3a993
--- /dev/null
+++ b/frontends/p4/flightplan_dot.cpp
@@ -0,0 +1,317 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#include <assert.h>
+#include <iostream>
+#include <fstream>
+
+#include "externInstance.h"
+
+#include "../common/options.h"
+#include "ir/ir.h"
+#include "ir/visitor.h"
+#include "lib/nullstream.h"
+#include "lib/path.h"
+#include "toP4/toP4.h"
+
+#include "flightplan.h"
+#include "flightplan_preanalysis.h"
+
+namespace P4 {
+
+std::string FStmt::link_from_prev() const {
+    std::string result;
+    if (get_prev() != nullptr) {
+        std::string tail;
+        if (get_prev()->getClustID() != nullptr) {
+            tail = "[ltail=" + *(get_prev()->getClustID()) + "]";
+        }
+
+        const BlockStmt *bs = dynamic_cast<const BlockStmt*>(get_prev());
+        if (bs != nullptr) {
+            if (bs->getEntry() != this) {
+                result += get_prev()->DOTid() + " -> " + DOTid() + tail + ";\n";
+            } else {
+                // Don't make the block's node appear in the graph.
+            }
+        } else {
+            result += get_prev()->DOTid() + " -> " + DOTid() + ";\n";
+        }
+    }
+    return result;
+}
+
+std::string Stmt::toDOT() const {
+    std::string abbrev_name = "stmt" + DOTid();
+    assert(original != nullptr);
+    std::string result = DOTid() + " [label=\"" + abbrev_name + ":" + original->getSourceInfo().toPositionString()  + "\",color=white];\n";
+//    result += "{ rank=same; \"" + DOTid() + "\"}\n";
+    return result;
+}
+
+std::string TransferPoint::toDOT() const {
+    std::string abbrev_name = "stmt" + DOTid();
+    std::string result = DOTid() + " [label=\"" + abbrev_name + ":" + original->getSourceInfo().toPositionString()  + "\",color=red,style=filled,fontcolor=white];\n";
+    return result;
+}
+
+std::string BlockStmt::toDOT() const {
+    std::string abbrev_name = "block";
+    std::string clust_name = *clust_id;
+
+    std::string result = "subgraph " + clust_name + " {\n";
+
+    result += "label=\"\";\n";
+    result += "style=solid;\n";
+    result += "color=lightgray;\n";
+    const FStmt *cursor = block_entry;
+    while (cursor != nullptr) {
+        result += cursor->toString() + "\n";
+        result += cursor->toDOT();
+        result += cursor->link_from_prev();
+        cursor = cursor->get_next();
+    }
+    result += "}\n";
+    return result;
+}
+
+std::string BlockStmt::entryDOTid() const {
+    return block_entry->DOTid();
+}
+
+std::string IfStmt::toDOT() const {
+    // FIXME DRY principle
+
+    std::string abbrev_name = "if";
+    std::string clust_name = *clust_id;
+
+    std::stringstream sstream;
+    P4::ToP4 top4(&sstream, false, "");
+    (void)condition->apply(top4);
+    std::string cond_s = sstream.str();
+
+    std::string label = "label=\"" + abbrev_name + " " + cond_s + "\"";
+
+    std::string result = "subgraph " + clust_name + " {\n";
+    result += DOTid() + " [" + label + ",color=white,fontcolor=blue];\n";
+
+    result += "label=\"\";\n";
+    result += "style=dotted;\n";
+    result += "color=lightgray;\n";
+
+    abbrev_name = "true";
+    result += "subgraph cluster_" + abbrev_name + "_" + DOTid() + " {\n";
+    result += "label=\"" + abbrev_name + "\";\n";
+    result += "style=dotted;\n";
+    result += "color=lightgray;\n";
+    result += "fontcolor=green;\n";
+    result += ifTrue->toDOT();
+    result += "}\n";
+    result += DOTid() + " -> " + ifTrue->entryDOTid() +";\n";
+
+    if (ifFalse != nullptr) {
+        abbrev_name = "false";
+        result += "subgraph cluster_" + abbrev_name + "_" + DOTid() + " {\n";
+        result += "label=\"" + abbrev_name + "\";\n";
+        result += "style=dotted;\n";
+        result += "color=lightgray;\n";
+        result += "fontcolor=red;\n";
+        result += ifFalse->toDOT();
+        result += "}\n";
+        result += DOTid() + " -> " + ifFalse->entryDOTid() +";\n";
+    } else {
+        result += "// no 'false' branch\n";
+    }
+
+    result += "}\n";
+
+    return result;
+}
+
+std::string SwitchStmt::toDOT() const {
+    throw std::logic_error("Unexpected");
+#if 0
+    std::cout << "switch\n" << std::endl;
+
+    // FIXME some code repeition; DRY principle
+    std::string abbrev_name = "switch";
+    std::string result = "subgraph cluster_" + abbrev_name + "_" + DOTid() + " {\n";
+    result += "label=\"" + abbrev_name + "\";\n";
+    result += "color=lightgray;\n";
+
+    // FIXME add edge to each case
+
+    unsigned i = 0;
+    for (auto c : cases) {
+        abbrev_name = "case" + std::to_string(i);
+        result += "label=\"" + abbrev_name + "\";\n";
+        result += "color=lightgray;\n";
+        result += "subgraph cluster_" + abbrev_name + "_" + DOTid() + " {\n";
+        result += c.get_stmt()->toDOT();
+        result += "}\n";
+        i += 1;
+    }
+
+    result += "}\n";
+    return result;
+#endif
+}
+
+void StmtFlow::cfg_dot(std::ostream *ost, const FStmt* st, std::set<const FStmt*> &visited, const FStmt* pre_st) {
+    std::set<const FStmt*> next = step(Direction::Forward, st, visited);
+    bool src_atom = atomic_stmt(st);
+    std::string node = st->DOTid() + " [color=white,label=\"" + st->toStatement()->toString() + ": " + st->toStatement()->getSourceInfo().toPositionString() + "\"];";
+    if (src_atom) {
+        *ost << node << std::endl;
+    } else {
+        *ost << "// " + node << std::endl;
+    }
+    for (auto next_st : next) {
+        bool tgt_atom = atomic_stmt(next_st);
+
+        std::string edge;
+        if (src_atom && tgt_atom) {
+            edge = st->DOTid() + " -> " + next_st->DOTid();
+        } else if (pre_st != nullptr && tgt_atom) {
+            edge = pre_st->DOTid() + " -> " + next_st->DOTid();
+        } else {
+            edge = "// " + st->DOTid() + " -> " + next_st->DOTid();
+        }
+
+        *ost << edge << std::endl;
+
+        if (st == next_st) {
+            // FIXME Shouldn't happen.   
+            continue;
+        }
+
+        if (src_atom) {
+            cfg_dot(ost, next_st, visited, st);
+        } else {
+            cfg_dot(ost, next_st, visited, pre_st);
+        }
+    }
+}
+
+void Split::to_dot(std::ostream *ost, Split *split) {
+    *ost << "digraph G {" << std::endl;
+    *ost << "compound=true;" << std::endl;
+
+    EntryPoint ep(std::string(FlightplanConfig::FP_options.flightplanFolder), nullptr);
+    *ost << ep.toDOT() << std::endl;
+
+#if 0
+    if (split->cleaved != nullptr) {
+        *ost << ep.DOTid() + " -> " + split->cleaved->entryDOTid() + ";" << std::endl;
+        std::cout << "Generating subDOT" << std::endl;
+        *ost << split->cleaved->toDOT() << std::endl;
+    } else {
+        *ost << ep.DOTid() + " -> " + split->getBeginning()->entryDOTid() + ";" << std::endl;
+        *ost << split->getBeginning()->toDOT() << std::endl;
+    }
+    std::cout << "Done subDOT" << std::endl;
+#else
+    *ost << ep.DOTid() + " -> " + split->cleaved->entryDOTid() + "; // Entry point's link" << std::endl;
+    *ost << split->cleaved->toDOT() << std::endl;
+#endif
+
+#if 0
+    std::set<const FStmt*> visited;
+    std::queue<FStmt*> to_visit;
+    to_visit.push((FStmt*)/*FIXME type hack*/split->getBeginning());
+
+//    if (split->beginning != FlightplanImpl::getMain()) {
+//        visited.insert(FlightplanImpl::getMain());
+//    }
+    if (split->beginning->getContainer() != nullptr) {
+        visited.insert(split->beginning->getContainer());
+    }
+
+    while (!to_visit.empty()) {
+        auto stmt = to_visit.front();
+        to_visit.pop();
+
+        const TransferPoint *tp = dynamic_cast<const TransferPoint*>(stmt);
+        if (tp != nullptr) {
+            throw std::logic_error("Unexpected: TransferPoint");
+        }
+
+        bool already_visited = false;
+        if (visited.find(stmt) != visited.end()) {
+            already_visited = true;
+            // We've cycled.
+//            break;
+//            throw std::logic_error("Impossible");
+        }
+//        visited.insert(stmt);
+
+        bool faked_next = false;
+        if (stmt->get_next() != nullptr) {
+            // FIXME this method isn't ideal since cannot detect a TransferPoint (at which point this split ends)
+            to_visit.push((FStmt*)/*FIXME type hack*/stmt->get_next());
+        } else {
+            if (stmt->getContainer() != nullptr) {
+                // FIXME add a link between current statement and the next, which might be at an outer scope.
+                const FStmt *prevUp = stmt->getContainer();
+                const FStmt *next = stmt->getContainer()->get_next();
+                bool reached_top = false;
+                while (next == nullptr) {
+                    if (prevUp->getContainer() == nullptr) {
+                        reached_top = true;
+                        break;
+                    }
+                    prevUp = prevUp->getContainer();
+                    next = prevUp->get_next();
+                }
+
+                if (!reached_top) {
+//                    to_visit.push((FStmt*)/*FIXME type hack*/next);
+                    faked_next = true;
+                    stmt->set_next((FStmt*)/*FIXME type hack*/next);
+                }
+            }
+        }
+
+        if (!already_visited) {
+            *ost << stmt->toDOT() << std::endl;
+
+            if (stmt != split->getBeginning()) {
+                // We can't link_from_prev for the beginning node, since there's no prev for it in general.
+                *ost << stmt->link_from_prev() << std::endl;
+            }
+        }
+
+        if (faked_next) {
+            stmt->set_next(nullptr);
+        }
+
+#if 0
+        for (auto next : StmtFlow::getNext(stmt, visited)) {
+            // FIXME redundant protection against cycling?
+            if (next != FlightplanImpl::getMain()) {
+                to_visit.push(next);
+            }
+        }
+#endif
+    }
+#endif
+
+    *ost << "}" << std::endl;
+}
+
+void Split::splits_dot(std::ostream *ost) {
+    *ost << "digraph G {" << std::endl;
+    *ost << "compound=true;" << std::endl;
+    for (auto split : Split::Splits) {
+        *ost << split->name << ";" << std::endl;
+        std::set<Split*> ts = split->successor_splits;
+        for (auto next_split : ts) {
+            *ost << split->name + " -> " + next_split->name + ";" << std::endl;
+        }
+    }
+    *ost << "}" << std::endl;
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan_ext.cpp b/frontends/p4/flightplan_ext.cpp
new file mode 100644
index 0000000..8551eef
--- /dev/null
+++ b/frontends/p4/flightplan_ext.cpp
@@ -0,0 +1,91 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#include <iostream>
+#include <fstream>
+
+#include "externInstance.h"
+
+#include "../common/options.h"
+#include "ir/ir.h"
+#include "ir/visitor.h"
+#include "lib/nullstream.h"
+#include "lib/path.h"
+#include "toP4/toP4.h"
+
+#include "flightplan.h"
+
+namespace P4 {
+
+const IR::Node* FlightplanTransf::preorder(IR::Type_Declaration* t) {
+/*
+Make list of Landing-returning entries, remember them for the next pass.
+Remove all Landing-returning declarations
+*/
+//    std::cout << "FlightplanTransf = " << t->toString() << std::endl;  
+    if (t->name == FlightplanConfig::landing_type_name) return nullptr;
+    return t;
+}
+
+const IR::Node* FlightplanTransf::preorder(IR::Method* t) {
+    std::cout << "FlightplanTransf = " << t->toString() << std::endl;
+    auto ty = t->type->as<IR::Type_Method>();
+    if (ty.returnType != nullptr && ty.returnType->is<IR::Type_Name>()) {
+      auto re_ty = ty.returnType->as<IR::Type_Name>();
+      std::cout << "                 a " << ty.parameters->size();
+      std::cout << "                 r " << re_ty.toString() << std::endl;
+      if (re_ty.toString() == FlightplanConfig::landing_type_name) return nullptr;
+    }
+    if (FlightplanConfig::landing_API.find(std::string(t->toString())) != FlightplanConfig::landing_API.end()) return nullptr;
+    return t;
+}
+
+const IR::Node* FlightplanTransf::preorder(IR::MethodCallStatement* mcs) {
+    const IR::MethodCallExpression* mce = mcs->methodCall;
+    auto mi = P4::MethodInstance::resolve(mce, refMap, typeMap);
+
+    if (mi->is<P4::ExternFunction>()) {
+        auto ef = mi->to<P4::ExternFunction>();
+//        if (landing_API.find(std::string(ef->method->toString())) != landing_API.end()) return new IR::CutStmt();
+        if (FlightplanConfig::landing_API.find(std::string(ef->method->toString())) != FlightplanConfig::landing_API.end()) return new IR::EmptyStatement();
+    }
+    return mcs;
+}
+
+}  // namespace P4
+
+#if 0
+bool IR::CutStmt::operator==(IR::CutStmt const & a) const {
+        return Statement::operator==(static_cast<const Statement &>(a));
+    }
+bool IR::CutStmt::equiv(IR::Node const & a_) const {
+        if (static_cast<const Node *>(this) == &a_) return true;
+        if (typeid(*this) != typeid(a_)) return false;
+        if (!Statement::equiv(a_)) return false;
+        return true;
+    }
+void IR::CutStmt::toJSON(JSONGenerator & json) const {
+    Statement::toJSON(json);
+}
+IR::CutStmt::CutStmt(JSONLoader & json) : Statement(json) {
+}
+IR::Node * IR::CutStmt::fromJSON(JSONLoader & json) { return new CutStmt(json); }
+IR::CutStmt::CutStmt(Util::SourceInfo srcInfo) :
+    Statement(srcInfo)
+    { validate(); }
+IR::CutStmt::CutStmt()
+    { validate(); }
+
+bool IR::CutStmt::apply_visitor_preorder(Modifier&) {return false;}
+void IR::CutStmt::apply_visitor_postorder(Modifier&) {}
+const IR::Node *IR::CutStmt::apply_visitor_preorder(Transform&) {return this;}
+const IR::Node *IR::CutStmt::apply_visitor_postorder(Transform&) {return this;}
+
+void IR::CutStmt::apply_visitor_revisit(Modifier&, IR::Node const*) const {}
+bool IR::CutStmt::apply_visitor_preorder(Inspector&) const {return false;}
+void IR::CutStmt::apply_visitor_postorder(Inspector&) const {}
+void IR::CutStmt::apply_visitor_revisit(Inspector&) const {}
+void IR::CutStmt::apply_visitor_revisit(Transform&, IR::Node const*) const {}
+#endif
diff --git a/frontends/p4/flightplan_externs.cpp b/frontends/p4/flightplan_externs.cpp
new file mode 100644
index 0000000..c998331
--- /dev/null
+++ b/frontends/p4/flightplan_externs.cpp
@@ -0,0 +1,109 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#include <assert.h>
+#include <iostream>
+#include <fstream>
+#include <regex>
+
+#include "externInstance.h"
+
+#include "../common/options.h"
+#include "ir/ir.h"
+#include "ir/visitor.h"
+#include "lib/nullstream.h"
+#include "lib/path.h"
+#include "toP4/toP4.h"
+
+#include "flightplan_externs.h"
+
+namespace P4 {
+
+bool FlightplanExterns::calls_extern_function(const IR::MethodCallStatement* mcs) {
+    const IR::MethodCallExpression* mce = mcs->methodCall;
+    auto mi = P4::MethodInstance::resolve(mce, FlightplanConfig::FP_refMap, FlightplanConfig::FP_typeMap);
+    return mi->is<P4::ExternFunction>();
+}
+
+std::string FlightplanExterns::extern_function_name(const IR::MethodCallStatement* mcs) {
+    const IR::MethodCallExpression* mce = mcs->methodCall;
+    auto mi = P4::MethodInstance::resolve(mce, FlightplanConfig::FP_refMap, FlightplanConfig::FP_typeMap);
+    auto ef = mi->to<P4::ExternFunction>();
+    return std::string(ef->method->toString());
+}
+
+bool FlightplanExterns::contains_extern_call(std::set<const FStmt*> &stmts) {
+    bool result = false;
+    for (auto &fstmt : stmts) {
+        const Stmt* stmt  = dynamic_cast<const Stmt*>(fstmt);
+        if (stmt != nullptr) {
+            const IR::MethodCallStatement *mcs = dynamic_cast<const IR::MethodCallStatement*>(stmt->original);
+            if (mcs != nullptr) {
+                result |= calls_extern_function(mcs);
+            }
+        }
+    }
+    return result;
+}
+
+// Remove non-extern calls from a set of statements, and return the resulting set.
+std::set<const FStmt*> FlightplanExterns::extern_subset(std::set<const FStmt*> &stmts) {
+    std::set<const FStmt*> result;
+    for (auto &fstmt : stmts) {
+        const Stmt* stmt  = dynamic_cast<const Stmt*>(fstmt);
+        if (stmt != nullptr) {
+            const IR::MethodCallStatement *mcs = dynamic_cast<const IR::MethodCallStatement*>(stmt->original);
+            if (mcs != nullptr) {
+                if (calls_extern_function(mcs)) {
+                    result.insert(fstmt);
+                }
+            }
+        }
+    }
+
+    return result;
+}
+
+std::string FlightplanExterns::name_of_caller(const IR::MethodCallStatement *mcs) {
+    return std::string(mcs->methodCall->method->toString());
+}
+
+std::string FlightplanExterns::name_of_caller(const FStmt* fstmt) {
+    const Stmt* stmt  = dynamic_cast<const Stmt*>(fstmt);
+    if (stmt != nullptr) {
+        const IR::MethodCallStatement *mcs = dynamic_cast<const IR::MethodCallStatement*>(stmt->original);
+        if (mcs != nullptr) {
+            return name_of_caller(mcs);
+        }
+    }
+    throw std::logic_error("Not a method call");
+}
+
+
+
+// Remove non-excepted extern calls from a set of statements, and return the resulting set.
+std::set<const FStmt*> FlightplanExterns::excepted_subset(std::set<const FStmt*> &stmts) {
+    std::set<const FStmt*> result;
+    for (auto &fstmt : stmts) {
+        const Stmt* stmt  = dynamic_cast<const Stmt*>(fstmt);
+        if (stmt != nullptr) {
+            const IR::MethodCallStatement *mcs = dynamic_cast<const IR::MethodCallStatement*>(stmt->original);
+            if (mcs != nullptr) {
+                if (calls_extern_function(mcs)) {
+
+                    for (std::string excluded_extern_name : FlightplanConfig::FP_options.flightplan_exclusions) {
+                        if (excluded_extern_name == name_of_caller(mcs)) {
+                            result.insert(fstmt);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    return result;
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan_externs.h b/frontends/p4/flightplan_externs.h
new file mode 100644
index 0000000..5e344a2
--- /dev/null
+++ b/frontends/p4/flightplan_externs.h
@@ -0,0 +1,25 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_EXTERNS_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_EXTERNS_H_
+
+#include "flightplan_stmt.h"
+
+namespace P4 {
+
+namespace FlightplanExterns {
+    bool calls_extern_function(const IR::MethodCallStatement* mcs);
+    std::string extern_function_name(const IR::MethodCallStatement* mcs);
+    bool contains_extern_call(std::set<const FStmt*> &stmts);
+    std::set<const FStmt*> extern_subset(std::set<const FStmt*> &stmts);
+    std::set<const FStmt*> excepted_subset(std::set<const FStmt*> &stmts);
+    std::string name_of_caller(const IR::MethodCallStatement *mcs);
+    std::string name_of_caller(const FStmt* fstmt);
+}
+
+}
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_EXTERNS_H_ */
diff --git a/frontends/p4/flightplan_preanalysis.cpp b/frontends/p4/flightplan_preanalysis.cpp
new file mode 100644
index 0000000..5697d16
--- /dev/null
+++ b/frontends/p4/flightplan_preanalysis.cpp
@@ -0,0 +1,319 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#include <assert.h>
+#include <iostream>
+#include <fstream>
+#include <regex>
+
+#include "externInstance.h"
+
+#include "../common/options.h"
+#include "ir/ir.h"
+#include "ir/visitor.h"
+#include "lib/nullstream.h"
+#include "lib/path.h"
+#include "toP4/toP4.h"
+
+#include "flightplan.h"
+#include "flightplan_preanalysis.h"
+
+namespace P4 {
+
+std::set<const FStmt*> StmtFlow::getNext(const FStmt* stmt, std::set<const FStmt*> &visited) {
+#if 0
+    std::cout << "getNext: " << stmt->toStatement()->toString() + ": " + stmt->toStatement()->getSourceInfo().toPositionString() << std::endl;
+#endif
+
+    bool is_statement = atomic_stmt(stmt);
+
+    if (!is_statement && visited.find(stmt) == visited.end()) {
+        return getIn(Direction::Forward, stmt, visited);
+    }
+
+    visited.insert(stmt);
+
+    // Continue moving in the same direction if we can, otherwise get out.
+    if (stmt->get_next() != nullptr) {
+        return std::set<const FStmt*>{stmt->get_next()};
+    } else {
+        return getOut(Direction::Forward, stmt, visited);
+    }
+}
+
+std::set<const FStmt*> StmtFlow::getPrev(const FStmt* stmt, std::set<const FStmt*> &visited) {
+#if 0
+    std::cout << "getPrev: " << stmt->toStatement()->toString() + ": " + stmt->toStatement()->getSourceInfo().toPositionString() << std::endl;
+#endif
+
+    // FIXME DRY with getNext
+
+    bool is_statement = atomic_stmt(stmt);
+
+    if (!is_statement && visited.find(stmt) == visited.end()) {
+        return getIn(Direction::Backward, stmt, visited);
+    }
+
+    visited.insert(stmt);
+
+    // Continue moving in the same direction if we can, otherwise get out.
+    if (stmt->get_prev() != nullptr) {
+        return std::set<const FStmt*>{stmt->get_prev()};
+    } else {
+        return getOut(Direction::Backward, stmt, visited);
+    }
+}
+
+std::set<const FStmt*> StmtFlow::getOut(StmtFlow::Direction dir, const FStmt* stmt, std::set<const FStmt*> &visited) {
+#if 0
+    std::cout << "getOut: " << stmt->toStatement()->toString() + ": " + stmt->toStatement()->getSourceInfo().toPositionString() << std::endl;
+#endif
+
+    visited.insert(stmt);
+
+    if (stmt->getContainer() == nullptr) {
+        // In case we're at the top-level (and can't get out) we first try continuing to travel
+        // in the same direction before giving up.
+        const FStmt *next = nullptr;
+        switch (dir) {
+            case Direction::Forward:
+                next = stmt->get_next();
+            case Direction::Backward:
+                next = stmt->get_prev();
+        }
+
+        if (next != nullptr) {
+            return std::set<const FStmt*>{next};
+        } else {
+            // This is how it ends: there's no containing structure, and no next step.
+            return std::set<const FStmt*>{};
+        }
+    } else {
+        switch (dir) {
+            case Direction::Forward:
+                return getNext(stmt->getContainer(), visited);
+            case Direction::Backward:
+                return getPrev(stmt->getContainer(), visited);
+        }
+    }
+}
+
+std::set<const FStmt*> StmtFlow::getIn(StmtFlow::Direction dir, const FStmt* stmt, std::set<const FStmt*> &visited) {
+#if 0
+    std::cout << "getIn: " << stmt->toStatement()->toString() + ": " + stmt->toStatement()->getSourceInfo().toPositionString() << std::endl;
+#endif
+
+    visited.insert(stmt);
+
+    const BlockStmt *bs = dynamic_cast<const BlockStmt*>(stmt);
+    if (bs != nullptr) {
+        if (bs->getEntry() != nullptr) {
+            switch (dir) {
+                case Direction::Forward:
+                    return std::set<const FStmt *>{bs->getEntry()};
+                case Direction::Backward:
+                    return std::set<const FStmt *>{bs->getLast()};
+            }
+        } else {
+            throw std::logic_error("Impossible: empty block");
+#if 0
+            // If we can't proceed vertically, then we proceed horizontally.
+            switch (dir) {
+                case Direction::Forward:
+//                    return std::set<const FStmt *>{stmt};
+                    return getNext(stmt, visited);
+                case Direction::Backward:
+//                    return std::set<const FStmt *>{stmt};
+                    return getPrev(stmt, visited);
+            }
+#endif
+        }
+    }
+    const IfStmt *ifst = dynamic_cast<const IfStmt*>(stmt);
+    if (ifst != nullptr) {
+        assert(ifst->get_ifTrue() != nullptr);
+        std::set<const FStmt*> result{ifst->get_ifTrue()};
+        if (ifst->get_ifFalse() != nullptr) {
+            result.insert(ifst->get_ifFalse());
+        }
+        return result;
+    }
+    const SwitchStmt *swst = dynamic_cast<const SwitchStmt*>(stmt);
+    if (swst != nullptr) {
+        std::set<const FStmt*> result;
+        for (auto c : swst->getCases()) {
+            result.insert(c.get_stmt());
+        }
+        return result;
+    }
+//    throw std::logic_error("getIn: Unknown statement type:" + stmt->toString());
+    throw std::logic_error("getIn: Unknown statement type");
+}
+
+std::string StmtFlow::stmt_kind(const FStmt* stmt) {
+    if (stmt == nullptr) {
+        throw std::logic_error("atomic_stmt: null stmt");
+    }
+    const BlockStmt *bs = dynamic_cast<const BlockStmt*>(stmt);
+    if (bs != nullptr) {
+        return "BlockStmt";
+    }
+    const Stmt *st = dynamic_cast<const Stmt*>(stmt);
+    if (st != nullptr) {
+        return "Stmt";
+    }
+    const TransferPoint *tp = dynamic_cast<const TransferPoint*>(stmt);
+    if (tp != nullptr) {
+        return "TransferPoint";
+    }
+    const IfStmt *ifst = dynamic_cast<const IfStmt*>(stmt);
+    if (ifst != nullptr) {
+        return "IfStmt";
+    }
+    const SwitchStmt *swst = dynamic_cast<const SwitchStmt*>(stmt);
+    if (swst != nullptr) {
+        return "SwitchStmt";
+    }
+//    throw std::logic_error("stmt_kind: Unknown statement type:" + stmt->toString());
+    throw std::logic_error("stmt_kind: Unknown statement type");
+}
+
+bool StmtFlow::atomic_stmt(const FStmt* stmt) {
+    if (stmt == nullptr) {
+        throw std::logic_error("atomic_stmt: null stmt");
+    }
+    const BlockStmt *bs = dynamic_cast<const BlockStmt*>(stmt);
+    if (bs != nullptr) {
+        return false;
+    }
+    const Stmt *st = dynamic_cast<const Stmt*>(stmt);
+    if (st != nullptr) {
+        return true;
+    }
+    const TransferPoint *tp = dynamic_cast<const TransferPoint*>(stmt);
+    if (tp != nullptr) {
+        return true;
+    }
+    const IfStmt *ifst = dynamic_cast<const IfStmt*>(stmt);
+    if (ifst != nullptr) {
+        return false;
+    }
+    const SwitchStmt *swst = dynamic_cast<const SwitchStmt*>(stmt);
+    if (swst != nullptr) {
+        return false;
+    }
+//    throw std::logic_error("atomic_stmt: Unknown statement type:" + stmt->toString());
+    throw std::logic_error("atomic_stmt: Unknown statement type");
+}
+
+bool StmtFlow::transfer_stmt(const FStmt* stmt) {
+    const TransferPoint *tp = dynamic_cast<const TransferPoint*>(stmt);
+    if (tp != nullptr) {
+        return true;
+    }
+    return false;
+}
+
+Split* StmtFlow::transfers_to(const FStmt* stmt) {
+    const TransferPoint *tp = dynamic_cast<const TransferPoint*>(stmt);
+    if (tp == nullptr) {
+        throw std::logic_error("Not a TransferPoint");
+    }
+    Split* result = nullptr;
+    for (auto split : Split::Splits) {
+#if 0
+        std::cout << "transfers_to : " << stmt->toString() << std::endl;
+        std::cout << "             : " << split->output_file << std::endl;
+        std::cout << "             : " << tp->transfer_to << std::endl;
+        std::cout << "             : " << tp->original->srcInfo.toBriefSourceFragment() << std::endl;
+#endif
+
+        std::string str(split->output_file);
+//        if (str.find(std::string(tp->transfer_to)) != std::string::npos) {
+        if (str.find(TransferPoint::flyto_target(std::string(tp->original->srcInfo.toBriefSourceFragment()))) != std::string::npos) {
+            result = split;
+            break;
+        }
+    }
+    assert(result != nullptr);
+    return result;
+}
+
+std::set<const FStmt*> StmtFlow::step(StmtFlow::Direction dir, const FStmt* stmt, std::set<const FStmt*> &visited) {
+    switch (dir) {
+        case Direction::Forward:
+            return getNext(stmt, visited);
+        case Direction::Backward:
+            return getPrev(stmt, visited);
+    }
+}
+
+std::set<const FStmt*> StmtFlow::step(StmtFlow::Direction dir, std::set<const FStmt*> stmts, std::set<const FStmt*> &visited) {
+    std::set<const FStmt*> result;
+    for (auto stmt : stmts) {
+        std::set<const FStmt*> pre_result = step(dir, stmt, visited);
+        if (pre_result.size() > 0) {
+            for (auto s : pre_result) {
+                result.insert(s);
+            }
+        }
+    }
+    return result;
+}
+
+std::string TransferPoint::flyto_target(const std::string& expression) {
+    std::regex regex("flyto\\(([a-zA-Z0-9_]+)\\(\\)\\)");
+    std::smatch match;
+//    std::cout << "MATCHING " << expression << std::endl;
+    if (!std::regex_search(expression.begin(), expression.end(), match, regex)) {
+        throw std::logic_error("TransferPoint::flyto_target: no match");
+    }
+    return match[1];
+}
+
+void transitive_closure(const FStmt* st, std::set<const FStmt*> &visited, const FStmt* pre_st=nullptr) {
+    std::set<const FStmt*> next = step(StmtFlow::Direction::Forward, st, visited);
+    bool src_atom = StmtFlow::atomic_stmt(st);
+    for (auto next_st : next) {
+        bool tgt_atom = StmtFlow::atomic_stmt(next_st);
+        if (st == next_st) {
+            throw std::logic_error("Unexpected");
+        }
+
+        if (src_atom) {
+            transitive_closure(next_st, visited, st);
+        } else {
+            transitive_closure(next_st, visited, pre_st);
+        }
+    }
+}
+
+std::set<const FStmt*> StmtFlow::TransitClos(const FStmt* stmt) {
+    std::set<const FStmt*> visited;
+    transitive_closure(stmt, visited);
+    return visited;
+}
+
+StmtFlow::P4_Stmt_Kind StmtFlow::p4_classify(IR::StatOrDecl* sod) {
+    if (nullptr == dynamic_cast<const IR::AssignmentStatement*>(sod)) {
+        return P4_Stmt_Kind::AssignmentStatement;
+    } else if (nullptr == dynamic_cast<const IR::MethodCallStatement*>(sod)) {
+        return P4_Stmt_Kind::MethodCallStatement;
+    } else if (nullptr == dynamic_cast<const IR::BlockStatement*>(sod)) {
+        return P4_Stmt_Kind::BlockStatement;
+    } else if (nullptr == dynamic_cast<const IR::StatOrDecl*>(sod)) {
+        return P4_Stmt_Kind::StatOrDecl;
+    } else if (nullptr == dynamic_cast<const IR::Statement*>(sod)) {
+        return P4_Stmt_Kind::Statement;
+    } else if (nullptr == dynamic_cast<const IR::Declaration*>(sod)) {
+        return P4_Stmt_Kind::Declaration;
+    } else if (nullptr == dynamic_cast<const IR::IfStatement*>(sod)) {
+        return P4_Stmt_Kind::IfStatement;
+    } else {
+        throw std::logic_error("Unrecognised StatOrDecl");
+    }
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan_preanalysis.h b/frontends/p4/flightplan_preanalysis.h
new file mode 100644
index 0000000..b3b3ac2
--- /dev/null
+++ b/frontends/p4/flightplan_preanalysis.h
@@ -0,0 +1,41 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_PREANALYSIS_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_PREANALYSIS_H_
+
+#include "flightplan.h"
+#include "flightplan_convert.h"
+
+namespace P4 {
+
+namespace StmtFlow {
+    enum class Direction {Forward, Backward};
+
+    bool atomic_stmt(const FStmt* stmt);
+    bool transfer_stmt(const FStmt* stmt);
+    Split* transfers_to(const FStmt* stmt);
+
+    std::set<const FStmt*> getNext(const FStmt* stmt, std::set<const FStmt*> &visited);
+    std::set<const FStmt*> getPrev(const FStmt* stmt, std::set<const FStmt*> &visited);
+    std::set<const FStmt*> getOut(Direction dir, const FStmt* stmt, std::set<const FStmt*> &visited);
+    std::set<const FStmt*> getIn(Direction dir, const FStmt* stmt, std::set<const FStmt*> &visited);
+    std::set<const FStmt*> step(Direction dir, const FStmt* stmt, std::set<const FStmt*> &visited);
+    std::set<const FStmt*> step(Direction dir, std::set<const FStmt*> stmts, std::set<const FStmt*> &visited);
+
+    void cfg_dot(std::ostream *ost, const FStmt* st, std::set<const FStmt*> &visited, const FStmt* pre_st=nullptr);
+
+    std::string stmt_kind(const FStmt* stmt);
+
+    std::set<const FStmt*> TransitClos(const FStmt* stmt);
+    std::set<const FStmt*> transfers(std::set<const FStmt*>);
+
+    enum class P4_Stmt_Kind {AssignmentStatement, MethodCallStatement, BlockStatement, StatOrDecl, Statement, Declaration, IfStatement};
+    P4_Stmt_Kind p4_classify(IR::StatOrDecl* sod);
+}
+
+}
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_PREANALYSIS_H_ */
diff --git a/frontends/p4/flightplan_stmt.cpp b/frontends/p4/flightplan_stmt.cpp
new file mode 100644
index 0000000..b320324
--- /dev/null
+++ b/frontends/p4/flightplan_stmt.cpp
@@ -0,0 +1,375 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#include <assert.h>
+#include <iostream>
+#include <fstream>
+
+#include "externInstance.h"
+
+#include "../common/options.h"
+#include "ir/ir.h"
+#include "ir/visitor.h"
+#include "lib/nullstream.h"
+#include "lib/path.h"
+#include "toP4/toP4.h"
+
+#include "flightplan.h"
+#include "flightplan_annotate.h"
+
+namespace P4 {
+
+FStmt::FStmt (const FStmt* container, std::string dest_path, FStmt* prev = nullptr, FStmt* next = nullptr) : DOT(FlightplanConfig::dot_id++), container(container), prev(prev), next(next) {
+    splits.insert(Split::current_split(dest_path, this));
+}
+
+FStmt::FStmt (const FStmt* container, unsigned dot_id, FStmt* prev, FStmt* next) : DOT(dot_id), container(container), prev(prev), next(next) {}
+
+Stmt::Stmt (const FStmt* container, std::string dest_path, const IR::AssignmentStatement* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next), original(stmt) {}
+Stmt::Stmt (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next), original(stmt) {}
+Stmt::Stmt (const FStmt* container, std::string dest_path, const IR::Declaration* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next), original(stmt) {
+    std::cout << "DECLARATION: " << stmt->toString() << std::endl;
+}
+
+TransferPoint::TransferPoint (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next), original(stmt) {}
+
+BlockStmt::BlockStmt (const FStmt* container, std::string dest_path, const IR::BlockStatement* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next), original(stmt) {
+    std::string abbrev_name = "block";
+    clust_id = new std::string("cluster_" + abbrev_name + "_" + DOTid());
+
+    FStmt* last = nullptr;
+    // Deconstruct stmt into statements, have block_entry point to the first of them.
+    for (const IR::StatOrDecl* c : stmt->components) {
+        if (block_entry == nullptr) {
+            assert(last == nullptr);
+            last = StmtConvert::encapsulate(this, dest_path, c, nullptr, nullptr);
+            block_entry = last;
+        } else {
+            auto new_last = StmtConvert::encapsulate(this, dest_path, c, last, nullptr);
+            last->set_next(new_last);
+            last = new_last;
+        }
+    }
+}
+//
+//BlockStmt::BlockStmt (const FStmt* container, std::string dest_path, FStmt* given_block_entry, const FStmt* prev, const FStmt* next) : FStmt(container, dest_path, prev, next), original(stmt) {
+//   block_entry =  given_block_entry;
+//}
+
+IfStmt::IfStmt (const FStmt* container, std::string dest_path, const IR::IfStatement* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next) {
+    std::string abbrev_name = "if";
+    clust_id = new std::string("cluster_" + abbrev_name + "_" + DOTid());
+
+    condition = stmt->condition;
+    ifTrue = StmtConvert::encapsulate(this, dest_path, stmt->ifTrue, nullptr, nullptr);
+    if (stmt->ifFalse == nullptr) {
+        ifFalse = nullptr;
+    } else {
+        ifFalse = StmtConvert::encapsulate(this, dest_path, stmt->ifFalse, nullptr, nullptr);
+    }
+}
+
+SwitchStmt::SwitchStmt (const FStmt* container, std::string dest_path, const IR::SwitchStatement* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next) {
+    expression = stmt->expression;
+    for (auto c : stmt->cases) {
+        Case cs = Case(c->label, StmtConvert::encapsulate(this, dest_path, c->statement, nullptr, nullptr));
+        cases.push_back(cs);
+    }
+}
+
+const IR::StatOrDecl* Stmt::toStatement() const {
+    return original;
+}
+
+cstring Stmt::toString() const {
+//    return "/*Stmt*/" + original->srcInfo.toSourceFragment();
+    return std::string("/*Stmt: " + splits_string() + " " + toP4String() + " */");
+}
+
+cstring BlockStmt::toString() const {
+//    return "/*BlockStmt*/" + toStatement()->srcInfo.toSourceFragment();
+//    return "/*BlockStmt*/" + toStatement()->toString();
+    return "/*BlockStmt*/";
+}
+
+cstring IfStmt::toString() const {
+//    return "/*IfStmt*/" + toStatement()->srcInfo.toSourceFragment();
+    return "/*IfStmt*/";
+}
+
+cstring SwitchStmt::toString() const {
+//    return "/*SwitchStmt*/" + toStatement()->srcInfo.toSourceFragment();
+    return "/*SwitchStmt*/";
+}
+
+cstring TransferPoint::toString() const {
+//    return toStatement()->srcInfo.toSourceFragment();
+//    return "/*flyto " + this->transfer_to + "*/";  
+    return "/*flyto: " + toP4String() + "*/";
+}
+
+const IR::StatOrDecl* BlockStmt::toStatement() const {
+    // Reconstruct block of statements from block_entry
+    const FStmt* cursor = block_entry;
+    IR::BlockStatement* result = new IR::BlockStatement();
+    while (cursor != nullptr) {
+        result->push_back(cursor->toStatement());
+        cursor = cursor->get_next();
+    }
+    return result;
+}
+
+const IR::Statement* IfStmt::trueStatement() const {
+    const IR::Statement* result = nullptr;
+    if (ifTrue != nullptr) {
+        result = &ifTrue->toStatement()->as<IR::Statement>();
+    }
+    return result;
+}
+
+const IR::Statement* IfStmt::falseStatement() const {
+    const IR::Statement* result = nullptr;
+    if (ifFalse != nullptr) {
+        result = &ifFalse->toStatement()->as<IR::Statement>();
+    }
+    return result;
+}
+
+const IR::StatOrDecl* IfStmt::toStatement() const {
+    // Reconstruct block of statements from block_entry
+    IR::IfStatement* result = new IR::IfStatement(condition, trueStatement(), falseStatement());
+    return result;
+}
+
+const IR::StatOrDecl* SwitchStmt::toStatement() const {
+    IR::Vector<IR::SwitchCase> cases;
+    for (auto c : this->cases) {
+        IR::SwitchCase *sc = new IR::SwitchCase(c.label, c.get_statement());
+        cases.push_back(sc);
+    }
+    IR::SwitchStatement* result = new IR::SwitchStatement(expression, cases);
+    return result;
+}
+
+FStmt* StmtConvert::encapsulate (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* mcs, FStmt* prev, FStmt* next) {
+    const IR::MethodCallExpression* mce = mcs->methodCall;
+
+    auto mi = P4::MethodInstance::resolve(mce, FlightplanConfig::FP_refMap, FlightplanConfig::FP_typeMap);
+
+#if 0
+    for (auto param : *mi->getActualParameters()) {
+        visit(param->getNode());
+    }
+#endif
+
+    if (mi->is<P4::ExternFunction>()) {
+#if 0      
+        print_ctxt();
+#endif
+
+        auto ef = mi->to<P4::ExternFunction>();
+        std::cout << "Flightplan: call statement: " << ef->method->toString() << std::endl;
+        //Split::new_split();
+        if (FlightplanConfig::FP_options.flightplan_mode != CompilerOptions::FlightplanMode::Split) {
+                std::cout << "WARNING: not effecting Flightplan transfer since not in Split mode" << std::endl;
+        } else {
+            if (FlightplanConfig::landing_API.find(std::string(ef->method->toString())) != FlightplanConfig::landing_API.end()) {
+    //            std::cout << mce->toString();
+    //            Split::new_split(std::string(options.flightplanFolder), std::string(mce->arguments->at(0)->toString()));
+                // We only insert a TransferPoint at this stage. Then during a later pass we'll annotate each statement on which split(s) is belongs to.
+                auto tp = new TransferPoint (container, dest_path, mcs, prev, next);
+                // NOTE assuming that the parameter to flyto() hasn't been tampered with by any earlier passes.
+    //            tp->transfer_to = std::string(mce->arguments->at(0)->toString());
+    
+    //            std::stringstream sstream;
+    //            P4::ToP4 top4(&sstream, false, "");
+    //            ((IR::Statement*)mcs)->apply(top4);
+    //            tp->transfer_to = sstream.str();
+    
+                tp->transfer_to = TransferPoint::flyto_target(std::string(mcs->srcInfo.toBriefSourceFragment()));
+                std::cout << "Flightplan transfer: " << tp->transfer_to << std::endl;
+                return tp;
+            }
+        }
+//        return new IR::EmptyStatement(); FIXME why does this go through the compiler?
+    } else {
+        std::cout << "-> " << mce->toString() << std::endl;
+    }
+
+    if (!mi->is<P4::ExternFunction>()) {
+      return new Stmt (container, dest_path, mcs, prev, next);
+    }
+
+#if 1
+    return new Stmt (container, dest_path, mcs, prev, next);
+#else
+//    return new Stmt (container, dest_path, mcs, prev, next);
+    auto orig_stmt = new Stmt (container, dest_path, mcs, prev, next);
+/*
+    auto new_call = new IR::MethodCallStatement(
+    auto orig_stmt = new Stmt (container, dest_path, mcs, prev, next);
+    orig_stmt->set_next( 
+*/
+
+    const cstring n = "flyto";
+    auto ty = new IR::Type_Method(new IR::ParameterList());
+//    auto m = new IR::Method(IR::ID(n), ty);
+    auto Pmethod = new IR::Method(IR::ID(Util::SourceInfo(), n), ty, nullptr);
+    auto bty = IR::Type_Bits::get(32, false);
+
+
+auto expr = new IR::PathExpression(IR::ID(Util::SourceInfo(), n));
+auto method = new IR::Member(expr->srcInfo, expr, IR::Type_Header::setInvalid);
+//method->Ann
+//Annotations::empty
+
+auto ef = mi->to<P4::ExternFunction>();
+std::string extern_name = std::string(ef->method->toString());
+
+//auto landing = new IR::PathExpression(IR::ID(Util::SourceInfo(), cstring("FlightStart")));
+auto suffix = std::to_string(FlightplanAnnotate::NoSegments);
+std::string segment_name;
+std::string* looked_up = FlightplanAnnotate::lookup_extern(extern_name);
+if (nullptr == looked_up) {
+  segment_name = "Segment_" + suffix;
+} else {
+  segment_name = *looked_up;
+}
+
+auto landing = new IR::PathExpression(IR::ID(Util::SourceInfo(), segment_name));
+auto args = new IR::Vector<IR::Argument>();
+auto landing_arg = new IR::Argument(landing);
+args->push_back(landing_arg);
+//auto mc = new IR::MethodCallExpression(Util::SourceInfo(), method, args);
+auto mc = new IR::MethodCallExpression(Util::SourceInfo(), expr, args);
+auto stat = new IR::MethodCallStatement(mc->srcInfo, mc);
+
+//auto b = new IR::BlockStatement();
+//b->push_back(mcs);
+//b->push_back(stat);
+
+
+//   420             type->methods.push_back(new IR::Method(type->name, new IR::Type_Method(                                                                    
+//                      421                                                 new IR::ParameterList()))); } }                                                                        
+//
+
+
+//BlockStmt::BlockStmt (const FStmt* container, std::string dest_path, FStmt* stmt, const FStmt* prev, const FStmt* next) : FStmt(container, dest_path, prev, next) {
+//    return new Stmt (container, dest_path, mcs, prev, next);
+//    return new Stmt (container, dest_path, stat, prev, next);
+//    return new BlockStmt (container, dest_path, b, prev, next);
+    auto result = new Stmt (container, dest_path, stat, prev, orig_stmt);
+    orig_stmt->set_prev(result);
+//    return orig_stmt;
+//    return result;
+
+    orig_stmt->set_next(nullptr);
+    result->set_next(orig_stmt);
+    result->set_prev(nullptr);
+
+    landing = new IR::PathExpression(IR::ID(Util::SourceInfo(), "FlightStart"));
+    args = new IR::Vector<IR::Argument>();
+    landing_arg = new IR::Argument(landing);
+    args->push_back(landing_arg);
+    mc = new IR::MethodCallExpression(Util::SourceInfo(), expr, args);
+    stat = new IR::MethodCallStatement(mc->srcInfo, mc);
+    orig_stmt->set_next(new Stmt (container, dest_path, stat, orig_stmt, nullptr));
+
+if (nullptr == looked_up) {
+  FlightplanAnnotate::NoSegments += 1;
+}
+FlightplanAnnotate::NoJumps += 2;
+if (nullptr == looked_up) {
+  FlightplanAnnotate::add_segment(segment_name);
+  std::cout << "New segment " << segment_name << " |-> " << extern_name << std::endl;
+}
+for (const auto& p : FlightplanAnnotate::Tip) {
+  FlightplanAnnotate::link(p.first, segment_name);
+}
+FlightplanAnnotate::retip(segment_name, extern_name);
+//FlightplanAnnotate::link(segment_name, "FlightStart");  
+//FlightplanAnnotate::retip_flightstart();  
+if (nullptr == looked_up) {
+  FlightplanAnnotate::add_segment_extern(segment_name, extern_name);
+}
+    return new BlockStmt (container, dest_path, result, prev, next);
+#endif
+}
+
+FStmt* TransferPoint::clone() const {
+    TransferPoint* result = new TransferPoint(container, dot_id, prev, next);
+    result->original = this->original;
+    /*FIXME copy state*/
+    return result;
+}
+
+FStmt* Stmt::clone() const {
+    // FIXME have cloning generate new DOTid, to show multiple splits in the same graph
+    Stmt* result = new Stmt(container, dot_id, prev, next);
+    result->original = this->original;
+    assert(result->original != nullptr);
+    return result;
+}
+
+FStmt* BlockStmt::clone() const {
+    BlockStmt* result = new BlockStmt(container, dot_id, prev, next);
+    result->original = this->original;
+    result->clust_id = this->clust_id;
+    result->block_entry = this->block_entry;
+    return result;
+}
+
+FStmt* IfStmt::clone() const {
+    IfStmt* result = new IfStmt(container, dot_id, prev, next);
+    result->condition = this->condition;
+    result->clust_id = this->clust_id;
+    result->ifTrue = this->ifTrue;
+    result->ifFalse = this->ifFalse;
+    return result;
+}
+
+FStmt* SwitchStmt::clone() const {
+    SwitchStmt* result = new SwitchStmt(container, dot_id, prev, next);
+    result->expression = this->expression;
+    result->clust_id = this->clust_id;
+    result->cases = this->cases;
+    return result;
+}
+
+BlockStmt::BlockStmt (const FStmt* container, std::string dest_path, FStmt* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next) {
+    std::string abbrev_name = "block";
+    clust_id = new std::string("cluster_" + abbrev_name + "_" + DOTid());
+
+    block_entry = stmt;
+}
+
+#if 0
+BlockStmt* BlockStmt::block_from (const FStmt* container, std::string dest_path, FStmt* stmt, const FStmt* prev, const FStmt* next) {
+    assert(stmt->getContainer() == nullptr);
+    BlockStmt* result = BlockStmt (container, dest_path, stmt, prev, next);
+
+    return result;
+}
+#endif
+
+FStmt::Kind FStmt::classify(FStmt* fstmt) {
+    if (dynamic_cast<EntryPoint*>(fstmt) != nullptr) {
+        return FStmt::Kind::EntryPoint;
+    } else if (dynamic_cast<TransferPoint*>(fstmt) != nullptr) {
+        return FStmt::Kind::TransferPoint;
+    } else if (dynamic_cast<Stmt*>(fstmt) != nullptr) {
+        return FStmt::Kind::Stmt;
+    } else if (dynamic_cast<BlockStmt*>(fstmt) != nullptr) {
+        return FStmt::Kind::BlockStmt;
+    } else if (dynamic_cast<IfStmt*>(fstmt) != nullptr) {
+        return FStmt::Kind::IfStmt;
+    } else if (dynamic_cast<SwitchStmt*>(fstmt) != nullptr) {
+        return FStmt::Kind::SwitchStmt;
+    } else {
+        throw std::logic_error("Unrecognised FStmt");
+    }
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan_stmt.h b/frontends/p4/flightplan_stmt.h
new file mode 100644
index 0000000..6808d6b
--- /dev/null
+++ b/frontends/p4/flightplan_stmt.h
@@ -0,0 +1,343 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_STMT_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_STMT_H_
+
+#include "flightplan.h"
+
+namespace P4 {
+
+class FStmt : public DOT {
+ protected:
+    friend class ProtoAnnotate;
+    template <class Ann> friend class ProtoAnnotateGeneric;
+    friend class FStmtDeepClone;
+    friend class Dleary;
+    friend class Flightplan_Annotator;
+
+    const FStmt* container = nullptr;
+
+    FStmt* prev = nullptr;
+    FStmt* next = nullptr;
+
+    void clone_from(FStmt* from_stmt) {
+        container = from_stmt->container;
+        //prev = from_stmt->prev;
+        //next = from_stmt->next;
+        prev = nullptr;
+        next = nullptr;
+        splits.clear();
+        for (auto s : from_stmt->splits) {
+            splits.insert(s);
+        }
+    }
+
+    FStmt (const FStmt* container, unsigned dot_id, FStmt* prev, FStmt* next);
+
+ public:
+    template <class Out, class State> friend class FStmtAnalyse;
+
+    enum class Kind {EntryPoint, TransferPoint, Stmt, BlockStmt, IfStmt, SwitchStmt};
+    static Kind classify(FStmt* fstmt);
+
+    std::set<Split*> splits;
+    std::string splits_string() const {
+      std::string result = "splits{";
+      bool started = false;
+      for (Split* s : splits) {
+        if (!started) result += s->name;
+        else result += " " + s->name;
+        started = true;
+      }
+      return result + "}";
+    }
+    explicit FStmt (const FStmt* container, std::string dest_path, FStmt* prev, FStmt* next);
+
+    // Purge all other splits that this stmt links to, except for one.
+    // For "effected" splits, this is used to purge other split
+    // info from each stmt in a split.
+    void keep_split(Split *split) {
+        assert(split != nullptr);
+        // FIXME these assertions should be switched on
+//        assert(splits.size() > 0);
+//        assert(splits.find(split) != splits.end());
+        splits.clear();
+        splits.insert(split);
+    }
+
+    void set_next (FStmt* next) {
+        this->next = next;
+    }
+
+    void set_prev (FStmt* prev) {
+        this->prev = prev;
+    }
+
+    FStmt* get_next () const {
+        return this->next;
+    }
+
+    FStmt* get_prev () const {
+        return this->prev;
+    }
+
+    const FStmt* getContainer() const {
+       return container;
+    }
+
+    std::string link_from_prev() const;
+
+    virtual FStmt* clone() const = 0;
+
+    virtual const IR::StatOrDecl* toStatement() const = 0;
+
+    virtual cstring toString() const = 0;
+
+    static void toString(const std::vector<const FStmt*> &steps) {
+        for (auto s : steps) {
+            std::cout << ":" << s->toString() << std::endl;
+        }
+    }
+
+    static void toFile(cstring inputfile, const cstring destination, const IR::P4Program* prog) {
+        if (!destination.isNullOrEmpty()) {
+            Util::PathName path(destination);
+            std::ostream *ppStream = new std::ofstream(path.toString(), std::ios_base::app);
+            *ppStream << FlightplanConfig::header_comment << std::endl << std::endl;
+            P4::ToP4 top4(ppStream, false, inputfile);
+            (void)prog->apply(top4);
+        } else {
+            ::error("Null filename?");
+        }
+    }
+
+    std::string toP4String() const {
+        auto stmt = this->toStatement();
+        std::ostringstream ppStream;
+        P4::ToP4 top4(&ppStream, false);
+        (void)stmt->apply(top4);
+        return ppStream.str();
+    }
+
+    static std::string toP4String(const IR::Expression* expr) {
+        std::ostringstream ppStream;
+        P4::ToP4 top4(&ppStream, false);
+        (void)expr->apply(top4);
+        return ppStream.str();
+    }
+
+    static std::string toP4String(const IR::Type* type) {
+        std::ostringstream ppStream;
+        P4::ToP4 top4(&ppStream, false);
+        (void)type->apply(top4);
+        return ppStream.str();
+    }
+
+    static std::string toP4String(const IR::StatOrDecl* stmt) {
+        std::ostringstream ppStream;
+        P4::ToP4 top4(&ppStream, false);
+        (void)stmt->apply(top4);
+        return ppStream.str();
+    }
+};
+
+class EntryPoint : public FStmt {
+ public:
+    EntryPoint (std::string dest_path, FStmt* next) : FStmt (nullptr, dest_path, nullptr, next) {}
+
+    const IR::StatOrDecl* toStatement() const override {
+        return new IR::EmptyStatement();
+    }
+    cstring toString() const override {
+        return std::string("/*EntryPoint*/");
+    }
+    std::string toDOT() const override {
+      std::string result = DOTid() + " [label=\"\",color=white,style=invis]; // Entry point\n";
+      return result;
+    }
+    FStmt* clone() const override {
+        throw std::logic_error("Cannot clone EntryPoint");
+    }
+};
+
+class TransferPoint : public FStmt {
+
+    TransferPoint (const FStmt* container, unsigned dot_id, FStmt* prev, FStmt* next) : FStmt (container, dot_id, prev, next) {}
+
+ public:
+    const IR::StatOrDecl* original = nullptr;
+    std::string transfer_to;
+
+    TransferPoint (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* stmt, FStmt* prev, FStmt* next);
+    const IR::StatOrDecl* toStatement() const override {
+        return original;
+    }
+    cstring toString() const override;
+    std::string toDOT() const override;
+
+    FStmt* clone() const override;
+
+    // FIXME ensure that types have defined width.
+    static void free_vars(std::map<std::string,std::string/*FIXME use AST objects*/> &context);
+
+    static std::string flyto_target(const std::string& expression);
+};
+
+class Stmt : public FStmt {
+    friend class ProtoAnnotate;
+    template <class Ann> friend class ProtoAnnotateGeneric;
+    friend class Cleary;
+    friend class Dleary;
+    friend class Flightplan_Annotator;
+    friend class ExternScanner;
+    Stmt (const FStmt* container, unsigned dot_id, FStmt* prev, FStmt* next) : FStmt (container, dot_id, prev, next) {}
+ public:
+    const IR::StatOrDecl* original = nullptr;
+    Stmt (const FStmt* container, std::string dest_path, const IR::AssignmentStatement* stmt, FStmt* prev, FStmt* next);
+    Stmt (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* stmt, FStmt* prev, FStmt* next);
+    Stmt (const FStmt* container, std::string dest_path, const IR::Declaration* stmt, FStmt* prev, FStmt* next);
+
+    const IR::StatOrDecl* toStatement() const override;
+    cstring toString() const override;
+    std::string toDOT() const override;
+    FStmt* clone() const override;
+};
+
+class BlockStmt : public FStmt {
+    const IR::BlockStatement* original = nullptr;
+    FStmt* block_entry = nullptr;
+    BlockStmt (const FStmt* container, unsigned dot_id, FStmt* prev, FStmt* next) : FStmt (container, dot_id, prev, next) {}
+ public:
+    template <class Out, class State> friend class FStmtAnalyse;
+    friend class Dleary;
+    BlockStmt (const FStmt* container, std::string dest_path, const IR::BlockStatement* stmt, FStmt* prev, FStmt* next);
+    BlockStmt (const FStmt* container, std::string dest_path, FStmt* stmt, FStmt* prev, FStmt* next);
+
+    const IR::StatOrDecl* toStatement() const override;
+    cstring toString() const override;
+    std::string toDOT() const override;
+    std::string entryDOTid() const override;
+    FStmt* getEntry() const {
+        return block_entry;
+    }
+    void setEntry(FStmt* stmt) {
+        block_entry = stmt;
+    }
+    const FStmt* getLast() const {
+        const FStmt* cursor = block_entry;
+        assert(cursor != nullptr);
+        // Walk to the last entry.
+        while (cursor->get_next() != nullptr) {
+            cursor = cursor->get_next();
+        }
+        return cursor;
+    }
+    FStmt* clone() const override;
+
+//    static BlockStmt* block_from (const FStmt* container, std::string dest_path, FStmt* stmt, const FStmt* prev, const FStmt* next);
+};
+
+class IfStmt : public FStmt {
+    const IR::Expression *condition = nullptr;
+    FStmt* ifTrue = nullptr;
+    FStmt* ifFalse = nullptr;
+    IfStmt (const FStmt* container, unsigned dot_id, FStmt* prev, FStmt* next) : FStmt (container, dot_id, prev, next) {}
+ public:
+    template <class Out, class State> friend class FStmtAnalyse;
+    friend class FStmtDeepClone;
+    friend class Flightplan_Annotator;
+    IfStmt (const FStmt* container, std::string dest_path, const IR::IfStatement* stmt, FStmt* prev, FStmt* next);
+
+    const IR::StatOrDecl* toStatement() const override;
+    cstring toString() const override;
+    std::string toDOT() const override;
+
+    const IR::Statement* trueStatement() const;
+    const IR::Statement* falseStatement() const;
+
+    FStmt* get_ifTrue() const {
+        return ifTrue;
+    }
+    FStmt* get_ifFalse() const {
+        return ifFalse;
+    }
+    void set_ifTrue(FStmt* stmt) {
+        ifTrue = stmt;
+    }
+    void set_ifFalse(FStmt* stmt) {
+        ifFalse = stmt;
+    }
+    const IR::Expression* getCondition() const {
+      return condition;
+    }
+    FStmt* clone() const override;
+};
+
+class SwitchStmt : public FStmt {
+    const IR::Expression *expression = nullptr;
+    SwitchStmt (const FStmt* container, unsigned dot_id, FStmt* prev, FStmt* next) : FStmt (container, dot_id, prev, next) {}
+ public:
+    SwitchStmt (const FStmt* container, std::string dest_path, const IR::SwitchStatement* stmt, FStmt* prev, FStmt* next);
+
+    const IR::StatOrDecl* toStatement() const override;
+    cstring toString() const override;
+    std::string toDOT() const override;
+
+    // FIXME no public way to examin the private "expression".  
+
+    friend class FStmtDeepClone;
+    friend class Flightplan_Annotator;
+    friend class Dleary;
+
+    class Case final {
+        FStmt *stmt = nullptr;
+     public:
+        template <class Out, class State> friend class FStmtAnalyse;
+        friend class FStmtDeepClone;
+        friend class Flightplan_Annotator;
+        friend class Dleary;
+        const IR::Expression *label = nullptr;
+        Case (const IR::Expression *label, FStmt *stmt) : label(label), stmt(stmt) {}
+        const FStmt* get_stmt() const {
+            return stmt;
+        }
+        const IR::Statement* get_statement() const {
+            const IR::Statement *result = nullptr;
+            if (stmt != nullptr) {
+                result = &stmt->toStatement()->as<IR::Statement>();
+            }
+            return result;
+        }
+        FStmt* get_fstmt() const {
+            return this->stmt;
+        }
+        void set_fstmt(FStmt* stmt) {
+            this->stmt = stmt;
+        }
+        const IR::Expression* getLabel() const {
+            return label;
+        }
+    };
+ private:
+    std::vector<Case> cases;
+ public:
+    std::vector<Case> getCases() const {
+        return cases;
+    }
+    void setCaseStatement(int i, FStmt* stmt) {
+        cases[i].set_fstmt(stmt);
+    }
+    const IR::Expression* getExpression() const {
+        return expression;
+    }
+    FStmt* clone() const override;
+};
+
+
+}
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_STMT_H_ */
+
diff --git a/frontends/p4/frontend.cpp b/frontends/p4/frontend.cpp
index ba7266e..5dcab24 100644
--- a/frontends/p4/frontend.cpp
+++ b/frontends/p4/frontend.cpp
@@ -36,6 +36,8 @@ limitations under the License.
 #include "directCalls.h"
 #include "dontcareArgs.h"
 #include "evaluator/evaluator.h"
+#include "flightplan.h"
+#include "flightplan_annotate.h"
 #include "frontends/common/constantFolding.h"
 #include "functionsInlining.h"
 #include "hierarchicalNames.h"
@@ -158,6 +160,9 @@ const IR::P4Program *FrontEnd::run(const CompilerOptions &options, const IR::P4P
         new RemoveAllUnusedDeclarations(&refMap, true),
         new SimplifyParsers(&refMap),
         new ResetHeaders(&refMap, &typeMap),
+
+//        new Flightplan(&refMap, &typeMap, options),
+
         new UniqueNames(&refMap),  // Give each local declaration a unique internal name
         new MoveDeclarations(),  // Move all local declarations to the beginning
         new MoveInitializers(),
@@ -189,6 +194,23 @@ const IR::P4Program *FrontEnd::run(const CompilerOptions &options, const IR::P4P
         new UniqueParameters(&refMap, &typeMap),
         new SimplifyControlFlow(&refMap, &typeMap),
         new HierarchicalNames(),
+// NOTE repeated by me
+        new ClearTypeMap(&typeMap),
+        evaluator,
+        new Inline(&refMap, &typeMap, evaluator),
+        new InlineActions(&refMap, &typeMap),
+        new InlineFunctions(&refMap, &typeMap),
+        // Check for constants only after inlining
+        new CheckConstants(&refMap, &typeMap),
+
+        new ConstantFolding(&refMap, &typeMap),
+
+        new SimplifyControlFlow(&refMap, &typeMap),
+// NOTE end of repetition
+
+//        new FlightplanAnnotate(&refMap, &typeMap, options),
+        new Flightplan(&refMap, &typeMap, options),
+
         new FrontEndLast(),
     };
 
diff --git a/frontends/p4/methodInstance.cpp b/frontends/p4/methodInstance.cpp
index ceaa6c0..1a4b895 100644
--- a/frontends/p4/methodInstance.cpp
+++ b/frontends/p4/methodInstance.cpp
@@ -27,7 +27,10 @@ MethodInstance::resolve(const IR::MethodCallExpression* mce, ReferenceMap* refMa
     auto mt = typeMap->getType(mce->method);
     if (mt == nullptr && useExpressionType)
         mt = mce->method->type;
+// Print out mce    
+//std::cout << "MCE: " << mce->toString() << std::endl;   
     CHECK_NULL(mt);
+//std::cout << "mt: " << mt->toString() << std::endl;   
     BUG_CHECK(mt->is<IR::Type_MethodBase>(), "%1%: expected a MethodBase type", mt);
     auto originalType = mt->to<IR::Type_MethodBase>();
     auto actualType = originalType;
