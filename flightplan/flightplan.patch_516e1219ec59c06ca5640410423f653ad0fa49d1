diff --git a/CMakeLists.txt b/CMakeLists.txt
index 6b1123c..4822c4a 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,4 +1,5 @@
 # Copyright 2013-present Barefoot Networks, Inc.
+# Copyright 2020 University of Pennsylvania
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -30,16 +31,18 @@ set (CMAKE_USE_RELATIVE_PATHS 1)
 
 OPTION (ENABLE_DOCS "Build the documentation" OFF)
 OPTION (ENABLE_GTESTS "Enable building and running GTest unit tests" ON)
-OPTION (ENABLE_BMV2 "Build the BMV2 backend (required for the full test suite)" ON)
-OPTION (ENABLE_EBPF "Build the EBPF backend (required for the full test suite)" ON)
+OPTION (ENABLE_BMV2 "Build the BMV2 backend (required for the full test suite)" OFF)
+OPTION (ENABLE_EBPF "Build the EBPF backend (required for the full test suite)" OFF)
 OPTION (ENABLE_P4TEST "Build the P4Test backend (required for the full test suite)" ON)
 OPTION (ENABLE_P4C_GRAPHS "Build the p4c-graphs backend" ON)
-OPTION (ENABLE_PROTOBUF_STATIC "Link against Protobuf statically" ON)
-OPTION (ENABLE_GC "Use libgc" ON)
+OPTION (ENABLE_PROTOBUF_STATIC "Link against Protobuf statically" OFF)
+#OPTION (ENABLE_GC "Use libgc" ON)
+OPTION (ENABLE_GC "Use libgc" OFF)
 OPTION (ENABLE_MULTITHREAD "Use multithreading" OFF)
 
 if (NOT CMAKE_BUILD_TYPE)
-  set (CMAKE_BUILD_TYPE "RELEASE")
+#  set (CMAKE_BUILD_TYPE "RELEASE")
+set (CMAKE_BUILD_TYPE "DEBUG")
 endif()
 
 if (NOT $ENV{P4C_VERSION} STREQUAL "")
diff --git a/frontends/CMakeLists.txt b/frontends/CMakeLists.txt
index 970b100..9387e24 100644
--- a/frontends/CMakeLists.txt
+++ b/frontends/CMakeLists.txt
@@ -1,4 +1,5 @@
 # Copyright 2013-present Barefoot Networks, Inc.
+# Copyright 2020 University of Pennsylvania
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -12,6 +13,31 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+set (FLIGHTPLAN_SRCS
+  p4/flightplan.cpp
+  p4/flightplan_dot.cpp
+  p4/flightplan_ext.cpp
+  p4/flightplan_preanalysis.cpp
+  p4/flightplan_analysis.cpp
+  p4/flightplan_stmt.cpp
+  p4/flightplan_annotate.cpp
+  p4/flightplan_externs.cpp
+  p4/flightplan_annotator.cpp
+  p4/flightplan_context_analysis.cpp
+  )
+
+set (FLIGHTPLAN_HDRS
+  p4/flightplan.h
+  p4/flightplan_stmt.h
+  p4/flightplan_convert.h
+  p4/flightplan_convert_extra.h
+  p4/flightplan_annotate.h
+  p4/flightplan_preanalysis.h
+  p4/flightplan_externs.h
+  p4/flightplan_annotator.h
+  p4/flightplan_context_analysis.h
+  )
+
 set (P4_FRONTEND_SRCS
   p4/actionsInlining.cpp
   p4/callGraph.cpp
@@ -227,6 +253,7 @@ add_parser(p4)
 set (FRONTEND_SOURCES
   ${COMMON_FRONTEND_SRCS}
   ${PARSERS_SRCS}
+  ${FLIGHTPLAN_SRCS}
   ${P4_FRONTEND_SRCS}
   ${V1_FRONTEND_SRCS}
   ${p4PARSER_GEN_SRCS}
@@ -239,7 +266,7 @@ set_source_files_properties(${v1PARSER_GEN_SRCS} PROPERTIES GENERATED TRUE)
 set_source_files_properties(${p4PARSER_GEN_SRCS} PROPERTIES GENERATED TRUE)
 
 set (FRONTEND_CPPLINT_FILES
-  ${P4_FRONTEND_SRCS} ${P4_FRONTEND_HDRS}
+  ${P4_FRONTEND_SRCS} ${P4_FRONTEND_HDRS} ${FLIGHTPLAN_HDRS}
   ${COMMON_FRONTEND_SRCS} ${COMMON_FRONTEND_HDRS}
   ${V1_FRONTEND_SRCS} ${V1_FRONTEND_HDRS}
   ${PARSERS_SRCS} ${PARSERS_HDRS})
diff --git a/frontends/common/options.cpp b/frontends/common/options.cpp
index 37a24f4..89ee31e 100644
--- a/frontends/common/options.cpp
+++ b/frontends/common/options.cpp
@@ -1,5 +1,6 @@
 /*
 Copyright 2013-present Barefoot Networks, Inc.
+Copyright 2020 University of Pennsylvania
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -33,6 +34,8 @@ const char* p4_14includePath = CONFIG_PKGDATADIR "/p4_14include";
 
 const char* CompilerOptions::defaultMessage = "Compile a P4 program";
 
+const int default_flightplan_max_handover_bytes = 13;
+
 CompilerOptions::CompilerOptions() : Util::Options(defaultMessage) {
     registerOption("--help", nullptr,
                    [this](const char*) { usage(); exit(0); return false; },
@@ -183,6 +186,170 @@ CompilerOptions::CompilerOptions() : Util::Options(defaultMessage) {
                   "  sourceFile:level,...,sourceFile:level\n"
                   "where 'sourceFile' is a compiler source file and\n"
                   "'level' is the verbosity level for LOG messages in that file");
+    registerOption("--flightplan", nullptr,
+                    [this](const char*) { flightplan = true; return true; },
+                    "Activate the Flightplan pass");
+    registerOption("--flightplan_verbse", nullptr,
+                    [this](const char*) { flightplan_verbose = true; return true; },
+                    "Verbose output from Flightplan");
+    registerOption("--flightplan_dest", "folder",
+                   [this](const char* arg) { flightplanFolder = arg; return true; },
+                   "Folder where P4 programs generated by Flightplan are written to\n");
+    registerOption("--flightplan_switch_md", "type name",
+                   [this](const char* arg) { flightplan_switch_md = arg; return true; },
+                   "Switch metadata datatype name.\n"/*FIXME show default value*/);
+    registerOption("--flightplan_standard_md", "type name",
+                   [this](const char* arg) { flightplan_standard_md = arg; return true; },
+                   "'Standard metadata' datatype name.\n"/*FIXME show default value*/);
+    registerOption("--flightplan_egress_var", "egress_member_in_standard_metadata",
+                   [this](const char* arg) { flightplan_egress_var = arg; return true; },
+                   "Member name of the egress port in the 'standard metadata' datatype.\n"/*FIXME show default value*/);
+    registerOption("--flightplan_ingress_var", "ingress_member_in_standard_metadata",
+                   [this](const char* arg) { flightplan_ingress_var = arg; return true; },
+                   "Member name of the ingress port in the 'standard metadata' datatype.\n"/*FIXME show default value*/);
+    registerOption("--flightplan_max_handover_bytes", "num",
+                   [this](const char* arg) { flightplan_max_handover_bytes = std::stoi(arg); return true; },
+                   "Maximum no. of bytes that can be handed over if the runtime supports hand-over.\n"/*FIXME show default value*/);
+    registerOption("--flightplan_routing_segment", "segment name",
+                   [this](const char* arg) { flightplan_routing_segment = arg; return true; },
+                   "Name of the routing segment.\n");
+    registerOption("--flightplan_dots", nullptr,
+                    [this](const char*) { flightplan_DOT_output = true; return true; },
+                    "Generate DOT file showing split P4 program");
+    registerOption("--flightplan_mode", "{analyse|annotate|split}",
+                    [this](const char* arg) {
+                     if (!strcmp(arg, "split")) {
+                        flightplan_mode = FlightplanMode::Split;
+                     } else if (!strcmp(arg, "annotate")) {
+                        flightplan_mode = FlightplanMode::Annotate;
+                     } else if (!strcmp(arg, "analyse")) {
+                        flightplan_mode = FlightplanMode::Analyse;
+                     } else {
+                        ::error("Unrecognised Flightplan mode %1%", arg);
+                        return false;
+                     }
+                     return true; },
+                    "Flightplan mode.");
+    registerOption("--flightplan_runtime", "{Full|HL}",
+                    [this](const char* arg) {
+                     if (!strcmp(arg, "Full")) {
+                        flightplan_runtime = FlightplanRuntime::Full;
+			if (flightplan_max_handover_bytes < 0) {
+			  flightplan_max_handover_bytes = default_flightplan_max_handover_bytes;
+			}
+                     } else if (!strcmp(arg, "HL")) {
+                        flightplan_runtime = FlightplanRuntime::HL;
+                     } else {
+                        ::error("Unrecognised Flightplan runtime %1%", arg);
+                        return false;
+                     }
+                     return true; },
+                    "Flightplan runtime.");
+    registerOption("--flightplan_annotation_mode", "{eager_offload|inertial_offload|chain}",
+                    [this](const char* arg) {
+                     if (!strcmp(arg, "eager_offload")) {
+                        flightplan_annotation_mode = FlightplanAnnotationMode::EagerOffload;
+                     } else if (!strcmp(arg, "inertial_offload")) {
+                        flightplan_annotation_mode = FlightplanAnnotationMode::InertialOffload;
+                     } else if (!strcmp(arg, "chain")) {
+                        flightplan_annotation_mode = FlightplanAnnotationMode::Chain;
+                     } else if (!strcmp(arg, "features")) {
+                        flightplan_annotation_mode = FlightplanAnnotationMode::Features;
+                     } else {
+                        ::error("Unrecognised Flightplan mode %1%", arg);
+                        return false;
+                     }
+                     return true; },
+                    "Flightplan annotation mode.");
+    registerOption("--flightplan_headered", nullptr,
+                    [this](const char*) { flightplan_headered = true; return true; },
+                    "Generate a Flightplan header");
+
+    registerOption("--flightplan_pinned_extern", "extern name",
+                    [this](const char* arg) {
+
+                    assert (flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::EagerOffload ||
+                            flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::InertialOffload ||
+                            flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::Chain);
+
+                       auto copy = strdup(arg);
+                       flightplan_exclusions.insert(copy);
+                     return true; },
+                    "Externs that must be called from FlightStart.");
+
+    registerOption("--flightplan_bunch_externs", "extern1,extern2[,extern3]",
+                   [this](const char* arg) {
+
+                       assert (flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::EagerOffload ||
+                               flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::InertialOffload ||
+                               flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::Chain);
+
+                       auto copy = strdup(arg);
+                       std::set<std::string> bunch;
+                       while (auto name = strsep(&copy, ",")) {
+                           bunch.insert(name);
+                       }
+                       flightplan_bunched.insert(bunch);
+                       return true;
+                   },
+                   "Externs that may be called while on the same segment\n");
+
+    registerOption("--flightplan_excluded_blocks", "name1[,name2]",
+                   [this](const char* arg) {
+                       assert(flightplan_focus_block == "");
+                       auto copy = strdup(arg);
+                       while (auto name = strsep(&copy, ",")) {
+                           flightplan_excluded_blocks.insert(name);
+                       }
+                       return true;
+                   },
+                   "Names of control blocks to exclude from analysis\n");
+    registerOption("--flightplan_focus_block", "name",
+                   [this](const char* arg) {
+                       assert(flightplan_excluded_blocks.size() == 0);
+                       assert(flightplan_focus_block == "");
+                       flightplan_focus_block = strdup(arg);
+                       return true;
+                   },
+                   "Name of the control blocks to focus the analysis on exclusively\n");
+    registerOption("--flightplan_offload_tables", "table1[,table2]",
+                   [this](const char* arg) {
+
+                       assert (flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::Features);
+
+                       auto copy = strdup(arg);
+                       while (auto name = strsep(&copy, ",")) {
+                           flightplan_table_offload.insert(name);
+                       }
+                       return true;
+                   },
+                   "Names of tables to be offloaded.\n");
+    registerOption("--flightplan_offload_headers", "type1[,type2]",
+                   [this](const char* arg) {
+
+                       assert (flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::Features);
+
+                       auto copy = strdup(arg);
+                       while (auto name = strsep(&copy, ",")) {
+                           flightplan_header_offload.insert(name);
+                       }
+                       return true;
+                   },
+                   "Header types to be offloaded.\n");
+    registerOption("--flightplan_offload_cflow", nullptr,
+                    [this](const char*) { flightplan_offload_cflow = true; return true; },
+                    "Use the offload control-flow pattern");
+    registerOption("--flightplan_emit_JSON", "filename",
+                    [this](const char* arg) {
+		       flightplan_emit_JSON = strdup(arg);
+                     return true; },
+                    "Emit JSON output describing configuration and analysis results.");
+    registerOption("--flightplan_allow_cflow", nullptr,
+                    [this](const char*) { flightplan_allow_cflow = true; return true; },
+                    "Allow return/exit statements in all cases, but emit warning");
+    registerOption("--flightplan_allow_metaIO", nullptr,
+                    [this](const char*) { flightplan_allow_metaIO = true; return true; },
+                    "Allow ingress/egress reading/writing in all cases, but emit warning");
 }
 
 void CompilerOptions::setInputFile() {
diff --git a/frontends/common/options.h b/frontends/common/options.h
index 124c29d..5ff3aff 100644
--- a/frontends/common/options.h
+++ b/frontends/common/options.h
@@ -1,5 +1,6 @@
 /*
 Copyright 2013-present Barefoot Networks, Inc.
+Copyright 2020 University of Pennsylvania
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -80,6 +81,53 @@ class CompilerOptions : public Util::Options {
     // Dump and undump the IR tree
     bool debugJson = false;
 
+    // Activate the Flightplan pass
+    bool flightplan = false;
+    bool flightplan_verbose = false;
+    // Flightplan outputs are written in this folder
+    cstring flightplanFolder = ".";
+    // Produce DOT output for each program fragment.
+    bool flightplan_DOT_output = false;
+
+    enum class FlightplanMode {Undefined, Analyse, Annotate, Split};
+    // What mode is Flightplan running in.
+    FlightplanMode flightplan_mode = FlightplanMode::Undefined;
+
+#if 1 || OLD_STUFF
+    enum class FlightplanAnnotationMode {Undefined, EagerOffload, InertialOffload, Chain, Features};
+    // If in annotation mode, what kind of annotation mode to use.
+    FlightplanAnnotationMode flightplan_annotation_mode = FlightplanAnnotationMode::Undefined;
+
+    bool flightplan_headered = false;
+
+    std::unordered_set<std::string> flightplan_exclusions;
+    std::set<std::set<std::string>> flightplan_bunched;
+
+    std::unordered_set<std::string> flightplan_table_offload;
+    std::unordered_set<std::string> flightplan_header_offload;
+
+    std::set<std::string> flightplan_excluded_blocks;
+    std::string flightplan_focus_block;
+#endif // OLD_STUFF
+
+    enum class FlightplanRuntime {Full, HL};
+    FlightplanRuntime flightplan_runtime = FlightplanRuntime::Full;
+    std::string flightplan_switch_md = "switch_metadata_t";
+    std::string flightplan_standard_md = "standard_metadata";
+    std::string flightplan_egress_var = "egress_spec";
+    std::string flightplan_ingress_var = "ingress_port";
+    int flightplan_max_handover_bytes = -1;
+    std::string flightplan_routing_segment = "";
+
+    bool flightplan_offload_cflow = false;
+    bool flightplan_allow_cflow = false;
+    bool flightplan_allow_metaIO = false;
+
+    std::string flightplan_emit_JSON;
+
+    std::vector<unsigned> mem_cells = {8,8,8,8,8,32,32}; // FIXME hardcoded const  
+
+
     // Write a P4Runtime control plane API description to the specified file.
     cstring p4RuntimeFile = nullptr;
 
diff --git a/frontends/common/resolveReferences/referenceMap.cpp b/frontends/common/resolveReferences/referenceMap.cpp
index 73c080e..8435fc5 100644
--- a/frontends/common/resolveReferences/referenceMap.cpp
+++ b/frontends/common/resolveReferences/referenceMap.cpp
@@ -1,5 +1,6 @@
 /*
 Copyright 2013-present Barefoot Networks, Inc.
+Copyright 2020 University of Pennsylvania
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -78,7 +79,7 @@ const IR::IDeclaration* ReferenceMap::getDeclaration(const IR::Path* path, bool
         LOG1("Looking up " << path << " found nothing");
 
     if (notNull)
-        BUG_CHECK(result != nullptr, "Cannot find declaration for %1%", path);
+      BUG_CHECK(result != nullptr, "Cannot find declaration for %1%", path);
     return result;
 }
 
diff --git a/frontends/p4/flightplan.cpp b/frontends/p4/flightplan.cpp
new file mode 100644
index 0000000..d1bc13c
--- /dev/null
+++ b/frontends/p4/flightplan.cpp
@@ -0,0 +1,164 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+Nik Sultana, UPenn, March 2020
+
+*/
+
+#include <assert.h>
+#include <iostream>
+#include <fstream>
+#include <chrono>
+#include <ctime>
+#include <math.h>
+
+#include "externInstance.h"
+
+#include "ir/ir.h"
+#include "ir/visitor.h"
+#include "lib/nullstream.h"
+#include "lib/path.h"
+#include "toP4/toP4.h"
+
+#include "flightplan.h"
+#include "flightplan_annotate.h"
+#include "flightplan_preanalysis.h"
+#include "flightplan_annotator.h"
+#include "flightplan_context_analysis.h"
+
+#define NOTSWITCH
+
+#include "flightplan_analyser.cpp"
+
+namespace P4 {
+
+Split* Split::curr_split = nullptr;
+std::set<Split*> Split::Splits;
+
+auto now = std::chrono::system_clock::now();
+std::time_t now_time = std::chrono::system_clock::to_time_t(now);
+const std::string FlightplanConfig::header_comment = "// Flightplan output\n// Now = " + std::string(std::ctime(&now_time));
+const std::string FlightplanConfig::landing_type_name = "Landing";
+const std::string FlightplanConfig::flyto_fn = "flyto";
+const std::set<std::string> FlightplanConfig::landing_API = {FlightplanConfig::flyto_fn};
+const std::string FlightplanConfig::landing_start = "FlightStart";
+//std::set<Split*> Flightplan::splits;
+unsigned FlightplanConfig::dot_id = 0;
+FStmt* FlightplanImpl::main = nullptr;
+const IR::P4Program* FlightplanConfig::p4_program = nullptr;
+IR::PathExpression* FlightplanConfig::flyto_expr = nullptr;
+
+ReferenceMap* FlightplanConfig::FP_refMap;
+TypeMap* FlightplanConfig::FP_typeMap;
+CompilerOptions FlightplanConfig::FP_options;
+
+std::string FlightplanConfig::adjusted_input_filename;
+
+void FlightplanImpl::end_apply(const IR::Node* node) {
+    if (options.flightplan_mode == CompilerOptions::FlightplanMode::Split) {
+        Split::mark_split(main);
+    }
+
+    if (node->is<IR::P4Program>()) {
+        this->hook_end();
+    }
+
+    Inspector::end_apply();
+}
+
+void FlightplanImpl::print_ctxt() const {
+    std::cout << "Ctxt (" << ctxt.size() << "): ";
+    for (auto elem : ctxt) {
+        std::cout << elem->toString() << " ";
+    }
+    std::cout << std::endl;
+}
+
+bool FlightplanImpl::preorder(const IR::P4Parser*) {
+    // We don't go into parsers
+    return false;
+}
+
+namespace FlightplanData {
+    bool seen_routing = false;
+    std::set<int> ingress_segments;
+    std::set<int> egress_segments;
+}
+
+Flightplan::Flightplan(ReferenceMap* refMap, TypeMap* typeMap, const CompilerOptions& options) {
+    CHECK_NULL(refMap);
+    CHECK_NULL(typeMap);
+    setName("Flightplan");
+
+    FlightplanConfig::FP_refMap = refMap;
+    FlightplanConfig::FP_typeMap = typeMap;
+    FlightplanConfig::FP_options = options;
+
+    FlightplanConfig::adjusted_input_filename = std::string(options.file);
+    std::replace( FlightplanConfig::adjusted_input_filename.begin(),
+     FlightplanConfig::adjusted_input_filename.end(), '/', '_');
+
+    if (options.flightplan) {
+        std::cout << "Starting Flightplan" << std::endl;
+
+        std::cout << "Input file: " << options.file << std::endl;
+        // Check our configuration.
+        switch (options.flightplan_mode) {
+            case CompilerOptions::FlightplanMode::Analyse:
+                std::cout << "Mode: Analyse" << std::endl;
+                break;
+            case CompilerOptions::FlightplanMode::Split:
+                std::cout << "Mode: Split" << std::endl;
+                if (options.flightplan_focus_block.empty()) {
+                    throw std::logic_error("Flightplan: 'split' mode requires the --flightplan_focus_block to be set to the main control block");
+		}
+                break;
+            case CompilerOptions::FlightplanMode::Undefined:
+                throw std::logic_error("Flightplan: must specify mode");
+            default:
+                throw std::logic_error("Flightplan: unsupported mode");
+        }
+
+        std::cout << "'Offload Cflow': ";
+        if (options.flightplan_offload_cflow) {
+            std::cout << "True" << std::endl;
+        } else {
+            std::cout << "False" << std::endl;
+        }
+
+        switch (options.flightplan_runtime) {
+            case CompilerOptions::FlightplanRuntime::Full:
+		{
+                std::cout << "Runtime: Full" << std::endl;
+                std::cout << "  Max. hand-over bytes: " << std::to_string(options.flightplan_max_handover_bytes) << std::endl;
+		assert(0 <= options.flightplan_max_handover_bytes);
+		unsigned mem_cells_bytes = 0;
+		for (unsigned bits : options.mem_cells) {
+		    assert(0 == remainder(bits, 8));
+		    mem_cells_bytes += bits/8;
+		}
+		if (mem_cells_bytes != (unsigned)options.flightplan_max_handover_bytes) {
+                    throw std::logic_error("Flightplan: mismatch between flightplan_max_handover_bytes==" + std::to_string(options.flightplan_max_handover_bytes) + " and mem_cell size==" + std::to_string(mem_cells_bytes));
+		}
+		}
+                break;
+	    case CompilerOptions::FlightplanRuntime::HL:
+                std::cout << "Runtime: HL" << std::endl;
+		assert(options.flightplan_offload_cflow);
+		assert(0 > options.flightplan_max_handover_bytes);
+		assert(!options.flightplan_routing_segment.empty());
+                std::cout << "  Routing segment: " << options.flightplan_routing_segment << std::endl;
+
+                std::cout << "  Ingress data: " << std::string(options.flightplan_standard_md) + "." + std::string(options.flightplan_ingress_var) << std::endl;
+                std::cout << "  Egress data: " << std::string(options.flightplan_standard_md) + "." + std::string(options.flightplan_egress_var) << std::endl;
+                break;
+            default:
+                throw std::logic_error("Flightplan: unsupported runtime");
+        }
+
+        auto fpi = new FlightplanImpl(refMap, typeMap, options);
+        passes.emplace_back(fpi);
+    }
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan.h b/frontends/p4/flightplan.h
new file mode 100644
index 0000000..d8c6c3c
--- /dev/null
+++ b/frontends/p4/flightplan.h
@@ -0,0 +1,320 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+
+NOTE must be executed after RemoveReturns, since we assume they've been removed.
+*/
+
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_H_
+
+#include <stdexcept>
+#include <string>
+#include <vector>
+#include <sstream>
+
+#include "../common/options.h"
+#include "ir/ir.h"
+#include "frontends/p4/typeChecking/typeChecker.h"
+#include "frontends/common/resolveReferences/resolveReferences.h"
+
+#include "toP4/toP4.h"
+
+namespace P4 {
+
+
+struct Dependency {
+    std::string name;
+    std::string desc;
+};
+
+struct SegDependency {
+    unsigned seg_id;
+    std::vector<std::vector<Dependency>> dependencies;
+};
+
+class Split;
+
+class Flightplan : public PassManager {
+ public:
+    Flightplan(ReferenceMap* refMap, TypeMap* typeMap, const CompilerOptions&);
+};
+
+namespace FlightplanConfig {
+    extern const std::string header_comment;
+    extern const std::string landing_type_name;
+    extern const std::string flyto_fn;
+    extern const std::set<std::string> landing_API;
+    extern const std::string landing_start;
+    extern unsigned dot_id;
+
+    extern ReferenceMap* FP_refMap;
+    extern TypeMap* FP_typeMap;
+    extern CompilerOptions FP_options;
+    extern const IR::P4Program* p4_program;
+    extern IR::PathExpression* flyto_expr;
+
+    extern std::string adjusted_input_filename;
+}
+
+namespace FlightplanData {
+    extern bool seen_routing;
+    extern std::set<int> ingress_segments;
+    extern std::set<int> egress_segments;
+}
+
+class FStmt;
+
+class Split final {
+    FStmt *beginning = nullptr;
+    FStmt *cleaved = nullptr;
+
+    friend class FlightplanImpl;
+
+    Split(std::string name, cstring output_file, FStmt *beginning) : output_file(output_file), beginning(beginning), name(name) {}
+
+    static Split* curr_split;
+
+ public:
+    cstring output_file = nullptr;
+    std::string name;
+    std::set<Split*> successor_splits;
+    static std::set<Split*> Splits;
+    static Split* new_split(std::string dest_path, std::string landing_name, FStmt *beginning) {
+        std::string result = dest_path + "/" + landing_name + ".p4";
+        curr_split = new Split(landing_name, result, beginning); // FIXME automatically deleted on deconstruction?
+        Splits.insert(curr_split);
+        return curr_split;
+    }
+    static Split* current_split(std::string dest_path, FStmt *current) {
+        if (curr_split == nullptr) {
+            curr_split = new_split(dest_path, FlightplanConfig::landing_start, current);
+        }
+        return curr_split;
+    }
+
+    const FStmt* getBeginning() const {
+        return beginning;
+    }
+
+    // FIXME for handover between splits, need to calculate context for latter split in advance, to be carried by the former.
+    static int mark_split(FStmt* main);
+    static void mark_split(FStmt* stmt, Split* split, std::set<const FStmt*> visited);
+    static void to_dot(std::ostream *ost, Split *split);
+    static FStmt* effect_split(Split *split);
+    static bool continue_split(Split *split, FStmt* prev, FStmt* stmt, std::set<FStmt*> &visited, bool pre_cloned, bool ascend);
+    static bool ascend_split(Split *split, FStmt* prev, FStmt* stmt, std::set<FStmt*> &visited);
+
+    // Show how splits connect to one another.
+    static void splits_dot(std::ostream *ost);
+
+    const FStmt* getCleaved() const {
+        return cleaved;
+    }
+};
+
+class DOT {
+ protected:
+    unsigned dot_id;
+    std::string* clust_id = nullptr;
+ public:
+    DOT(unsigned id) : dot_id(id) {}
+    virtual std::string toDOT() const = 0;
+    virtual std::string DOTid() const {
+        return "n" + std::to_string(dot_id);
+    }
+    virtual std::string* getClustID() const {
+        return clust_id;
+    }
+    virtual std::string entryDOTid() const {
+        return DOTid();
+    }
+};
+
+enum class Access {Read, Write, None};
+std::string access_to_string (Access a);
+enum class CodeContext {ControlBlock, Function, Action};
+
+class FlightplanImpl : public Inspector {
+    ReferenceMap*   refMap;
+    TypeMap*        typeMap;
+    const CompilerOptions options;
+
+    static FStmt* main;
+
+    const IR::P4Program* original_prog = nullptr;
+    std::set<const IR::PathExpression*> ctxt;
+
+    // FIXME there's redundancy here
+    IR::ID control_ID;
+    const IR::P4Control* control = nullptr;
+    std::vector<const IR::IDeclaration*> control_decls;
+
+    std::vector<const IR::IDeclaration*> control_sequence;
+    std::set<const IR::IDeclaration*> control_set;
+    std::map<const IR::IDeclaration*,std::set<const IR::IDeclaration*>> control_tables;
+
+    const unsigned initial_segment_id = 0;
+    const std::string initial_segment_location = "(start)";
+
+    unsigned next_segment_id = 0;
+    std::set<unsigned> current_segments;
+    std::set<unsigned> FlightStart_Segments;
+    std::list<CodeContext> current_context;
+    std::map<unsigned,std::string> segments;
+    std::vector<std::pair<std::pair<unsigned,unsigned>, const IR::Expression*> > hand_overs;
+    std::vector<SegDependency> dependencies; // We use this to generate abstract program.
+    std::map<std::string,std::set<std::pair<unsigned,std::string>>> segment_info;
+    std::map<unsigned,std::set<unsigned>> hand_overs_fw;
+    std::map<unsigned,std::set<unsigned>> hand_overs_bk;
+
+    std::map<unsigned,std::set<const IR::Expression*>> agg_handed_over_var;
+
+    void compute_chains (std::set<std::vector<unsigned>> &chainset);
+
+    template<typename Dep>
+    using deps_store_type = std::set<std::vector<Dep>*>;
+
+    template<typename Dep>
+    using deps_type = std::map<unsigned,deps_store_type<Dep>>;
+
+    template<typename Dep>
+    static deps_store_type<Dep> clone_deps_store(
+              unsigned seg,
+              deps_type<Dep> chains);
+
+    using mem_deps_type = std::pair<Access,const IR::Expression*>;
+    deps_type<mem_deps_type> mem_dependencies_active;
+    deps_type<mem_deps_type> mem_dependencies_completed;
+    deps_type<Dependency> res_dependencies_active;
+    deps_type<Dependency> res_dependencies_completed;
+
+    void deactivate_chains();
+    void activate_chain(unsigned segment_id);
+    template<typename Dep>
+    static deps_type<Dep> union_chains(
+              deps_type<Dep> chains1,
+              deps_type<Dep> chains2);
+    template<typename Dep>
+    static void product_chains(
+              deps_type<Dep> chains,
+              deps_store_type<Dep> extensions);
+    void analyse_mem_deps (unsigned seg_id);
+    template<typename Dep>
+    static deps_type<Dep> branch_chains(deps_type<Dep> chains);
+    template<typename Dep>
+    static void print_chains(std::string prefix, deps_type<Dep> chains);
+    template<typename Dep>
+    static std::string chain_to_string(Dep dep);
+
+    std::map<unsigned,std::set<const IR::Expression*>> mem_reads;
+    std::map<unsigned,std::set<const IR::Expression*>> mem_writes;
+    void calculate_transitive_handover (unsigned seg_id);
+    struct handed_var_info {
+	unsigned width = 0; // in bits
+	std::set<unsigned> dependants; // may include the current segment
+    };
+    std::map<unsigned,std::map<std::string,handed_var_info>> handed_over_set; // For each seg_id we keep track of the set of variables it expects to receive, their width in bits, and the downstream dependent segments.
+    void require_transitive_handover (unsigned seg_id, std::string var_name, handed_var_info hvi, bool initial);
+
+    std::set<unsigned> terminal_segments; // set of segments at which the program terminates
+    bool egress_var_is_updated = false;
+
+    void control_flow_change(std::string position);
+
+    struct cell_segment {
+	unsigned cell_idx = 0;
+    };
+    struct single_allocation {
+        std::string name;
+        std::list<cell_segment> cell_segments;
+    };
+    std::map<unsigned,std::list<single_allocation>> cell_allocations;
+    void allocate_mem(unsigned seg_no);
+    void print_allocation(unsigned seg_no);
+
+    void split();
+
+    std::list<std::vector<std::string> > ignores;
+
+    unsigned int analyse_handover (unsigned seg_id);
+    std::string generate_json ();
+
+    Access default_access = Access::None;
+
+    bool am_within_switch = false;
+
+ public:
+    void note_mem_dependency(Access access, const IR::Expression* v);
+
+    explicit FlightplanImpl(ReferenceMap* refMap, TypeMap* typeMap, const CompilerOptions& options) :
+            refMap(refMap), typeMap(typeMap), options(options)
+    {
+        setName("FlightplanImpl");
+    }
+
+    void end_apply(const IR::Node*) override;
+
+    void hook_end();
+
+    bool preorder(const IR::PathExpression* expr) override;
+    bool preorder(const IR::P4Control* s) override;
+    bool preorder(const IR::P4Parser* s) override;
+    bool preorder(const IR::P4Program* p) override;
+
+    bool preorder(const IR::P4Action* c) override;
+    bool preorder(const IR::Function* function) override;
+    bool preorder(const IR::P4Table* c) override;
+
+    bool preorder(const IR::AssignmentStatement* s) override;
+    bool preorder(const IR::BlockStatement* s) override;
+    bool preorder(const IR::MethodCallStatement* s) override;
+    bool preorder(const IR::EmptyStatement* s) override;
+    bool preorder(const IR::ReturnStatement* s) override;
+    bool preorder(const IR::ExitStatement* s) override;
+    bool preorder(const IR::SwitchCase* s) override;
+    bool preorder(const IR::SwitchStatement* s) override;
+    bool preorder(const IR::IfStatement* s) override;
+
+    bool preorder(const IR::MethodCallExpression* e) override;
+
+    bool preorder(const IR::Slice* slice) override;
+    bool preorder(const IR::Cast* c) override;
+    bool preorder(const IR::Operation_Binary* b) override;
+    bool preorder(const IR::Operation_Unary* u) override;
+    bool preorder(const IR::ArrayIndex* a) override;
+    bool preorder(const IR::Mux* a) override;
+    bool preorder(const IR::ConstructorCallExpression* e) override;
+    bool preorder(const IR::Member* e) override;
+    bool preorder(const IR::SelectCase* e) override;
+    bool preorder(const IR::SelectExpression* e) override;
+    bool preorder(const IR::ListExpression* e) override;
+    bool preorder(const IR::StructInitializerExpression* e) override;
+
+    void print_ctxt() const;
+
+    static const FStmt* getMain() {
+        return main;
+    }
+};
+
+class FlightplanTransf : public Transform {
+    ReferenceMap*   refMap;
+    TypeMap*        typeMap;
+    const CompilerOptions options;
+ public:
+    explicit FlightplanTransf(ReferenceMap* refMap, TypeMap* typeMap, const CompilerOptions& options) :
+            refMap(refMap), typeMap(typeMap), options(options)
+    {
+        setName("FlightplanTransf");
+    }
+
+    const IR::Node* preorder(IR::Type_Declaration* t) override;
+    const IR::Node* preorder(IR::Method* t) override;
+    const IR::Node* preorder(IR::MethodCallStatement* mcs) override;
+};
+
+}  // namespace P4
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_H_ */
diff --git a/frontends/p4/flightplan_analyser.cpp b/frontends/p4/flightplan_analyser.cpp
new file mode 100644
index 0000000..e41e512
--- /dev/null
+++ b/frontends/p4/flightplan_analyser.cpp
@@ -0,0 +1,1791 @@
+/*
+Flightplan
+Nik Sultana, UPenn, March 2020
+*/
+
+#define TABLE_STR "Table"
+#define EXTERN_STR "Extern"
+
+#include <assert.h>
+#include <iostream>
+#include <fstream>
+#include <chrono>
+#include <ctime>
+#include <math.h>
+
+#include "externInstance.h"
+
+#include "ir/ir.h"
+#include "ir/visitor.h"
+#include "lib/nullstream.h"
+#include "lib/path.h"
+#include "toP4/toP4.h"
+
+#include "flightplan.h"
+#include "flightplan_annotate.h"
+#include "flightplan_preanalysis.h"
+#include "flightplan_annotator.h"
+#include "flightplan_context_analysis.h"
+
+namespace P4 {
+
+std::string runtime_to_string (CompilerOptions::FlightplanRuntime fpr) {
+    switch (fpr) {
+        case CompilerOptions::FlightplanRuntime::Full:
+            return "Full";
+        case CompilerOptions::FlightplanRuntime::HL:
+            return "HL";
+    }
+    throw std::logic_error("Flightplan: Invalid FlightplanRuntime value");
+}
+
+static const IR::P4Table* attempt_resolve_table(const IR::Expression* expression, ReferenceMap* refMap, TypeMap* typeMap) {
+    auto mce = expression->to<IR::MethodCallExpression>();
+    auto mi = P4::MethodInstance::resolve(mce, refMap, typeMap);
+    if (!mi->isApply()) {
+        return nullptr;
+    }
+    auto am = mi->to<P4::ApplyMethod>();
+    if (!am->object->is<IR::P4Table>()) {
+        return nullptr;
+    }
+    return am->object->to<IR::P4Table>();
+}
+
+static const IR::P4Action* attempt_resolve_action_body(const IR::Expression* expression, ReferenceMap* refMap, TypeMap* typeMap) {
+    auto mce = expression->to<IR::MethodCallExpression>();
+    auto mi = P4::MethodInstance::resolve(mce, refMap, typeMap);
+
+    if (auto ac = mi->to<ActionCall>()) {
+        return ac->action;
+    }
+
+    return nullptr;
+}
+
+std::string access_to_string (Access a) {
+  std::string result;
+  switch (a) {
+  case Access::Read:
+    result = "READ";
+    break;
+  case Access::Write:
+    result = "WRITE";
+    break;
+  case Access::None:
+    result = "NONE";
+    break;
+  default:
+    throw std::logic_error("Flightplan: Invalid Access value");
+  }
+  return result;
+}
+
+void FlightplanImpl::note_mem_dependency(Access access, const IR::Expression* v) {
+    if (Access::None == access) {
+        throw std::logic_error("Flightplan: note_mem_dependency: None for " + v->toString() + " at " + v->getSourceInfo().toPositionString());
+    }
+
+    if (Access::Write == access &&
+        v->toString() == std::string(options.flightplan_standard_md) + "." + std::string(options.flightplan_egress_var))
+    {
+        egress_var_is_updated = true;
+    }
+
+    bool found = false;
+    for (std::vector<std::string> frame : ignores) {
+        for (const std::string entry : frame) {
+	    if (entry == v->toString()) {
+		    found = true;
+		    break;
+	    }
+        }
+	if (found) break;
+    }
+    if (!found) {
+	for (unsigned current_segment_id : current_segments) {
+	    for (std::vector<std::pair<Access,const IR::Expression*>> *chain : mem_dependencies_active[current_segment_id]) {
+                chain->push_back(std::pair<Access,const IR::Expression*>(access, v));
+	    }
+
+            if ((v->toString() == std::string(options.flightplan_standard_md) + "." + std::string(options.flightplan_egress_var) ||
+	    		v->toString() == std::string(options.flightplan_standard_md) + "." + std::string(options.flightplan_ingress_var)) &&
+	    		options.flightplan_runtime == CompilerOptions::FlightplanRuntime::HL &&
+                        // Confirm that non-routing segments don't read/write to port metadata
+	    		options.flightplan_routing_segment != segments[current_segment_id]) {
+                 if (options.flightplan_allow_metaIO) {
+                     std::cerr << ("Flightplan WARNING: Encountered port-metadata "+ access_to_string(access) + " on " + v->toString() + " in segment " + segments[current_segment_id] + " (at " + v->getSourceInfo().toPositionString() + "), which is not the routing segment (" + options.flightplan_routing_segment + ").") << std::endl;
+		 } else {
+                     throw std::logic_error("Flightplan: Using this runtime, port metadata must be accessed in routing segment (" + options.flightplan_routing_segment + "). Attempted "+ access_to_string(access) + " on " + v->toString() + " in segment " + segments[current_segment_id] + " (at " + v->getSourceInfo().toPositionString() + ")");
+		 }
+	    }
+	}
+    }
+}
+
+bool FlightplanImpl::preorder(const IR::P4Action* c) {
+    if (options.flightplan_verbose) {
+         std::cout << "P4Action: " << c->getName() << std::endl;
+    }
+    // Add parameters to "ignore" list wrt variables
+    std::vector<std::string> entry;
+    for (auto param : *c->getParameters()) {
+	entry.push_back(std::string(param->getName().toString()));
+    }
+    ignores.push_front(entry);
+    current_context.push_front(CodeContext::Action);
+    visit(c->body);
+    current_context.pop_front();
+    ignores.pop_front();
+    return false;
+}
+bool FlightplanImpl::preorder(const IR::Function* function) {
+    if (options.flightplan_verbose) {
+        std::cout << "Function: " << function->getName() << std::endl;
+    }
+    // NOTE we go through parameters and update mem_dependencies wrt "in"/"out"/"inout" at the call site, where we can access the actual parameters, not at this point.
+    // Add parameters to "ignore" list wrt variables
+    std::vector<std::string> entry;
+    for (auto param : *function->getParameters()) {
+	entry.push_back(std::string(param->getName().toString()));
+    }
+    ignores.push_front(entry);
+    current_context.push_front(CodeContext::Function);
+    visit(function->body);
+    current_context.pop_front();
+    ignores.pop_front();
+    return false;
+}
+bool FlightplanImpl::preorder(const IR::P4Table* c) {
+    if (options.flightplan_verbose) {
+        std::cout << "P4Table: " << c->getName() << std::endl;
+    }
+
+    for (unsigned current_segment_id : current_segments) {
+        for (std::vector<Dependency> *chain : res_dependencies_active[current_segment_id]) {
+            Dependency dep;
+            dep.name = std::string(c->getName().toString());
+            dep.desc = TABLE_STR;
+            chain->push_back(dep);
+        }
+    }
+
+    // FIXME include c->getDefaultAction
+    const IR::ActionList* actions = c->getActionList();
+    const IR::Key* key = c->getKey();
+    for (const IR::KeyElement* ke : key->keyElements) {
+        note_mem_dependency(Access::Read, ke->expression);
+    }
+
+    for (const IR::ActionListElement* action : actions->actionList) {
+        const IR::P4Action* p4action = attempt_resolve_action_body(action->expression, refMap, typeMap);
+        visit(p4action);
+    }
+    return false;
+}
+
+bool FlightplanImpl::preorder(const IR::Slice* slice) {
+	visit(slice->e0);
+	visit(slice->e1);
+	visit(slice->e2);
+	return false;
+}
+bool FlightplanImpl::preorder(const IR::Cast* c) {
+	visit(c->expr);
+	return false;
+}
+bool FlightplanImpl::preorder(const IR::Operation_Binary* b) {
+	Access old_da = default_access;
+	default_access = Access::Read;
+	visit(b->left);
+	visit(b->right);
+	old_da = default_access;
+	return false;
+}
+bool FlightplanImpl::preorder(const IR::Operation_Unary* u) {
+	Access old_da = default_access;
+	default_access = Access::Read;
+	visit(u->expr);
+	old_da = default_access;
+	return false;
+}
+bool FlightplanImpl::preorder(const IR::ArrayIndex* a) {
+	visit(a->left);
+	visit(a->right);
+	return false;
+}
+bool FlightplanImpl::preorder(const IR::Mux* a) {
+	visit(a->e0);
+	visit(a->e1);
+	visit(a->e2);
+	return false;
+}
+bool FlightplanImpl::preorder(const IR::ConstructorCallExpression* e) {
+  throw std::logic_error("Flightplan: Unsupported");
+}
+bool FlightplanImpl::preorder(const IR::Member* e) {
+        bool is_hit_statement = false;
+        const IR::MethodCallExpression* table_expr = nullptr;
+        if (e->expr->is<IR::MethodCallExpression>()) {
+            const IR::MethodCallExpression* sub_e = &e->expr->as<IR::MethodCallExpression>();
+
+            if (sub_e->method->is<IR::Member>()) {
+                const IR::Member* sub_sub_e = &sub_e->method->as<IR::Member>();
+	        table_expr = sub_e;
+                is_hit_statement = std::string("hit") == std::string(e->member.toString()) && std::string("apply") == std::string(sub_sub_e->member.toString());
+
+            }
+        }
+
+        if (!is_hit_statement) {
+            note_mem_dependency(default_access, e);
+        } else {
+            const IR::P4Table* tbl = attempt_resolve_table(table_expr, refMap, typeMap);
+            this->preorder(tbl);
+	}
+	return false;
+}
+bool FlightplanImpl::preorder(const IR::SelectCase* e) {
+	return false;
+}
+bool FlightplanImpl::preorder(const IR::SelectExpression* e) {
+	visit(e->select);
+	return false;
+}
+bool FlightplanImpl::preorder(const IR::ListExpression* e) {
+	for (auto e0 : e->components) {
+	    visit(e0);
+	}
+	return false;
+}
+bool FlightplanImpl::preorder(const IR::StructInitializerExpression* e) {
+	for (auto e0 : e->components) {
+	    visit(e0);
+	}
+	return false;
+}
+
+bool FlightplanImpl::preorder(const IR::AssignmentStatement* s) {
+    // update read/write sequence properly
+    // also remove constants wrt mem_dependencies
+    // remove Landing values wrt mem_dependencies
+    Access old_da = default_access;
+    default_access = Access::Write;
+    visit(s->left);
+    default_access = Access::Read;
+    visit(s->right);
+    default_access = old_da;
+    return false;
+}
+bool FlightplanImpl::preorder(const IR::BlockStatement* s) {
+    for (auto sub : s->components) {
+        visit(sub);
+    }
+    return false;
+}
+bool FlightplanImpl::preorder(const IR::MethodCallStatement* s) {
+    visit(s->methodCall);
+    return false;
+}
+bool FlightplanImpl::preorder(const IR::EmptyStatement*) {
+    return false;
+}
+
+void FlightplanImpl::activate_chain(unsigned segment_id) {
+    assert(mem_dependencies_active.find(segment_id) == mem_dependencies_active.end());
+    mem_dependencies_active[segment_id] = std::set<std::vector<std::pair<Access,const IR::Expression*>>*>();
+    mem_dependencies_active[segment_id].insert(new std::vector<std::pair<Access,const IR::Expression*>>());
+
+    assert(res_dependencies_active.find(segment_id) == res_dependencies_active.end());
+    res_dependencies_active[segment_id] = std::set<std::vector<Dependency>*>();
+    res_dependencies_active[segment_id].insert(new std::vector<Dependency>());
+}
+void FlightplanImpl::deactivate_chains() {
+    mem_dependencies_completed = FlightplanImpl::union_chains<FlightplanImpl::mem_deps_type>(mem_dependencies_active, mem_dependencies_completed);
+    mem_dependencies_active.clear();
+
+    res_dependencies_completed = FlightplanImpl::union_chains<Dependency>(res_dependencies_active, res_dependencies_completed);
+    res_dependencies_active.clear();
+}
+template<typename Dep>
+FlightplanImpl::deps_type<Dep> FlightplanImpl::branch_chains(FlightplanImpl::deps_type<Dep> chains) {
+    FlightplanImpl::deps_type<Dep> result;
+    for (std::pair<unsigned,std::set<std::vector<Dep>*>> chain_set : chains) {
+        result[chain_set.first] = std::set<std::vector<Dep>*>();
+        for (std::vector<Dep>* chain : chain_set.second) {
+            std::vector<Dep>* chain_copy = new std::vector<Dep>();
+            *chain_copy = *chain;
+            result[chain_set.first].insert(chain_copy);
+        }
+    }
+    return result;
+}
+
+// NOTE order of the parameters to union() matters, despite the operation seeming to be commutative
+template<typename Dep>
+FlightplanImpl::deps_type<Dep> FlightplanImpl::union_chains(
+		FlightplanImpl::deps_type<Dep> chains1,
+		FlightplanImpl::deps_type<Dep> chains2) {
+    for (std::pair<unsigned,std::set<std::vector<Dep>*>> chain : chains1) {
+        if (chains2.find(chain.first) == chains2.end()) {
+            chains2[chain.first] = chain.second;
+	} else {
+            for (auto instance : chain.second) {
+                chains2[chain.first].insert(instance);
+            }
+	}
+    }
+    return chains2;
+}
+
+template<typename Dep>
+void FlightplanImpl::product_chains(
+		FlightplanImpl::deps_type<Dep> chains,
+		FlightplanImpl::deps_store_type<Dep> extensions) {
+    for (std::pair<unsigned,std::set<std::vector<Dep>*>> chain_set : chains) {
+        for (std::vector<Dep>* ext : extensions) {
+            for (std::vector<Dep>* chain : chain_set.second) {
+                chain->insert(chain->end(), ext->begin(), ext->end());
+	    }
+	}
+    }
+}
+
+// Handle 'exit' or 'return'
+void FlightplanImpl::control_flow_change(std::string position) {
+        for (unsigned current_segment_id : current_segments) {
+            if (segments[current_segment_id] != FlightplanConfig::landing_start) {
+		if (options.flightplan_allow_cflow) {
+			std::cerr << ("Flightplan WARNING: On Full runtime, 'return' is being called in " + segments[current_segment_id] + ", which isn not the routing segment (" + options.flightplan_routing_segment + ") -- see " + position) << std::endl;
+		} else {
+                    throw std::logic_error("Flightplan: On Full runtime, 'return' called in " + segments[current_segment_id] + " but it is only supported in " + FlightplanConfig::landing_start + " -- see " + position);
+		}
+            }
+        }
+}
+bool FlightplanImpl::preorder(const IR::ReturnStatement* s) {
+    if (current_context.front() == CodeContext::ControlBlock) {
+        if (options.flightplan_runtime == CompilerOptions::FlightplanRuntime::HL) {
+            for (unsigned current_segment_id : current_segments) {
+	        if (options.flightplan_routing_segment != segments[current_segment_id]) {
+	    	    std::string position = std::string(s->getSourceInfo().toPositionString());
+		    if (options.flightplan_allow_cflow) {
+		    	std::cerr << ("Flightplan WARNING: On HL runtime, 'return' is being called in " + segments[current_segment_id] + ", which isn not the routing segment (" + options.flightplan_routing_segment + ") -- see " + position) << std::endl;
+		    } else {
+                    throw std::logic_error("Flightplan: On HL runtime, 'return' may only be called in routing segment (" + options.flightplan_routing_segment + ") but it is being called in " + segments[current_segment_id] + " -- see " + position);
+		    }
+	        }
+            }
+        } else if (options.flightplan_runtime == CompilerOptions::FlightplanRuntime::Full) {
+            control_flow_change(std::string(s->getSourceInfo().toPositionString()));
+        } else {
+            throw std::logic_error("Flightplan: Uncertain applicability of runtime for 'return' at " + s->getSourceInfo().toPositionString());
+	}
+    }
+
+    if (s->expression != nullptr) {
+        visit(s->expression);
+    }
+
+    deactivate_chains();
+    return false;
+}
+bool FlightplanImpl::preorder(const IR::ExitStatement* s) {
+    if (options.flightplan_runtime == CompilerOptions::FlightplanRuntime::HL) {
+        for (unsigned current_segment_id : current_segments) {
+	    if (options.flightplan_routing_segment != segments[current_segment_id]) {
+		std::string position = std::string(s->getSourceInfo().toPositionString());
+		if (options.flightplan_allow_cflow) {
+                    std::cerr << ("Flightplan WARNING: On HL runtime, 'exit' is being called in " + segments[current_segment_id] + ", which isn not the routing segment (" + options.flightplan_routing_segment + ") -- see " + position) << std::endl;
+		} else {
+                    throw std::logic_error("Flightplan: On HL runtime, 'exit' may only be called in routing segment (" + options.flightplan_routing_segment + ") but it is being called in " + segments[current_segment_id] + " -- see " + position);
+		}
+	    }
+        }
+    } else if (options.flightplan_runtime == CompilerOptions::FlightplanRuntime::Full) {
+    } else {
+        throw std::logic_error("Flightplan: Uncertain applicability of runtime for 'exit' at " + s->getSourceInfo().toPositionString());
+    }
+
+    deactivate_chains();
+    return false;
+}
+bool FlightplanImpl::preorder(const IR::SwitchCase* s) {
+    visit(s->statement);
+    return false;
+}
+bool FlightplanImpl::preorder(const IR::SwitchStatement* s) {
+    visit(s->expression);
+    this->am_within_switch = true;
+    for (auto sub : s->cases) {
+        visit(sub);
+    }
+    this->am_within_switch = false;
+    return false;
+}
+
+template<>
+std::string FlightplanImpl::chain_to_string<FlightplanImpl::mem_deps_type>(mem_deps_type dep) {
+    return access_to_string(dep.first) + " " + std::string(dep.second->toString());
+}
+
+template<typename Dep>
+void FlightplanImpl::print_chains(std::string prefix, FlightplanImpl::deps_type<Dep> chains) {
+    std::cout << "print_chains " << prefix << " (" << std::to_string(chains.size()) << "):" << std::endl;
+    for (std::pair<unsigned,std::set<std::vector<Dep>*>> chain_set : chains) {
+        std::cout << "  seg=" << std::to_string(chain_set.first) << " (" << std::to_string(chain_set.second.size()) << "):" << std::endl;
+        for (std::vector<Dep>* chain : chain_set.second) {
+            std::cout << "    chain (" << std::to_string(chain->size()) << "):" << std::endl;
+            for (Dep dep : *chain) {
+                std::cout << "      " << chain_to_string<Dep>(dep) << std::endl;
+	    }
+        }
+    }
+}
+
+bool FlightplanImpl::preorder(const IR::IfStatement* s) {
+    visit(s->condition);
+
+    std::set<unsigned> seg_snapshot0 = current_segments;
+    auto mem_snapshot0 = FlightplanImpl::branch_chains<FlightplanImpl::mem_deps_type>(mem_dependencies_active);
+    auto res_snapshot0 = FlightplanImpl::branch_chains<Dependency>(res_dependencies_active);
+
+    assert(s->ifTrue != nullptr);
+    visit(s->ifTrue);
+
+    if (s->ifFalse != nullptr) {
+        std::set<unsigned> seg_snapshot1 = current_segments;
+        auto mem_snapshot1 = FlightplanImpl::branch_chains<FlightplanImpl::mem_deps_type>(mem_dependencies_active);
+        auto res_snapshot1 = FlightplanImpl::branch_chains<Dependency>(res_dependencies_active);
+
+        current_segments = seg_snapshot0;
+	mem_dependencies_active = mem_snapshot0;
+	res_dependencies_active = res_snapshot0;
+
+        assert(s->ifFalse != nullptr);
+        visit(s->ifFalse);
+
+        seg_snapshot0 = seg_snapshot1;
+        mem_snapshot0 = mem_snapshot1;
+        res_snapshot0 = res_snapshot1;
+    }
+
+    for (auto seg : seg_snapshot0) {
+        current_segments.insert(seg);
+    }
+    mem_dependencies_active = FlightplanImpl::union_chains<FlightplanImpl::mem_deps_type>(mem_dependencies_active, mem_snapshot0);
+    res_dependencies_active = FlightplanImpl::union_chains<Dependency>(res_dependencies_active, res_snapshot0);
+
+    return false;
+}
+
+template<typename Dep>
+FlightplanImpl::deps_store_type<Dep> FlightplanImpl::clone_deps_store(
+  unsigned seg,
+  FlightplanImpl::deps_type<Dep> chains) {
+    FlightplanImpl::deps_store_type<Dep> result;
+    for (std::vector<Dep>* chain : chains[seg]) {
+        std::vector<Dep>* chain_copy = new std::vector<Dep>();
+	*chain_copy = *chain;
+	result.insert(chain_copy);
+    }
+    return result;
+}
+
+bool FlightplanImpl::preorder(const IR::MethodCallExpression* e) {
+    const IR::ParameterList * param_list = nullptr;
+    bool skip_visit = false;
+    if (options.flightplan_verbose) {
+        std::cout << "CALL " << e->toString() << std::endl;
+    }
+    const IR::P4Table* tbl = attempt_resolve_table(e, refMap, typeMap);
+    if (tbl != nullptr) {
+        if (options.flightplan_verbose) {
+            std::cout << "  is Table" << std::endl;
+	}
+        visit(tbl->getNode());
+        if (options.flightplan_verbose) {
+            std::cout << "  back from \"is Table\"" << std::endl;
+	}
+    } else {
+        MethodInstance* mi = MethodInstance::resolve(e, refMap, typeMap);
+        if (mi->isApply()) {
+            if (options.flightplan_verbose) {
+                std::cout << "  is Apply" << std::endl;
+	    }
+	} else if (mi->is<P4::BuiltInMethod>()) {
+            const P4::BuiltInMethod* bim = (P4::BuiltInMethod*)mi;
+            if (options.flightplan_verbose) {
+	        std::cout << "BIM: " << bim->name << std::endl;
+	    }
+	} else if (mi->is<P4::ExternMethod>()) {
+            const P4::ExternMethod* narrowed_mi = (P4::ExternMethod*)mi;
+            if (options.flightplan_verbose) {
+	        std::cout << "EXTERN-METH: " << narrowed_mi->method->name <<
+	                     " from " << narrowed_mi->method->getSourceInfo() << std::endl;
+	    }
+	    param_list = narrowed_mi->getOriginalParameters();
+	} else if (mi->is<P4::ExternFunction>()) {
+            const P4::ExternFunction* narrowed_mi = (P4::ExternFunction*)mi;
+
+	    std::string re_ty_s;
+            if (narrowed_mi->method->type->returnType->is<IR::Type_Name>()) {
+              re_ty_s = narrowed_mi->method->type->returnType->as<IR::Type_Name>().toString();
+	    }
+
+            if (re_ty_s == FlightplanConfig::landing_type_name) {
+	        skip_visit = true;
+	    } else {
+                if (options.flightplan_verbose) {
+	            std::cout << "EXTERN-FUNC: " << narrowed_mi->method->name <<
+	                         " from " << narrowed_mi->method->getSourceInfo() << std::endl;
+	            std::cout << "EXTERN-FUNC's TYPE: " << narrowed_mi->method->type << std::endl;
+		}
+		param_list = narrowed_mi->getOriginalParameters();
+
+                if (options.flightplan_verbose) {
+		    std::cout << "param_list is ";
+		    if (nullptr == param_list) std::cout << "NULL" << std::endl;
+		    else std::cout << "not NULL" << std::endl;
+		}
+
+	        if (std::string(narrowed_mi->method->name.toString()) != FlightplanConfig::flyto_fn) {
+                    for (unsigned current_segment_id : current_segments) {
+                        for (std::vector<Dependency> *chain : res_dependencies_active[current_segment_id]) {
+                            Dependency dep;
+                            dep.name = std::string(narrowed_mi->method->name.toString());
+                            dep.desc = EXTERN_STR;
+                            chain->push_back(dep);
+                        }
+		    }
+	        } else {
+	            skip_visit = true;
+                    auto stmt = std::string(e->srcInfo.toBriefSourceFragment());
+                    auto segname = stmt.substr(FlightplanConfig::flyto_fn.length() + 1, stmt.length() - (FlightplanConfig::flyto_fn.length() + 4));
+                    if (options.flightplan_verbose) {
+	                std::cout << "FLYTO " << segname << std::endl;
+		    }
+
+	            if (this->am_within_switch) {
+                        throw std::logic_error("Flightplan: " + FlightplanConfig::flyto_fn + "() not supported in switch statement. " + e->getSourceInfo().toPositionString());
+	            }
+
+                    if (current_context.front() == CodeContext::Action ||
+                        current_context.front() == CodeContext::Function) {
+                        throw std::logic_error("Flightplan: Cannot flyto() in Action or Function");
+		    }
+
+                    if (segment_info.find(segname) == segment_info.end()) {
+                        segment_info[segname] = std::set<std::pair<unsigned,std::string>>();
+                    }
+                    bool found = false;
+		    std::set<unsigned> next_segments;
+		    for (auto pair : segment_info[segname]) {
+                        for (unsigned current_segment_id : current_segments) {
+                            if (std::string(e->getSourceInfo().toPositionString()) == pair.second) {
+			    	    found = true;
+                                    auto seg_handover = std::pair<unsigned,unsigned>(current_segment_id, pair.first);
+                                    auto handover_entry = std::pair<std::pair<unsigned,unsigned>, const IR::Expression*>(seg_handover, e);
+                                    hand_overs.push_back(handover_entry);
+		                    next_segments.insert(pair.first);
+
+                                    // Check against having flyto to same segment -- i.e., flyto(FlightStart) -> flyto(FlightStart)
+                                    if (segments[current_segment_id] == segments[pair.first]) {
+					throw std::logic_error("Flightplan: cannot " + FlightplanConfig::flyto_fn + "() from a segment to itself -- '" + segments[current_segment_id] + "' in " + e->getSourceInfo().toPositionString());
+				    }
+			    }
+			}
+		    }
+
+                    assert(next_segments.size() <= 1);
+                    // All segments must be uniquely-named, except for FlightStart since we can always go back to FlightStart.
+		    if (segment_info[segname].size() > 0 && !found && segname != FlightplanConfig::landing_start) {
+                        throw std::logic_error("Flightplan: Cannot have duplicate " + FlightplanConfig::flyto_fn + "() arguments except for " + FlightplanConfig::landing_start + ": " + segname);
+		    }
+		    if (!found) {
+                        assert(next_segments.size() == 0);
+		        unsigned current_segment_id = next_segment_id;
+                        next_segment_id++;
+                        segments[current_segment_id] = segname;
+                        next_segments.insert(current_segment_id);
+
+                        for (unsigned previous_segment_id : current_segments) {
+                            auto seg_handover = std::pair<unsigned,unsigned>(previous_segment_id, current_segment_id);
+                            auto handover_entry = std::pair<std::pair<unsigned,unsigned>, const IR::Expression*>(seg_handover, e);
+                            hand_overs.push_back(handover_entry);
+                            segment_info[segname].insert(std::pair<unsigned,std::string>(current_segment_id, std::string(e->getSourceInfo().toPositionString())));
+
+                            // Check against having flyto to same segment -- i.e., flyto(FlightStart) -> flyto(FlightStart)
+                            if (segments[current_segment_id] == segments[previous_segment_id]) {
+				throw std::logic_error("Flightplan: cannot " + FlightplanConfig::flyto_fn + "() from a segment to itself -- '" + segments[current_segment_id] + "' in " + e->getSourceInfo().toPositionString());
+			    }
+			}
+		    }
+
+                    deactivate_chains();
+                    for (unsigned segment_id : next_segments) {
+                        activate_chain(segment_id);
+		    }
+
+		    current_segments = next_segments;
+
+                    for (unsigned current_segment_id : current_segments) {
+	                if (options.flightplan_runtime == CompilerOptions::FlightplanRuntime::HL &&
+		                options.flightplan_routing_segment == segments[current_segment_id]) {
+		            FlightplanData::seen_routing = true;
+		            assert(current_segments.size() == 1);
+		        } else if (options.flightplan_runtime == CompilerOptions::FlightplanRuntime::HL &&
+		                options.flightplan_routing_segment != segments[current_segment_id]) {
+		            if (!FlightplanData::seen_routing) {
+                                FlightplanData::ingress_segments.insert(current_segment_id);
+		            } else {
+                                FlightplanData::egress_segments.insert(current_segment_id);
+		            }
+		        }
+		    }
+	        }
+	    }
+	} else {
+            const IR::P4Action* act = attempt_resolve_action_body(e, refMap, typeMap);
+	    if (act != nullptr) {
+                static deps_store_type<mem_deps_type> *mem_DST = nullptr;
+                static deps_store_type<Dependency> *res_DST = nullptr;
+                std::set<unsigned> current_segments_cp;
+                deps_type<mem_deps_type> mem_dependencies_active_cp;
+                deps_type<Dependency> res_dependencies_active_cp;
+
+		const unsigned arbitrary_const = 0;
+                if (nullptr == mem_DST && nullptr == res_DST) {
+                    current_segments_cp = current_segments;
+                    mem_dependencies_active_cp = mem_dependencies_active;
+                    res_dependencies_active_cp = res_dependencies_active;
+
+                    current_segments = std::set<unsigned>{arbitrary_const};
+                    mem_dependencies_active[arbitrary_const] = std::set<std::vector<mem_deps_type>*>();
+                    mem_dependencies_active[arbitrary_const].insert(new std::vector<mem_deps_type>());
+                    res_dependencies_active[arbitrary_const] = std::set<std::vector<Dependency>*>();
+                    res_dependencies_active[arbitrary_const].insert(new std::vector<Dependency>());
+                }
+
+                visit(act);
+
+                if (nullptr == mem_DST && nullptr == res_DST) {
+                    mem_DST = new deps_store_type<mem_deps_type>();
+                    res_DST = new deps_store_type<Dependency>();
+
+                    *mem_DST = clone_deps_store<mem_deps_type>(arbitrary_const, mem_dependencies_active);
+                    *res_DST = clone_deps_store<Dependency>(arbitrary_const, res_dependencies_active);
+
+                    current_segments = current_segments_cp;
+                    mem_dependencies_active = mem_dependencies_active_cp;
+                    res_dependencies_active = res_dependencies_active_cp;
+                }
+
+                product_chains<mem_deps_type>(mem_dependencies_active, *mem_DST);
+                product_chains<Dependency>(res_dependencies_active, *res_DST);
+
+                skip_visit = false;
+	    } else {
+                throw std::logic_error("Flightplan: unrecognised call syntax");
+	    }
+	}
+    }
+
+    if (!skip_visit) {
+	Access old_da = default_access;
+        // heed "in", "out", "inout"
+        if (nullptr == param_list) {
+            visit(e->arguments);
+	} else {
+            int i = 0;
+	    for (const IR::Argument *arg : *e->arguments->getEnumerator()) {
+	        auto param = param_list->getEnumerator()->toVector()->at(i);
+		i++;
+
+		switch (param->direction) {
+		case IR::Direction::In:
+	    		default_access = Access::Read;
+	    		break;
+		case IR::Direction::Out:
+	    		default_access = Access::Write;
+	    		break;
+		case IR::Direction::InOut:
+	    		default_access = Access::Read; // FIXME should also include 'Write'
+	    		break;
+		case IR::Direction::None:
+	    		default_access = Access::Read;
+	    		break;
+		}
+            	visit(arg);
+	    }
+	    default_access = old_da;
+	}
+    }
+    return false;
+}
+
+// Return width of the type in bytes -- make sure that type is serialisable (ask programmer to make it so otherwise)
+unsigned int sumBits(std::set<const IR::Expression*> set) {
+    unsigned int total = 0;
+    for (const IR::Expression* expr : set) {
+        const IR::Type* ty = FlightplanConfig::FP_typeMap->getType(expr->getNode());
+        if (ty->is<IR::Type_Bits>()) {
+            const IR::Type_Bits* ty_bits = &ty->as<IR::Type_Bits>();
+            total += ty_bits->size;
+	} else {
+            std::cout << "Could not sumBits non-bit type (" << ty->node_type_name() << ") of " << expr << std::endl;
+        }
+    }
+    return total;
+}
+
+std::set<const IR::Expression*> filter_location_variables(std::set<const IR::Expression*> set) {
+    std::set<const IR::Expression*> result;
+    for (const IR::Expression* expr : set) {
+        const IR::Type* ty = FlightplanConfig::FP_typeMap->getType(expr->getNode());
+        if (ty->is<IR::Type_Bits>()) {
+            const IR::Type_Bits* ty_bits = &ty->as<IR::Type_Bits>();
+	    if (ty_bits->size != 1337/*FIXME const*/) {
+                result.insert(expr);
+            }
+        } else {
+            result.insert(expr);
+	}
+    }
+    return result;
+}
+
+std::set<const IR::Expression*> deduplicate(ReferenceMap* refMap, std::set<const IR::Expression*> set) {
+    std::set<const IR::Expression*> result;
+    for (auto e1 : set) {
+        bool found = false;
+        for (auto e2 : result) {
+            if (std::string(e1->toString()) == std::string(e2->toString())) {
+    	        found = true;
+    	        break;
+            }
+        }
+        if (!found) {
+            result.insert(e1);
+        }
+    }
+    return result;
+}
+
+unsigned int bytesForBits(unsigned int bits) {
+    double bits_d = bits;
+    return (unsigned int)(ceil(bits_d / 8));
+}
+
+void FlightplanImpl::analyse_mem_deps (unsigned seg_id) {
+    // This function should only be called once.
+
+    assert((mem_reads.find(seg_id) == mem_reads.end() || mem_reads[seg_id].empty()) &&
+	  (mem_writes.find(seg_id) == mem_writes.end() || mem_writes[seg_id].empty()));
+
+    for (std::vector<std::pair<Access,const IR::Expression*>> *chain : mem_dependencies_completed[seg_id]) {
+        std::set<const IR::Expression*> reads;
+        std::set<const IR::Expression*> writes;
+
+        for (std::pair<Access,const IR::Expression*> entry : *chain) {
+            // FIXME naive -- relies on string comparison, would be better to compare wrt whether
+	    //       the expressions have the same definition.
+            if (Access::Write == entry.first) {
+                // FIXME Hack to avoid having duplicates of a variable in a set, since different expressions
+		//       (but featuring the same variable) are different wrt the pointer.
+		bool found = false;
+		for (const IR::Expression* expression : writes) {
+		    if (std::string(expression->toString()) == std::string(entry.second->toString())) {
+			found = true;
+			break;
+		    }
+		}
+		if (!found) {
+                    writes.insert(entry.second);
+		}
+            } else if (Access::Read == entry.first) {
+		// If we haven't written to that variable so far, then we need to read that variable externally.
+		bool found = false;
+		for (const IR::Expression* expression : writes) {
+		    if (std::string(expression->toString()) == std::string(entry.second->toString())) {
+			found = true;
+			break;
+		    }
+		}
+		if (found) {
+                    continue;
+		}
+
+		// Avoid duplicate entries in "reads" set
+		for (const IR::Expression* expression : reads) {
+		    if (std::string(expression->toString()) == std::string(entry.second->toString())) {
+			found = true;
+			break;
+		    }
+		}
+		if (!found) {
+                    reads.insert(entry.second);
+		}
+            }
+        }
+
+        mem_reads[seg_id].insert(reads.begin(), reads.end());
+        mem_writes[seg_id].insert(writes.begin(), writes.end());
+    }
+}
+
+// Required seg_id to be able to transitively handover hvi.
+// That is, regardless of how seg_id is reached, it might need to hand-over var_name downstream (only "might" since it depends on the control flow in the segment) and therefore it must be able to do so.
+void FlightplanImpl::require_transitive_handover (unsigned seg_id, std::string var_name, handed_var_info hvi, bool initial) {
+    if (handed_over_set.find(seg_id) == handed_over_set.end()) {
+        handed_over_set[seg_id] = std::map<std::string,handed_var_info>();
+    }
+
+    if (handed_over_set[seg_id].find(var_name) == handed_over_set[seg_id].end()) {
+        handed_over_set[seg_id][var_name] = hvi;
+    } else {
+        assert(handed_over_set[seg_id][var_name].width == hvi.width);
+	handed_over_set[seg_id][var_name].dependants.insert(hvi.dependants.begin(), hvi.dependants.end());
+    }
+
+    if (!initial) {
+        for (const IR::Expression *expr : mem_writes[seg_id]) {
+            std::string expr_s = std::string(expr->toString());
+            if (expr_s == var_name) {
+                return;
+            }
+        }
+    }
+
+    for (unsigned predecessor_sig_id : hand_overs_bk[seg_id]) {
+        require_transitive_handover(predecessor_sig_id, var_name, hvi, false);
+    }
+}
+
+// In FlightplanImpl::calculate_transitive_handover() we calculate what needs to be handed-over
+// at each segment to satisfy needs of downstream segments.
+// From seg_id, for each READ it needs, we iterate through all upstream segments that lead to seg_id
+// until we reach the first one that does a WRITE to that variable, then update
+// that segment and all intermediate segments to hand-over that value.
+//
+// We populate the "handed-over set" for that segment.
+// This is the set of values that the segment expects to be handed-over from each immediately-upstream segment.
+//
+// Later, for each segment and immediate upstream segment from which it gets a
+// hand-over, we map the handed-over set to the scratch space in the Flightplan
+// header: the immediate upstream segment uses this to write to the header,
+// and the receiving segment to read from the header. There will also be
+// data that is passed on to downstream segments, and not used by that receiving segment.
+void FlightplanImpl::calculate_transitive_handover (unsigned seg_id) {
+    for (const IR::Expression *expr : mem_reads[seg_id]) {
+        std::string expr_s = std::string(expr->toString());
+	handed_var_info hvi;
+	hvi.width = sumBits(std::set<const IR::Expression*>{expr});
+	hvi.dependants = std::set<unsigned>{seg_id};
+        require_transitive_handover(seg_id, expr_s, hvi, true);
+    }
+}
+
+// FlightplanImpl::analyse_handover() tells us the reads and writes of each segment by
+// digesting the mem_reads and mem_writes values calculated earlier for that segment.
+// We exclude switchmetadata and packetheader values from the calculation
+unsigned int FlightplanImpl::analyse_handover (unsigned seg_id) {
+    unsigned int result = 0;
+
+    analyse_mem_deps(seg_id);
+
+    //The new analysis uses mem_reads[seg_id] and mem_writes[seg_id] instead of the trace.
+
+    std::cout << "  analyse_handover:" << std::endl;
+    std::cout << "    analyse_handover@" << std::to_string(seg_id) << ": reads:" << std::endl;
+    if (!mem_reads[seg_id].empty()) {
+        for (const IR::Expression* entry : mem_reads[seg_id]) {
+            std::cout << "      '" << entry << "'" << std::endl;
+        }
+    } else {
+            std::cout << "      (none)" << std::endl;
+    }
+    std::cout << "    analyse_handover@" << std::to_string(seg_id) << ": writes:" << std::endl;
+    if (!mem_writes[seg_id].empty()) {
+        for (const IR::Expression* entry : mem_writes[seg_id]) {
+            std::cout << "      '" << entry << "'" << std::endl;
+        }
+    } else {
+            std::cout << "      (none)" << std::endl;
+    }
+
+    unsigned routing_segment_ingress_edits = 0;
+    unsigned routing_segment_egress_edits = 0;
+
+    std::set<const IR::Expression*> mem_accesses;
+    mem_accesses.insert(mem_reads[seg_id].begin(), mem_reads[seg_id].end());
+    mem_accesses.insert(mem_writes[seg_id].begin(), mem_writes[seg_id].end());
+
+    for (const IR::Expression* expr : mem_accesses) {
+	bool expr_is_metadata_egress = expr->toString() == std::string(options.flightplan_standard_md) + "." + std::string(options.flightplan_egress_var);
+	bool expr_is_metadata_ingress = expr->toString() == std::string(options.flightplan_standard_md) + "." + std::string(options.flightplan_ingress_var);
+        if (expr_is_metadata_egress) {
+            if (mem_reads[seg_id].find(expr) != mem_reads[seg_id].end()) {
+
+                // Programmer is trying to read the egress port
+                switch (options.flightplan_runtime) {
+	            case CompilerOptions::FlightplanRuntime::Full:
+                        break;
+	            case CompilerOptions::FlightplanRuntime::HL:
+                        if (options.flightplan_allow_metaIO) {
+                            std::cerr << ("Flightplan WARNING: Encountered egress (port-metadata) READ on " + expr->toString() + " (at " + expr->getSourceInfo().toPositionString() + ")") << std::endl;
+		        } else {
+                            throw std::logic_error("Flightplan: READ access forbidden by runtime: " + expr->toString() + " T=" + expr->type->toString() + " (at " + std::string(expr->getSourceInfo().toPositionString()) + ")");
+		        }
+                        break;
+                    default:
+                        throw std::logic_error("Flightplan: READ access forbidden by runtime: " + expr->toString() + " T=" + expr->type->toString() + " (at " + std::string(expr->getSourceInfo().toPositionString()) + ")");
+                        break;
+                }
+
+	    }
+
+            switch (options.flightplan_runtime) {
+	        case CompilerOptions::FlightplanRuntime::HL:
+	            std::cout << "  Hand-over partly made implicit by runtime: " << expr->toString() << " T=" << expr->type->toString() << std::endl;
+                    break;
+                default:
+                    break;
+            }
+            routing_segment_egress_edits += 1;
+	}
+
+        if (expr_is_metadata_ingress) {
+            switch (options.flightplan_runtime) {
+	        case CompilerOptions::FlightplanRuntime::HL:
+                    // Programmer is trying to read the ingress port
+                    if (options.flightplan_allow_metaIO) {
+                        std::cerr << ("Flightplan WARNING: Encountered ingress (port-metadata) READ on " + expr->toString() + " (at " + expr->getSourceInfo().toPositionString() + ")") << std::endl;
+		    } else {
+                        throw std::logic_error("Flightplan: READ access forbidden by runtime: " + expr->toString() + " T=" + expr->type->toString() + " (at " + std::string(expr->getSourceInfo().toPositionString()) + ")");
+		    }
+                    break;
+                default:
+                    routing_segment_ingress_edits += 1;
+                    break;
+            }
+	}
+
+	bool handover_this_entry = true;
+        if (expr->is<IR::Member>()) {
+            const IR::Member *pe = &expr->as<IR::Member>();
+	    if (std::string(pe->expr->type->toString()) == "struct " + std::string(options.flightplan_switch_md) ||
+	        std::string(pe->expr->type->toString()) == "struct " + std::string(options.flightplan_standard_md)) {
+	        if (!expr_is_metadata_egress && !expr_is_metadata_ingress) { // Those metadata fields are excepted, need to be passed on
+		       	handover_this_entry = false;
+		}
+	    } else if (std::string(pe->expr->type->toString()).substr(0, 7) == std::string("header ")) {
+	        handover_this_entry = false;
+	    }
+	}
+
+	if (std::string(expr->type->node_type_name()) == "Type_Header" || std::string(expr->type->node_type_name()) == "Type_Enum") {
+	    handover_this_entry = false;
+	}
+
+	if (!handover_this_entry) {
+	    if (mem_reads[seg_id].find(expr) != mem_reads[seg_id].end()) {
+                mem_reads[seg_id].erase(expr);
+	    }
+	    if (mem_writes[seg_id].find(expr) != mem_writes[seg_id].end()) {
+                mem_writes[seg_id].erase(expr);
+	    }
+	}
+    }
+
+    mem_accesses.clear();
+    mem_accesses.insert(mem_reads[seg_id].begin(), mem_reads[seg_id].end());
+    mem_accesses.insert(mem_writes[seg_id].begin(), mem_writes[seg_id].end());
+
+    // Confirm that routing segment does indeed read/write to port metadata
+    if (CompilerOptions::FlightplanRuntime::HL == options.flightplan_runtime &&
+	options.flightplan_routing_segment == segments[seg_id] &&
+	0 == routing_segment_ingress_edits &&
+	0 == routing_segment_egress_edits) {
+	std::cerr << "Flightplan WARNING: ingress/egress ports not read/written in the routing segment ('" << options.flightplan_routing_segment << "') at segment " << std::to_string(seg_id) << std::endl;
+    }
+
+    bool program_level_handover_needed = false;
+    if (mem_accesses.empty()) {
+	std::cout << "  No handover needed" << std::endl;
+    } else {
+        std::cout << "  Handover needed:" << std::endl;
+        for (const IR::Expression* entry : mem_accesses) {
+            program_level_handover_needed = true;
+            std::cout << "    " << entry->toString() << " T=" << entry->type->toString() << std::endl;
+	}
+    }
+
+    // NOTE this conflates reading (from earlier segment) and writing (to later segment);
+    //       these need to be split out, and transitively combined, and display for each pair of
+    //       contiguous segments. This is done by a later step.
+    result = sumBits(mem_accesses);
+    return bytesForBits(result);
+}
+
+std::string FlightplanImpl::generate_json ()
+{
+    std::set<std::string> props;
+    std::set<std::string> props_table;
+    std::set<std::string> props_extern;
+
+    std::string output = "{\n";
+
+    output += "  \"Parameters\" : {\n";
+    output += "    \"flightplan_runtime\" : \"" + runtime_to_string(options.flightplan_runtime) + "\",\n";
+    output += "    \"flightplan_switch_md\" : \"" + options.flightplan_switch_md + "\",\n";
+    output += "    \"flightplan_standard_md\" : \"" + options.flightplan_standard_md + "\",\n";
+    output += "    \"flightplan_egress_var\" : \"" + options.flightplan_egress_var + "\",\n";
+    output += "    \"flightplan_ingress_var\" : \"" + options.flightplan_ingress_var + "\",\n";
+    output += "    \"flightplan_max_handover_bytes\" : " + std::to_string(options.flightplan_max_handover_bytes) + ",\n";
+    output += "    \"flightplan_routing_segment\" : \"" + options.flightplan_routing_segment + "\",\n";
+    output += "    \"flightplan_offload_cflow\" : " + std::to_string(options.flightplan_offload_cflow) + ",\n";
+
+    output += "    \"mem_cells\" : [";
+    for (unsigned mem_cells_idx = 0; mem_cells_idx < options.mem_cells.size(); mem_cells_idx++) {
+	output += std::to_string(options.mem_cells[mem_cells_idx]);
+	if (mem_cells_idx < options.mem_cells.size() - 1) {
+            output += ", ";
+	}
+    }
+    output += "]\n";
+    output += "  },\n";
+
+    output += "  \"Abstract program\" : [\n";
+    for (unsigned long dep_idx = 0; dep_idx < dependencies.size(); ++dep_idx) {
+        auto seg_dep = dependencies.at(dep_idx);
+	std::string seg_label = std::to_string(seg_dep.seg_id) + "." + segments[seg_dep.seg_id];
+	output += "    {\"" + seg_label + "\": [";
+	props.insert(seg_label);
+	if (!seg_dep.dependencies.empty()) {
+	    output += "\n";
+	    for (unsigned long chain_idx = 0; chain_idx < seg_dep.dependencies.size(); ++chain_idx) {
+	        std::vector<Dependency> chain = seg_dep.dependencies.at(chain_idx);
+	        if (!chain.empty()) {
+	            output += "      {\"Index\": " + std::to_string(chain_idx) + ", " +
+			    "\"Props\": [";
+		    std::string descs;
+	            for (unsigned long i = 0; i < chain.size(); ++i) {
+	                output += "\"" + chain.at(i).name + "\"";
+	                descs += "\"" + chain.at(i).desc + "\"";
+                        if (i < chain.size() - 1) {
+	                    output += ", ";
+	                    descs += ", ";
+	                }
+
+	                if (TABLE_STR == chain.at(i).desc) {
+                             props_table.insert(chain.at(i).name);
+	                } else if (EXTERN_STR == chain.at(i).desc) {
+                             props_extern.insert(chain.at(i).name);
+	                }
+                    }
+	            output += "], \"Desc\": [" + descs + "]";
+	            output += "}";
+                    if (chain_idx < seg_dep.dependencies.size() - 1) {
+	                output += ",";
+	            }
+	            output += "\n";
+	        }
+	    }
+	    output += "    ";
+	}
+	output += "]}";
+        if (dep_idx < dependencies.size() - 1) {
+	    output += ",";
+	}
+	output += "\n";
+    }
+    output += "  ],\n";
+
+    output += "  \"FlightStartAliases\" : [\n";
+    unsigned long idx = 0;
+    for (unsigned segno : FlightStart_Segments) {
+	std::string seg_label = std::to_string(segno) + "." + segments[segno];
+        output += "    \"" + seg_label + "\"";
+	if (idx != FlightStart_Segments.size() - 1) {
+            output += ",";
+	}
+        output += "\n";
+
+	idx++;
+    }
+    output += "  ],\n";
+
+    output += "  \"Allocations\" : {\n";
+    for (unsigned long segno = 0; segno < next_segment_id; ++segno) {
+	std::string seg_label = std::to_string(segno) + "." + segments[segno];
+        output += "    \"" + seg_label + "\" : {\n";
+        unsigned alloc_idx = 0;
+        for (single_allocation allocation : cell_allocations[segno]) {
+            output += "      \"" + allocation.name + "\" : [";
+	    unsigned cs_idx = 0;
+            for (cell_segment cs : allocation.cell_segments) {
+                output += std::to_string(cs.cell_idx);
+                if (cs_idx < allocation.cell_segments.size() - 1) {
+                    output += ",";
+	        }
+		cs_idx++;
+	    }
+            output += "]";
+            if (alloc_idx < cell_allocations[segno].size() - 1) {
+                output += ",";
+	    }
+            output += "\n";
+            alloc_idx++;
+        }
+        output += "    }";
+        if (segno < next_segment_id - 1) {
+            output += ",";
+	}
+        output += "\n";
+    }
+    output += "  },\n";
+
+    output += "  \"CFG\" : [\n";
+    for (unsigned long idx = 0; idx < hand_overs.size(); ++idx) {
+	std::pair<std::pair<unsigned,unsigned>, const IR::Expression*> handovers_entry = hand_overs[idx];
+        output += "    {\"" + std::to_string(handovers_entry.first.first) + "." + segments[handovers_entry.first.first] + "\": \"" + std::to_string(handovers_entry.first.second) + "." + segments[handovers_entry.first.second] + "\"}";
+        if (idx < hand_overs.size() - 1) {
+            output += ",";
+	}
+        output += "\n";
+    }
+    output += "  ],\n";
+
+    output += "  \"Signature\" : {\n";
+    output += "    \"Prop\": [";
+    for (std::string prop : props) {
+	    output += "\"" + prop + "\"";
+	    output += ", ";
+    }
+    output.pop_back(); output.pop_back();
+    output += "],\n";
+    output += "    \"V\": []\n"; // NOTE we don't populate this here.
+    output += "  },\n";
+
+    output += "  \"Tables\": {\n";
+    for (std::string resource : props_table) {
+        output += "    \"" + resource + "\": [],\n";
+    }
+    if (!props_table.empty()) {
+        output.pop_back(); output.pop_back();
+    }
+    output += "\n  },\n";
+
+    output += "  \"Externs\": {\n";
+    for (std::string resource : props_extern) {
+        output += "    \"" + resource + "\": [],\n";
+    }
+    if (!props_extern.empty()) {
+        output.pop_back(); output.pop_back();
+    }
+    output += "\n  },\n";
+
+    output += "  \"Hand-over Overheads\" : {\n";
+    for (unsigned i = 0; i < next_segment_id; ++i) {
+	std::string seg_label = std::to_string(i) + "." + segments[i];
+
+	if (handed_over_set[i].empty()) {
+            output += "    \"" + seg_label + "\" : {";
+	} else {
+            output += "    \"" + seg_label + "\" : {\n";
+	    unsigned idx = 0;
+	    for (std::pair<std::string,handed_var_info> entry : handed_over_set[i]) {
+                output += "      \"" + entry.first + "\" : " + std::to_string(entry.second.width);
+                if (idx < handed_over_set[i].size() - 1) {
+		    output += ",";
+		}
+		output += "\n";
+		idx++;
+	    }
+	}
+        output += "    }";
+        if (i < next_segment_id - 1) {
+	    output += ",";
+	}
+        output += "\n";
+    }
+    output += "  }\n";
+
+    output += "}";
+
+    return output;
+}
+
+bool FlightplanImpl::preorder(const IR::P4Program* p) {
+    current_segments.insert(initial_segment_id);
+    segments[initial_segment_id] = FlightplanConfig::landing_start;
+    segment_info[FlightplanConfig::landing_start] = std::set<std::pair<unsigned,std::string>>();
+    segment_info[FlightplanConfig::landing_start].insert(std::pair<unsigned,std::string>(initial_segment_id, initial_segment_location));
+    if (options.flightplan_runtime == CompilerOptions::FlightplanRuntime::HL &&
+            options.flightplan_routing_segment != segments[initial_segment_id]) {
+        FlightplanData::ingress_segments.insert(initial_segment_id);
+    }
+    next_segment_id = initial_segment_id + 1;
+
+    activate_chain(initial_segment_id);
+
+    FlightplanConfig::p4_program = p;
+    if (options.flightplan_verbose) {
+        std::cout << "Program main: " << p->main << std::endl;
+    }
+    original_prog = p;
+    auto main_decl = p->getDeclsByName(p->main)->toVector()->at(0);
+
+    auto di = main_decl->getNode()->to<IR::Declaration_Instance>();
+    for (auto a : *di->arguments) {
+        auto decl = p->getDeclsByName(a->toString())->toVector()->at(0);
+        bool interesting_control_block = false;
+        if (decl->getNode()->is<IR::P4Control>()) {
+            interesting_control_block = true;
+	    control_sequence.push_back(decl);
+        }
+
+        if (options.flightplan_verbose) {
+            std::cout << "Arg: " << decl->toString();
+            std::cout << " : " << decl->getNode()->node_type_name();
+            if (interesting_control_block) {
+                std::cout << " (*)";
+            }
+            std::cout << std::endl;
+	}
+
+        if (interesting_control_block)
+            visit(decl->getNode());
+    }
+
+    return false;
+}
+
+bool FlightplanImpl::preorder(const IR::PathExpression* expr) {
+        note_mem_dependency(default_access, expr);
+	return false;
+}
+
+bool FlightplanImpl::preorder(const IR::P4Control* s) {
+    if (options.flightplan_verbose) {
+        std::cout << "P4Control: " << s->externalName() << std::endl;
+    }
+
+    if (options.flightplan_mode == CompilerOptions::FlightplanMode::Split) {
+        if (std::string(options.flightplan_focus_block) == std::string(s->getName().toString())) {
+            std::cerr << "main = " << s->getName() << std::endl;
+            control = s;
+            control_ID = s->getName(); // FIXME redundant
+            main = StmtConvert::encapsulate(nullptr, std::string(options.flightplanFolder), s->body, nullptr, nullptr);
+        }
+    }
+
+    for (auto decl : *s->getDeclarations()) {
+        control_set.insert(decl);
+    }
+
+    current_context.push_front(CodeContext::ControlBlock);
+    visit(s->body);
+    current_context.pop_front();
+
+    return false;
+}
+
+void FlightplanImpl::compute_chains(std::set<std::vector<unsigned>> &chainset)
+{
+    bool changes = true;
+    while (changes) {
+        changes = false;
+        std::set<std::vector<unsigned>> updated_chainset;
+        for (const std::vector<unsigned> chain : chainset) {
+            if (initial_segment_id != chain.back()) {
+                changes = true;
+                assert(!hand_overs_bk[chain.back()].empty());
+                for (const unsigned next_segment : hand_overs_bk[chain.back()]) {
+                    std::vector<unsigned> chain_copy = chain;
+                    chain_copy.push_back(next_segment);
+                    updated_chainset.insert(chain_copy);
+                }
+            } else {
+                updated_chainset.insert(chain);
+            }
+        }
+        chainset = updated_chainset;
+    }
+}
+
+// NOTE this only applies to Full runtime
+void FlightplanImpl::allocate_mem(unsigned seg_no) {
+    // FIXME this allocation is wasteful since doesn't pack tightly.
+    unsigned cur_cell_idx = 0;
+    for (std::pair<std::string,handed_var_info> entry : handed_over_set[seg_no]) {
+        single_allocation salloc;
+	salloc.name = entry.first;
+	unsigned width_left = entry.second.width;
+	while (width_left > 0) {
+	  if (options.mem_cells[cur_cell_idx] >= width_left) {
+              width_left = 0;
+	  } else {
+              width_left -= options.mem_cells[cur_cell_idx];
+	  }
+	  cell_segment cs;
+	  cs.cell_idx = cur_cell_idx;
+	  salloc.cell_segments.push_back(cs);
+          cur_cell_idx++;
+	}
+	cell_allocations[seg_no].push_back(salloc);
+    }
+}
+
+void FlightplanImpl::print_allocation(unsigned seg_no) {
+    std::cout << "  allocations = " << std::endl;
+    for (single_allocation allocation : cell_allocations[seg_no]) {
+        std::cout << "    " << allocation.name << ": ";
+	for (cell_segment cs : allocation.cell_segments) {
+            std::cout << std::to_string(cs.cell_idx) << " ";
+	}
+        std::cout << std::endl;
+    }
+}
+
+void FlightplanImpl::split() {
+    std::cout << "Split summary:" << std::endl;
+    for (auto split : Split::Splits) {
+        std::cout << "  split->name: " << split->name << std::endl;
+        std::cout << "  split->output_file: " << split->output_file << std::endl;
+        std::cout << "  split->beginning: " << split->beginning << std::endl;
+        std::cout << std::endl;
+    }
+
+    FlyAnalysisState fas;
+    Fly_Analyser ca(FlightplanConfig::FP_typeMap, FlightplanConfig::FP_refMap);
+    ca.process(FlightplanImpl::main, &fas);
+    std::cout << "Fly location mappings:" << std::endl;
+    // FIXME use these mappings to clean up the flyto's in the splits, so they'll mention actual Landings and not tmp_0 etc.
+    for (auto &p : fas) {
+        std::cout << "  " << p.first << " |-> " << p.second << std::endl;
+    }
+
+    unsigned idx = 0;
+    std::cout << "Output files (" << Split::Splits.size() << "): ";
+    for (auto item : Split::Splits) {
+        idx += 1;
+        item->output_file = item->output_file + "_seg" + std::to_string(idx);
+        std::cout << item->output_file << " ";
+    }
+    std::cout << std::endl;
+    print_ctxt();
+
+    std::cout << "Program declarations: " << std::endl;
+    for (auto decl : *original_prog->getDeclarations()) {
+        std::cout << "  * (" << decl->node_type_name() << ") " << decl->getNode()->toString() << std::endl;
+    }
+
+    std::cout << "Main-block declarations: " << std::endl;
+    for (auto decl : control_decls) {
+        std::cout << "  * (" << decl->node_type_name() << ") " << decl->getNode()->toString() << std::endl;
+    }
+
+    std::cout << "Main-block ID: " << control_ID.name << std::endl;
+
+    std::map<const cstring, IR::BlockStatement> step_map;
+    std::cout << "Emitting splits";
+    int split_count = 0;
+    for (auto split : Split::Splits) {
+        std::cout << "Split " << std::to_string(split_count) << std::endl;
+        ++split_count;
+
+        if (step_map.find(split->output_file) != step_map.end()) {
+            std::logic_error("Unexpected");
+        } else {
+           IR::BlockStatement bs;
+
+           // This is crucial, we need to split before we can getCleaved()
+           if (options.flightplan_mode == CompilerOptions::FlightplanMode::Split) {
+              Split::effect_split(split);
+              bs.push_back(split->getCleaved()->toStatement());
+
+              // find out set of read & written variables in each segment   
+              ContextAnalysisState cas;
+              Context_Analyser ca(FlightplanConfig::FP_typeMap, FlightplanConfig::FP_refMap);
+              ca.process((FStmt*)split->getCleaved(), &cas);
+              cas.reads = deduplicate(FlightplanConfig::FP_refMap, filter_location_variables(cas.reads));
+              cas.writes = deduplicate(FlightplanConfig::FP_refMap, filter_location_variables(cas.writes));
+              std::cout << "  reads : " << cas.readsString() << std::endl;
+              // FIXME factor reads & writes by same expressions -- the sets appear to contain repeated references (but different pointers) to the same expressions
+              std::cout << "    total bytes = " << std::to_string(bytesForBits(sumBits(cas.reads))) << std::endl;
+              std::cout << "  writes: " << cas.writesString() << std::endl;
+              std::cout << "    total bytes = " << std::to_string(bytesForBits(sumBits(cas.writes))) << std::endl;
+
+           } else {
+              bs.push_back(split->getBeginning()->toStatement());
+           }
+           step_map[split->output_file] = bs;
+
+           if (options.flightplan_DOT_output) {
+               const cstring destination = std::string(split->output_file) + ".dot";
+               std::cout << "Writing DOT file:" << destination << std::endl;
+               if (!destination.isNullOrEmpty()) {
+                   Util::PathName path(destination);
+                   std::ostream *ost = new std::ofstream(path.toString(), std::ios_base::app);
+                   *ost << FlightplanConfig::header_comment << std::endl << std::endl;
+                   if (options.flightplan_mode == CompilerOptions::FlightplanMode::Split) {
+                      std::cout << "Generating DOT" << std::endl;
+                      Split::to_dot(ost, split);
+                   }
+               } else {
+                   ::error("Null filename?");
+               }
+           }
+        }
+    }
+    std::cout << std::endl;
+
+    // Show dependencies between splits
+    for (auto split : Split::Splits) {
+        std::cout << "split = " << split->output_file;
+        std::set<Split*> ts = split->successor_splits;
+        std::cout << " (" << ts.size() << ")" << std::endl;
+        for (auto next_split : ts) {
+            std::cout << "  * " << next_split->output_file << std::endl;
+        }
+    }
+
+    if (options.flightplan_mode == CompilerOptions::FlightplanMode::Split) {
+        // Draw split-level topology
+        if (options.flightplan_DOT_output) {
+            const cstring destination = options.flightplanFolder + "/" + "split-topology.dot";
+            std::cout << "Writing split-level topology:" << destination << std::endl;
+            if (!destination.isNullOrEmpty()) {
+                Util::PathName path(destination);
+                std::ostream *ost = new std::ofstream(path.toString(), std::ios_base::app);
+                *ost << FlightplanConfig::header_comment << std::endl << std::endl;
+                Split::splits_dot(ost);
+            }
+        }
+
+        // FIXME experimental    
+        if (options.flightplan_DOT_output) {
+            const cstring destination = options.flightplanFolder + "/" + "cfg.dot";
+            std::cout << "Writing CFG file:" << destination << std::endl;
+            if (!destination.isNullOrEmpty()) {
+                Util::PathName path(destination);
+                std::ostream *ost = new std::ofstream(path.toString(), std::ios_base::app);
+                *ost << FlightplanConfig::header_comment << std::endl << std::endl;
+                *ost << "digraph G {" << std::endl;
+                std::set<const FStmt*> visited;
+                StmtFlow::cfg_dot(ost, FlightplanImpl::main, visited);
+                *ost << "}" << std::endl;
+            } else {
+                ::error("Null filename?");
+            }
+        }
+    }
+
+    std::cout << "Writing files:" << std::endl;
+    idx = 0;
+    for (auto step : step_map) {
+        idx += 1;
+        std::cout << "  * idx=" << std::to_string(idx) << " " << step.first << " (";
+        IR::BlockStatement bs = step.second;
+        int size = 0;
+        for (auto c : bs.components) {
+            size += 1;
+        }
+        std::cout << size << ")" << std::endl;
+
+        IR::P4Control newctrl = IR::P4Control(control_ID, control->type, control->controlLocals, /*control->body*/&bs);
+        IR::IndexedVector<IR::Node> declarations;
+
+        for (auto decl : *original_prog->getDeclarations()) {
+            // Preserve order of declarations
+            if (decl->is<IR::IDeclaration>() && decl->as<IR::IDeclaration>().getName() == control_ID)
+                declarations.push_back(&newctrl);
+            else
+                declarations.push_back(decl->getNode());
+        }
+
+        IR::P4Program prog = IR::P4Program(declarations);
+        prog.validate();
+
+        FStmt::toFile(FlightplanConfig::adjusted_input_filename, step.first, &prog);
+    }
+
+    std::string received_file = options.flightplanFolder + "/" + FlightplanConfig::adjusted_input_filename + "_received";
+    std::cout << "Writing received file:" << received_file << std::endl;
+
+    /*FIXME DRY principle from the previous block*/
+    IR::P4Control newctrl = IR::P4Control(control_ID, control->type, control->controlLocals, /*control->body*/(IR::BlockStatement*)/*FIXME hack*/FlightplanImpl::main->toStatement());
+    IR::IndexedVector<IR::Node> declarations;
+    for (auto decl : *original_prog->getDeclarations()) {
+        // Preserve order of declarations
+        if (decl->is<IR::IDeclaration>() && decl->as<IR::IDeclaration>().getName() == control_ID)
+            declarations.push_back(&newctrl);
+        else
+            declarations.push_back(decl->getNode());
+    }
+    IR::P4Program prog = IR::P4Program(declarations);
+    prog.validate();
+    FStmt::toFile(FlightplanConfig::adjusted_input_filename, received_file, &prog);
+}
+
+void FlightplanImpl::hook_end() {
+    if (options.flightplan_mode == CompilerOptions::FlightplanMode::Split) {
+        FlightplanImpl::split();
+    }
+
+    if (options.flightplan_mode == CompilerOptions::FlightplanMode::Analyse) {
+        deactivate_chains();
+
+        if (FlightplanConfig::landing_start == options.flightplan_routing_segment) {
+            FlightplanData::seen_routing = true;
+        }
+
+        if (options.flightplan_offload_cflow) {
+            std::vector<std::pair<std::pair<unsigned,unsigned>, const IR::Expression*> > updated_hand_overs;
+            for (std::pair<std::pair<unsigned,unsigned>, const IR::Expression*> handovers_entry : hand_overs) {
+                if (FlightplanConfig::landing_start != segments[handovers_entry.first.first] &&
+                    FlightplanConfig::landing_start != segments[handovers_entry.first.second]) {
+
+                    std::pair<std::pair<unsigned,unsigned>, const IR::Expression*> handovers_entry1;
+                    std::pair<std::pair<unsigned,unsigned>, const IR::Expression*> handovers_entry2;
+
+            	segments[next_segment_id] = FlightplanConfig::landing_start;
+                    handovers_entry1.first = {handovers_entry.first.first, next_segment_id};
+                    handovers_entry1.second = handovers_entry.second;
+
+                    handovers_entry2.first = {next_segment_id, handovers_entry.first.second};
+                    handovers_entry2.second = handovers_entry.second;
+            	next_segment_id++;
+
+            	updated_hand_overs.push_back(handovers_entry1);
+            	updated_hand_overs.push_back(handovers_entry2);
+                } else {
+            	updated_hand_overs.push_back(handovers_entry);
+                }
+            }
+            hand_overs = updated_hand_overs;
+        }
+
+        std::cout << "segments = " << std::endl;
+        bool found_flightplan_routing_segment = false;
+        for (auto segname : segments) {
+            std::cout << "  " << std::to_string(segname.first) << ": " << segname.second;
+            if (segname.second == options.flightplan_routing_segment) {
+                found_flightplan_routing_segment = true;
+            }
+
+            if (options.flightplan_runtime == CompilerOptions::FlightplanRuntime::HL) {
+                if (FlightplanData::ingress_segments.find(segname.first) != FlightplanData::ingress_segments.end()) {
+                    std::cout << " (ingress segment)";
+                } else if (FlightplanData::egress_segments.find(segname.first) != FlightplanData::egress_segments.end()) {
+                    std::cout << " (egress segment)";
+                } else {
+                    // Neither ingress nor egress segment
+            	assert(segname.second == options.flightplan_routing_segment);
+                    std::cout << " (routing segment)";
+                }
+            }
+
+            std::cout << std::endl;
+        }
+
+        if (options.flightplan_runtime == CompilerOptions::FlightplanRuntime::HL &&
+            	    ! found_flightplan_routing_segment) {
+            throw std::logic_error("Flightplan: Segment named by --flightplan_routing_segment not found");
+        }
+
+        std::cout << "FlightStart segments = " << std::endl;
+        for (auto segname : segments) {
+            if (FlightplanConfig::landing_start == segname.second) {
+            	FlightStart_Segments.insert(segname.first);
+                    std::cout << "  " << std::to_string(segname.first) << " (" << segname.second << ")" << std::endl;
+            }
+        }
+
+        std::cout << "hand-overs = " << std::endl;
+        for (std::pair<std::pair<unsigned,unsigned>, const IR::Expression*> handovers_entry : hand_overs) {
+            std::cout << "  " << std::to_string(handovers_entry.first.first) << "." << segments[handovers_entry.first.first] << " -> " << std::to_string(handovers_entry.first.second) << "." << segments[handovers_entry.first.second] << " (at " << handovers_entry.second->getSourceInfo().toPositionString() << ")" << std::endl;
+
+            if (hand_overs_fw.find(handovers_entry.first.first) == hand_overs_fw.end()) {
+                hand_overs_fw[handovers_entry.first.first] = std::set<unsigned>();
+            }
+            hand_overs_fw[handovers_entry.first.first].insert(handovers_entry.first.second);
+
+            if (hand_overs_bk.find(handovers_entry.first.second) == hand_overs_bk.end()) {
+                hand_overs_bk[handovers_entry.first.second] = std::set<unsigned>();
+            }
+            hand_overs_bk[handovers_entry.first.second].insert(handovers_entry.first.first);
+        }
+
+        for (auto segname : segments) {
+            if (hand_overs_fw.find(segname.first) == hand_overs_fw.end()) {
+                terminal_segments.insert(segname.first);
+            }
+        }
+        std::cout << "egress_var_is_updated = " << std::to_string(egress_var_is_updated) << std::endl;
+        std::cout << "(original) terminal_segments = " << std::endl;
+        for (unsigned seg_id : terminal_segments) {
+            std::cout << "  " << std::to_string(seg_id) << ": " << segments[seg_id] << std::endl;
+        }
+
+        if (options.flightplan_offload_cflow) {
+            std::set<unsigned> updated_terminal_segments;
+            for (unsigned seg_id : terminal_segments) {
+                 if (FlightplanConfig::landing_start != segments[seg_id]) {
+        	     segments[next_segment_id] = FlightplanConfig::landing_start;
+                     updated_terminal_segments.insert(next_segment_id);
+
+                     std::pair<std::pair<unsigned,unsigned>, const IR::Expression*> handover_entry;
+                     handover_entry.first = {seg_id, next_segment_id};
+                     handover_entry.second = nullptr;
+                     hand_overs.push_back(handover_entry);
+
+                     FlightStart_Segments.insert(next_segment_id);
+
+        	     std::cout << "Adding terminal return " <<
+                       std::to_string(next_segment_id) << "(" << segments[next_segment_id] << ")" << " from " <<
+                       std::to_string(seg_id) << "(" << segments[seg_id] << ")" << std::endl;
+
+                     hand_overs_fw[seg_id].insert(next_segment_id);
+                     hand_overs_bk[next_segment_id].insert(seg_id);
+
+        	     next_segment_id++;
+                 } else {
+                     updated_terminal_segments.insert(seg_id);
+                 }
+            }
+            terminal_segments = updated_terminal_segments;
+        }
+
+        std::cout << "terminal_segments = " << std::endl;
+        for (unsigned seg_id : terminal_segments) {
+            std::cout << "  " << std::to_string(seg_id) << ": " << segments[seg_id] << std::endl;
+        }
+
+        // FlightplanData::seen_routing overlaps with found_flightplan_routing_segment, but only if we're using CompilerOptions::FlightplanRuntime::HL
+        if (options.flightplan_runtime == CompilerOptions::FlightplanRuntime::HL) {
+            assert(FlightplanData::seen_routing == found_flightplan_routing_segment);
+        }
+
+        std::cout << "(max) segment_id = " << next_segment_id << std::endl;
+
+        assert(mem_dependencies_active.empty());
+        assert(res_dependencies_active.empty());
+
+        for (unsigned i = 0; i < next_segment_id; ++i) {
+            std::cout << "i = " << i << " (" << segments[i] << ")" << std::endl;
+
+            for (std::vector<Dependency>* entry_set : res_dependencies_completed[i]) {
+                if (0 == entry_set->size()) {
+                    res_dependencies_completed[i].erase(entry_set);
+                    continue;
+                }
+            }
+
+            if (res_dependencies_completed[i].empty()) {
+                std::cout << "  No res_dependencies" << std::endl;
+
+                SegDependency sd;
+                sd.seg_id = i;
+                dependencies.push_back(sd);
+            } else {
+                std::cout << "  res_dependencies(" << res_dependencies_completed[i].size() << ") = " << std::endl;
+                SegDependency sd;
+                sd.seg_id = i;
+                for (std::vector<Dependency>* entry_set : res_dependencies_completed[i]) {
+                    std::cout << "    chain(" << entry_set->size() << ") = " << std::endl;
+                    for (Dependency dep : *entry_set) {
+                        std::cout << "      " << dep.name << " : " << dep.desc << std::endl;
+                    }
+                    sd.dependencies.push_back(*entry_set);
+                }
+                dependencies.push_back(sd);
+            }
+
+            if (segments.size() > 1) {
+                // NOTE handover_state_overhead is only approximate -- it conflates
+                //      reads and writes, and doesn't account for transitive
+                //      hand-overs.
+                //      A more accurate overhead figure can be obtained after the call
+                //      to calculate_transitive_handover().
+                unsigned int handover_state_overhead = analyse_handover(i);
+                std::cout << "  handover_state_overhead = " << std::to_string(handover_state_overhead) << " bytes " << std::endl;
+            }
+
+            if (terminal_segments.find(i) != terminal_segments.end()) {
+                if (egress_var_is_updated) {
+                    handed_var_info hvi;
+                    hvi.width = 9/*FIXME const*/;
+                    hvi.dependants.insert(i);
+                    std::string var_name = std::string(options.flightplan_standard_md) + "." + std::string(options.flightplan_egress_var);
+                    require_transitive_handover(i, var_name, hvi, true);
+                }
+            }
+
+            calculate_transitive_handover(i);
+        }
+
+        std::cout << "Post-analysis:" << std::endl;
+        bool handover_required = false;
+        for (unsigned i = 0; i < next_segment_id; ++i) {
+            std::cout << "i = " << i << " (" << segments[i] << ")" << std::endl;
+            std::cout << "  handed_over_set[" << std::to_string(i) << "] = " << std::endl;
+            if (segments.size() == 1) {
+                handed_over_set[i].clear();
+            }
+            if (handed_over_set[i].empty()) {
+               std::cout << "     (none)" << std::endl;
+            } else {
+               for (std::pair<std::string,handed_var_info> entry : handed_over_set[i]) {
+                   std::cout << "     " << entry.first << ": width=" << std::to_string(entry.second.width) << std::endl;
+                   std::cout << "       dependants= ";
+                   for (unsigned dep : entry.second.dependants) {
+                       std::cout << std::to_string(dep) << " (" << segments[dep] << ") ";
+                   }
+                   std::cout << std::endl;
+
+                   if ((entry.first == std::string(options.flightplan_standard_md) + "." + std::string(options.flightplan_egress_var) ||
+                		entry.first == std::string(options.flightplan_standard_md) + "." + std::string(options.flightplan_ingress_var)) &&
+                        	   options.flightplan_runtime == CompilerOptions::FlightplanRuntime::HL)
+                   {
+                       std::cerr << ("Flightplan WARNING: Ignoring hand-over related to port-metadata on HL since it will follow an HL parameter") << std::endl;
+                   } else {
+                       handover_required = true;
+                   }
+               }
+               allocate_mem(i);
+               print_allocation(i);
+            }
+        }
+
+        if (handover_required) {
+            switch (options.flightplan_runtime) {
+                case CompilerOptions::FlightplanRuntime::Full:
+                    break;
+                default:
+                    throw std::logic_error("Flightplan: runtime does not support hand-over of program state");
+            }
+        }
+
+        if (!options.flightplan_emit_JSON.empty()) {
+            //std::string json_filename = options.flightplanFolder + "/" + FlightplanConfig::adjusted_input_filename + ".json";
+            std::string json_filename = options.flightplanFolder + "/" + options.flightplan_emit_JSON;
+            std::cout << "Writing JSON file:" << json_filename << std::endl;
+            if (!json_filename.empty()) {
+                std::ifstream fTest(json_filename);
+                if (fTest.good()) {
+                    ::error("JSON filename exists");
+                } else {
+                    std::ostream *ppStream = new std::ofstream(json_filename, std::ios_base::app);
+                    *ppStream << FlightplanImpl::generate_json() << std::endl;
+                }
+            } else {
+                ::error("Invalid JSON filename");
+            }
+        }
+    }
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan_analysis.cpp b/frontends/p4/flightplan_analysis.cpp
new file mode 100644
index 0000000..e46e605
--- /dev/null
+++ b/frontends/p4/flightplan_analysis.cpp
@@ -0,0 +1,194 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#include <assert.h>
+#include <iostream>
+#include <fstream>
+#include <queue>
+
+#include "externInstance.h"
+
+#include "../common/options.h"
+#include "ir/ir.h"
+#include "ir/visitor.h"
+#include "lib/nullstream.h"
+#include "lib/path.h"
+#include "toP4/toP4.h"
+
+#include "flightplan.h"
+
+namespace P4 {
+
+void Split::mark_split(FStmt* stmt, Split* split, std::set<const FStmt*> visited) {
+    for (auto next : StmtFlow::step(StmtFlow::Direction::Forward, stmt, visited)) {
+        const TransferPoint *tp = dynamic_cast<const TransferPoint*>(stmt);
+        if (tp != nullptr) {
+            stmt->splits.clear();
+            split = new_split(std::string(FlightplanConfig::FP_options.flightplanFolder), tp->transfer_to, stmt);
+            mark_split((FStmt*)/*FIXME type hack*/next, split, visited);
+        } else {
+            stmt->splits.insert(split);
+            mark_split((FStmt*)/*FIXME type hack*/next, split, visited);
+        }
+    }
+}
+
+int Split::mark_split(FStmt* main) {
+    for (auto split : main->splits) {
+        std::set<const FStmt*> visited;
+        mark_split(main, split, visited);
+    }
+    return Split::Splits.size();
+}
+
+bool Split::ascend_split(Split *split, FStmt* prev, FStmt* stmt, std::set<FStmt*> &visited) {
+    if (stmt == nullptr || stmt->getContainer() == nullptr) {
+        return false;
+    }
+
+    if (stmt->getContainer()->get_next() != nullptr) {
+        return continue_split(split, prev, (FStmt*)/*FIXME type hack*/stmt->getContainer()->get_next(), visited, false, true/*If we have ascended, we shall continue to ascend*/);
+    } else {
+        return ascend_split(split, prev, (FStmt*)/*FIXME type hack*/stmt->getContainer(), visited);
+    }
+}
+
+bool Split::continue_split(Split *split, FStmt* prev, FStmt* stmt, std::set<FStmt*> &visited, bool pre_cloned, bool ascend) {
+    if (stmt == nullptr) {
+        return false;
+    }
+
+    // We are guaranteed that stmt!=nullptr at this point
+    stmt->keep_split(split);
+
+    FStmt* stmt_cp = nullptr;
+    if (!pre_cloned) {
+        stmt_cp = stmt->clone();
+        stmt = nullptr;
+    } else {
+        stmt_cp = (FStmt *)/*FIXME type hack*/stmt;
+        stmt = nullptr;
+    }
+    if (prev != nullptr) {
+        prev->set_next(stmt_cp);
+    }
+    stmt_cp->set_prev(prev);
+
+    if (StmtFlow::transfer_stmt(stmt_cp)) {
+        stmt_cp->set_next(nullptr);
+        // FIXME set_next to null be default?
+        auto next_split = StmtFlow::transfers_to(stmt_cp);
+        std::cout << "TRANSFER! -> " << next_split->output_file << std::endl;
+        split->successor_splits.insert(next_split);
+        return true;
+    }
+
+    BlockStmt *bs = dynamic_cast<BlockStmt*>(stmt_cp);
+    if (bs != nullptr) {
+        assert(bs->getEntry() != nullptr);
+        assert(visited.find(bs) == visited.end());
+        std::cout << "...Block" << std::endl;
+        visited.insert(bs);
+        bs->setEntry(bs->getEntry()->clone());
+        if (continue_split(split, nullptr, bs->getEntry(), visited, true, ascend)) {
+            return true;
+        }
+    }
+    IfStmt *ifst = dynamic_cast<IfStmt*>(stmt_cp);
+    if (ifst != nullptr) {
+        visited.insert(ifst);
+        std::cout << "...If" << std::endl;
+
+        assert(ifst->get_ifTrue() != nullptr);
+        int total_branches = 2; // Even if there isn't a "false" branch, it's implicitly there but does nothing (importantly, it doesn't transfer)
+        int total_transfers = 0;
+        ifst->set_ifTrue(ifst->get_ifTrue()->clone());
+        if (continue_split(split, nullptr, ifst->get_ifTrue(), visited, true, ascend)) {
+            total_transfers += 1;
+        }
+
+        if (ifst->get_ifFalse() != nullptr) {
+            total_branches += 1;
+
+            ifst->set_ifFalse(ifst->get_ifFalse()->clone());
+            if (continue_split(split, nullptr, ifst->get_ifFalse(), visited, true, ascend)) {
+                total_transfers += 1;
+            }
+        }
+
+        if (total_branches == total_transfers) {
+            return true;
+        }
+    }
+    SwitchStmt *swst = dynamic_cast<SwitchStmt*>(stmt_cp);
+    if (swst != nullptr) {
+        assert(visited.find(swst) == visited.end());
+        visited.insert(swst);
+        std::cout << "...Switch" << std::endl;
+
+        int total_branches = swst->getCases().size();
+        int total_transfers = 0;
+
+        for (auto c : swst->getCases()) {
+            std::cout << "...Case" << std::endl;
+            if (continue_split(split, nullptr, c.get_fstmt(), visited, true, ascend)) {
+                total_transfers += 1;
+            }
+        }
+
+        if (total_branches == total_transfers) {
+            return true;
+        }
+    }
+
+    if (stmt_cp->get_next() != nullptr) {
+        return continue_split(split, stmt_cp, (FStmt*)/*FIXME type hack*/stmt_cp->get_next(), visited, false, ascend);
+    } else {
+        if (stmt_cp->getContainer() != nullptr &&
+                visited.find((FStmt *)/*FIXME type hack*/stmt_cp->getContainer()) == visited.end()) {
+            if (ascend) {
+                // Computes CFG
+                return ascend_split(split, stmt_cp, stmt_cp, visited);
+            } else {
+                // Computes subgraph of AST
+                return false;
+            }
+        } else {
+            return false;
+        }
+    }
+}
+
+FStmt* Split::effect_split(Split *split) {
+    // Cache the split code, to avoid redoing the splitting if this function is called again?
+    if (split->cleaved != nullptr) {
+        return split->cleaved;
+    } else {
+        std::cout << "Splitting..." << std::endl;
+        std::set<FStmt *> visited;
+        FStmt* pre_result = split->beginning->clone();
+        pre_result->set_prev(nullptr);
+
+        if (StmtFlow::transfer_stmt(pre_result)) {
+            pre_result->keep_split(split);
+            // Otherwise it terminates immediately
+            continue_split(split, pre_result, (FStmt*)/*FIXME type hack*/pre_result->get_next(), visited, false, true);
+        } else {
+            // This must be the "main" entry point
+            continue_split(split, nullptr, pre_result, visited, true, false);
+        }
+
+        FStmt* result = pre_result;
+        const BlockStmt *bs = dynamic_cast<const BlockStmt*>(pre_result);
+        if (bs == nullptr) {
+            result = new BlockStmt (nullptr, std::string(FlightplanConfig::FP_options.flightplanFolder), pre_result, nullptr, nullptr);
+        }
+        split->cleaved = result;
+        std::cout << "Done splitting" << std::endl;
+        return result;
+    }
+}
+
+}
diff --git a/frontends/p4/flightplan_annotate.cpp b/frontends/p4/flightplan_annotate.cpp
new file mode 100644
index 0000000..9ac0992
--- /dev/null
+++ b/frontends/p4/flightplan_annotate.cpp
@@ -0,0 +1,179 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+*/
+
+#include <iostream>
+#include <fstream>
+
+#include "lib/path.h"
+#include "lib/cstring.h"
+
+#include "flightplan.h"
+#include "flightplan_annotate.h"
+
+namespace P4 {
+
+std::map<std::string, std::unordered_set<std::string>> FlightplanAnnotate::SegExternMap;
+std::map<std::string, int> FlightplanAnnotate::SegLines;
+std::map<std::string, int> FlightplanAnnotate::AnnotLines;
+int FlightplanAnnotate::ProgLines = 0;
+std::map<std::string, std::string> FlightplanAnnotate::ExternIndex;
+int FlightplanAnnotate::NoJumps = 0;
+bool FlightplanAnnotate::FlyBack = false;
+std::set<std::pair<std::string,std::string>> FlightplanAnnotate::Links;
+std::string FlightplanAnnotate::segment_annotated_control_block;
+std::map<const FStmt*, std::unordered_set<std::string>> FlightplanAnnotate::statement_segment_map;
+
+
+void FlightplanAnnotate::Initialise() {
+  FlightplanAnnotate::add_segment(FlightplanConfig::landing_start);
+}
+
+int FlightplanAnnotate::NoSegments() {
+   return SegExternMap.size();
+}
+
+void FlightplanAnnotate::link(std::string from, std::string to) {
+  FlightplanAnnotate::Links.insert(std::pair<std::string,std::string>(from, to));
+}
+
+void FlightplanAnnotate::EmitResults() {
+  std::cout << "==[ Annotator ]==================" << std::endl;
+  std::cout << "FlightplanAnnotate::NoSegments " << FlightplanAnnotate::NoSegments() << std::endl;
+  std::cout << "FlightplanAnnotate::NoJumps " << FlightplanAnnotate::NoJumps << std::endl;
+  std::cout << "FlightplanAnnotate::ProgLines " << FlightplanAnnotate::ProgLines << std::endl;
+  std::cout << "|FlightplanAnnotate::statement_segment_map| " << FlightplanAnnotate::statement_segment_map.size() << std::endl;
+  std::cout << "Segment sizes: " << std::endl;
+  int total_prog_lines = 0;
+  int total_annot_lines = 0;
+  for (auto &segline : SegLines) {
+      std::cout << "    Segment " << segline.first << ": Orig lines=" << segline.second << " Annot lines=" << AnnotLines[segline.first] << std::endl;
+      total_prog_lines += segline.second;
+      total_annot_lines += AnnotLines[segline.first];
+  }
+  std::cout << "Total Prog lines " << total_prog_lines << std::endl;
+  std::cout << "Total Annot lines " << total_annot_lines << std::endl;
+
+  std::cout << "Segment arities: " << std::endl;
+  for (auto &segmap : SegExternMap) {
+      std::string segment_name = segmap.first;
+      int from = 0;
+      int to = 0;
+      for (std::pair<std::string,std::string> edge : Links) {
+          if (edge.first == segment_name) {
+              from++;
+          }
+          if (edge.second == segment_name) {
+              to++;
+          }
+      }
+      std::cout << "    Segment " << segment_name << ": from=" << from << " to=" << to << std::endl;
+  }
+
+  if (FlightplanConfig::FP_options.flightplan_DOT_output) {
+      const cstring destination = std::string(FlightplanConfig::FP_options.flightplanFolder + "/" + FlightplanConfig::adjusted_input_filename) + "_annotated.dot";
+      std::cout << "Annotator: writing DOT file:" << destination << std::endl;
+      if (!destination.isNullOrEmpty()) {
+          Util::PathName path(destination);
+          std::ostream *ost = new std::ofstream(path.toString(), std::ios_base::app);
+          *ost << FlightplanAnnotate::toDOT() << std::endl;
+      } else {
+          ::error("Null filename?");
+      }
+  }
+
+  const cstring destination = std::string(FlightplanConfig::FP_options.flightplanFolder + "/" + FlightplanConfig::adjusted_input_filename) + "_annotated.p4";
+  std::cout << "Annotator: writing annotated control-block code:" << destination << std::endl;
+  if (!destination.isNullOrEmpty()) {
+      Util::PathName path(destination);
+      std::ostream *ost = new std::ofstream(path.toString(), std::ios_base::app);
+      *ost << FlightplanAnnotate::segment_annotated_control_block << std::endl;
+  } else {
+      ::error("Null filename?");
+  }
+
+  std::cout << "=================================" << std::endl;
+}
+
+std::string FlightplanAnnotate::toDOT() {
+  std::string result = "digraph G {\ncompound=true;\n";
+  result += FlightplanConfig::landing_start + " [label=\"" + FlightplanConfig::landing_start + "\",color=white,fontcolor=blue];\n";
+  for (const auto& p : FlightplanAnnotate::Links) {
+    result += p.first + " -> " + p.second + ";\n";
+  }
+
+  for (const auto& p : FlightplanAnnotate::SegExternMap) {
+    if (p.first == FlightplanConfig::landing_start) {
+      continue;
+    }
+    result += "subgraph cluster_" + p.first + " {\n";
+    result += p.first + " [label=\"" + p.first + "\",color=white];\n";
+    result += "style=solid;\ncolor=lightgray;\nfontcolor=green;\n";
+
+    result += "subgraph cluster_" + p.first + " {\n";
+    result += "label=\"\";\nstyle=dotted;\ncolor=lightgray;\n";
+
+    for (const auto& extern_name : p.second) {
+      result += extern_name + " [label=\"" + extern_name + "\",color=white];\n";
+    }
+    result += "}\n}\n";
+  }
+
+  result += "}";
+  return result;
+}
+
+void FlightplanAnnotate::add_segment(std::string segment_name) {
+  if (FlightplanAnnotate::SegExternMap.find(segment_name) == FlightplanAnnotate::SegExternMap.end()) {
+      FlightplanAnnotate::SegExternMap.insert(std::pair<std::string,std::unordered_set<std::string>>(segment_name, std::unordered_set<std::string>()));
+      FlightplanAnnotate::SegLines.insert(std::pair<std::string,int>(segment_name, 0));
+      FlightplanAnnotate::AnnotLines.insert(std::pair<std::string,int>(segment_name, 0));
+  } else {
+    throw std::logic_error("add_segment for a segment that already exists");
+  }
+
+}
+
+std::string* FlightplanAnnotate::segment_of_extern(std::string extern_name) {
+  if ( FlightplanAnnotate::ExternIndex.find(extern_name) == FlightplanAnnotate::ExternIndex.end() ) {
+    return nullptr;
+  } else {
+    return &FlightplanAnnotate::ExternIndex[extern_name];
+  }
+}
+
+void FlightplanAnnotate::add_segment_extern(std::string segment_name, std::string extern_name) {
+  FlightplanAnnotate::SegExternMap[segment_name].insert(extern_name);
+  FlightplanAnnotate::ExternIndex.insert(std::pair<std::string,std::string>(extern_name, segment_name));
+}
+
+
+IR::MethodCallStatement* FlightplanAnnotate::flyto(std::string where_to) {
+    if (FlightplanConfig::flyto_expr == nullptr) {
+        auto params = new IR::IndexedVector<IR::Parameter>();
+        auto param = new IR::Parameter(IR::ID("dest", nullptr), IR::Direction::In,
+                                                new IR::Type_InfInt());
+        FlightplanConfig::FP_typeMap->setType(param, param->type);
+        params->push_back(param);
+        auto method_type = new IR::Type_Method(IR::Type_Void::get(), new IR::ParameterList(*params));
+        FlightplanConfig::flyto_expr = new IR::PathExpression(IR::ID(Util::SourceInfo(), FlightplanConfig::flyto_fn));
+
+        auto path = FlightplanConfig::flyto_expr->path;
+        auto decl = new IR::Method(IR::ID(FlightplanConfig::flyto_fn, nullptr), method_type);
+        FlightplanConfig::FP_refMap->setDeclaration(path, decl);
+        FlightplanConfig::FP_typeMap->setType(FlightplanConfig::flyto_expr, method_type);
+    }
+
+    auto landing = new IR::PathExpression(IR::ID(Util::SourceInfo(), where_to));
+    auto args = new IR::Vector<IR::Argument>();
+    auto landing_arg = new IR::Argument(landing);
+    args->push_back(landing_arg);
+    auto mc = new IR::MethodCallExpression(Util::SourceInfo(), FlightplanConfig::flyto_expr, args);
+    auto result = new IR::MethodCallStatement(mc->srcInfo, mc);
+
+    FlightplanConfig::FP_typeMap->setType(result, IR::Type_Void::get());
+    return result;
+}
+
+}
diff --git a/frontends/p4/flightplan_annotate.h b/frontends/p4/flightplan_annotate.h
new file mode 100644
index 0000000..9f0a891
--- /dev/null
+++ b/frontends/p4/flightplan_annotate.h
@@ -0,0 +1,208 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+
+NOTE must be executed after RemoveReturns, since we assume they've been removed.
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_ANNOTATE_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_ANNOTATE_H_
+
+#include <utility>
+#include <stdexcept>
+#include <string>
+#include <vector>
+#include <map>
+#include <unordered_set>
+
+#include "flightplan_externs.h"
+
+namespace P4 {
+
+namespace FlightplanAnnotate {
+   // Mapping from Segment to set of Externs
+   extern std::map<std::string, std::unordered_set<std::string>> SegExternMap;
+   extern int ProgLines;
+   extern std::map<std::string, int> SegLines;
+   extern std::map<std::string, int> AnnotLines;
+   // Mapping from Extern to the Segment in which it has been placed.
+   // NOTE an extern is mapped to a single segment.
+   extern std::map<std::string, std::string> ExternIndex;
+   // No. of jumps made so far.
+   extern int NoJumps;
+   // Whether we should fly back to FlightStart at the end of the program.
+   extern bool FlyBack;
+   // Graph of links between segments.
+   extern std::set<std::pair<std::string,std::string>> Links;
+   // Contains the main control-block code annotated with which segments are "active".
+   extern std::string segment_annotated_control_block;
+
+  //Mapping from statements to the set ofsegments they feature in
+   extern std::map<const FStmt*, std::unordered_set<std::string>> statement_segment_map;
+
+   int NoSegments();
+
+   // Generates P4 AST for flyto a particular Segment.
+   IR::MethodCallStatement* flyto(std::string where_to);
+
+   // Run this once to bring FlightplanAnnotate data structures into initial state.
+   void Initialise();
+
+   // Produce stats related to the annotated program (e.g., number of links).
+   void EmitResults();
+
+   // Link two segments. (This is directed.)
+   void link(std::string from, std::string to);
+
+   // Generate DOT representation of the topology of segments.
+   std::string toDOT();
+
+   // Add a new segment.
+   void add_segment(std::string segment_name);
+
+   // Resolve the Segment to which an extern has been mapped.
+   std::string* segment_of_extern(std::string extern_name);
+
+   // Add an extern to an existing Segment.
+   void add_segment_extern(std::string segment_name, std::string extern_name);
+
+   class Tippy {
+      int generation = 0;
+      int jumps_so_far = 0;
+      Tippy* parent = nullptr;
+      std::vector<Tippy*> children;
+      using SegExternMap = std::map<std::string, std::string>;
+      // The set of Segments we currently might be in, and the last extern that was
+      // called in each one. We use the latter info to find out whether we can "bunch".
+      SegExternMap map;
+      Tippy() {}
+      bool active = true;
+      void deactive() {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          active = false;
+          for (Tippy* child : children) {
+             delete child;
+          }
+          children.clear();
+      }
+    public:
+      void incrementJump() {
+         jumps_so_far++;
+      }
+      int getJumps() const {
+         return jumps_so_far;
+      }
+      bool isActive() {
+         return active;
+      }
+      void widen_tip(std::string segment_name, std::string extern_name) {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          map.insert(std::pair<std::string,std::string>(segment_name, extern_name));
+      }
+      void clear() {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          map.clear();
+      }
+      void retip(std::string segment_name, std::string extern_name) {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          clear();
+          widen_tip(segment_name, extern_name);
+      }
+      void retip_externonly(std::string extern_name) {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          for (auto &tip : map) {
+              map[tip.first] = extern_name;
+          }
+      }
+      void retip_flightstart() {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          retip(FlightplanConfig::landing_start, "");
+      }
+      static Tippy* Initial() {
+          Tippy* t = new Tippy();
+          t->retip_flightstart();
+          return t;
+      }
+      Tippy* sprout() {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          Tippy* t = new Tippy();
+          t->parent = this;
+          t->map = map;
+          t->generation = generation + 1;
+          t->jumps_so_far = jumps_so_far;
+          children.push_back(t);
+          return t;
+      }
+      std::vector<Tippy*> sprout(int n) {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          std::vector<Tippy*> result;
+          for (int i = 0; i < n; ++i) {
+             result.push_back(sprout());
+          }
+          return result;
+      }
+      void fuse() {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+          for (auto &tip : map) {
+             parent->widen_tip(tip.first, tip.second);
+             if (jumps_so_far > parent->jumps_so_far) {
+                 parent->jumps_so_far = jumps_so_far;
+             }
+          }
+	  deactive();
+      }
+      void chop() {
+          if (!active) {
+             throw std::logic_error("Stale tip");
+          }
+	  deactive();
+      }
+      bool are_definitely_on_FlightStart() {
+        if ((map.size() == 1) && (map.find(FlightplanConfig::landing_start) != map.end())) {
+              // FIXME assert(FlightplanAnnotate::SegExternMap[FlightplanConfig::landing_start] == std::string(""));
+              return true;
+        }
+        return false;
+      }
+      SegExternMap getTip() {
+          return map;
+      }
+      std::string toString() {
+          std::string result;
+          result += " (" + std::to_string(generation) + ") ";
+          result += "{";
+          for (auto &p : map) {
+              result += p.first + "|->" + p.second + " ";
+          }
+          return result + "}";
+      }
+      int getGeneration() {
+          return generation;
+      }
+   };
+
+   void Occur(const FStmt* fstmt, Tippy* state);
+
+} // namespace FlightplanAnnotate
+
+}  // namespace P4
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_ANNOTATE_H_ */
diff --git a/frontends/p4/flightplan_annotator.cpp b/frontends/p4/flightplan_annotator.cpp
new file mode 100644
index 0000000..8859e5b
--- /dev/null
+++ b/frontends/p4/flightplan_annotator.cpp
@@ -0,0 +1,655 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+*/
+
+#include "flightplan_preanalysis.h"
+#include "flightplan_annotator.h"
+
+namespace P4 {
+
+bool calls_table_lookup(const IR::MethodCallStatement* mcs) {
+    const IR::MethodCallExpression* mce = mcs->methodCall;
+    auto mi = P4::MethodInstance::resolve(mce, FlightplanConfig::FP_refMap, FlightplanConfig::FP_typeMap);
+    if (mi->is<P4::ApplyMethod>()) {
+        auto application = mi->to<P4::ApplyMethod>();
+        return application->isTableApply();
+    } else {
+        return false;
+    }
+}
+
+std::string table_lookup_string(const IR::MethodCallStatement* mcs) {
+    const IR::MethodCallExpression* mce = mcs->methodCall;
+    auto mi = P4::MethodInstance::resolve(mce, FlightplanConfig::FP_refMap, FlightplanConfig::FP_typeMap);
+    if (mi->is<P4::ApplyMethod>()) {
+        auto application = mi->to<P4::ApplyMethod>();
+        if (application->isTableApply()) {
+            return std::string(mce->toString());
+        }
+    }
+    throw std::logic_error("table_lookup_string() called on non-table-lookup");
+}
+
+// FIXME there are opportunities to use this function more frequently in the code of Flightplan_Annotator::visit functions
+FStmt* fly_before_stmt(std::string destination, FStmt* fstmt, FlightplanAnnotate::Tippy* state, bool in_place = false) {
+    // Jump BEFORE the statement
+    FStmt* stmt_copy = nullptr;
+    if (!in_place) {
+      stmt_copy = fstmt->clone();
+    } else {
+      stmt_copy = fstmt;
+    }
+    assert(stmt_copy != nullptr);
+    auto dest_path = std::string(FlightplanConfig::FP_options.flightplanFolder);
+    state->incrementJump();
+    FStmt* jump = new Stmt (fstmt->getContainer(), dest_path, FlightplanAnnotate::flyto(destination), nullptr, stmt_copy);
+    if (in_place) {
+      if (stmt_copy->get_prev() != nullptr) {
+        stmt_copy->get_prev()->set_next(jump);
+      }
+      jump->set_prev(stmt_copy->get_prev());
+      jump->set_next(stmt_copy);
+      stmt_copy->set_prev(jump);
+    } else {
+      stmt_copy->set_prev(jump);
+      stmt_copy->set_next(nullptr);
+    }
+    for (const auto& p : state->getTip()) {
+      FlightplanAnnotate::link(p.first, destination);
+      FlightplanAnnotate::AnnotLines[p.first] += 1;
+    }
+    state->retip_flightstart();
+    return new BlockStmt (fstmt->getContainer(), dest_path, jump, fstmt->get_prev(), fstmt->get_next());
+}
+
+FStmt* fly_FlightStart_before_stmt(FStmt* fstmt, FlightplanAnnotate::Tippy* state) {
+    // Jump BEFORE the statement
+    FStmt* stmt_copy = fstmt->clone();
+    auto dest_path = std::string(FlightplanConfig::FP_options.flightplanFolder);
+    state->incrementJump();
+    FStmt* jump = new Stmt (fstmt->getContainer(), dest_path, FlightplanAnnotate::flyto(FlightplanConfig::landing_start), nullptr, stmt_copy);
+    stmt_copy->set_prev(jump);
+    stmt_copy->set_next(nullptr);
+    for (const auto& p : state->getTip()) {
+      FlightplanAnnotate::link(p.first, FlightplanConfig::landing_start);
+      FlightplanAnnotate::AnnotLines[p.first] += 1;
+    }
+    state->retip_flightstart();
+    return new BlockStmt (fstmt->getContainer(), dest_path, jump, fstmt->get_prev(), fstmt->get_next());
+}
+
+FStmt* fly_FlightStart_after_stmt(FStmt* fstmt, FlightplanAnnotate::Tippy* state) {
+    // Jump AFTER the statement
+    FStmt* stmt_copy = fstmt->clone();
+    auto dest_path = std::string(FlightplanConfig::FP_options.flightplanFolder);
+    state->incrementJump();
+    FStmt* jump = new Stmt (fstmt->getContainer(), dest_path, FlightplanAnnotate::flyto(FlightplanConfig::landing_start), stmt_copy, nullptr);
+    stmt_copy->set_prev(nullptr);
+    stmt_copy->set_next(jump);
+    for (const auto& p : state->getTip()) {
+      FlightplanAnnotate::link(p.first, FlightplanConfig::landing_start);
+      FlightplanAnnotate::AnnotLines[p.first] += 1;
+    }
+    state->retip_flightstart();
+    return new BlockStmt (fstmt->getContainer(), dest_path, stmt_copy, fstmt->get_prev(), fstmt->get_next());
+}
+
+void append_indentation(FlightplanAnnotate::Tippy* state) {
+    for (int i = 0; i < state->getGeneration(); ++i) {
+      FlightplanAnnotate::segment_annotated_control_block += "  ";
+    }
+}
+
+void append_analysis_metadata(FlightplanAnnotate::Tippy* state) {
+    FlightplanAnnotate::segment_annotated_control_block += "// width=" +
+	    std::to_string(state->getTip().size()) + ": " + state->toString() + "\n";
+}
+
+void FlightplanAnnotate::Occur(const FStmt* fstmt, FlightplanAnnotate::Tippy* state) {
+    if (FlightplanAnnotate::statement_segment_map.find(fstmt) == FlightplanAnnotate::statement_segment_map.end()) {
+        std::unordered_set<std::string> emptyset;
+        FlightplanAnnotate::statement_segment_map.insert(std::pair<const FStmt*, std::unordered_set<std::string>>(fstmt, emptyset));
+    }
+
+    for (auto &tip : state->getTip()) {
+        FlightplanAnnotate::statement_segment_map[fstmt].insert(tip.first);
+    }
+}
+
+FStmt* Flightplan_Annotator::visit(Stmt* fstmt, FlightplanAnnotate::Tippy* state) {
+    Occur(fstmt, state);
+
+    FlightplanAnnotate::ProgLines += 1;
+
+    StatementAnalysisMetadata metadata(fstmt, getAnalysisState(), state);
+
+    append_indentation(state);
+    append_analysis_metadata(state);
+    append_indentation(state);
+    FlightplanAnnotate::segment_annotated_control_block += metadata.toString();
+    append_indentation(state);
+    FlightplanAnnotate::segment_annotated_control_block += fstmt->toP4String();
+    FlightplanAnnotate::segment_annotated_control_block += " /* " + fstmt->original->getSourceInfo().toPositionString() + " */\n";
+
+    //Check statement for expression involving metadata (ingress/egress ports)
+    if (!FlightplanConfig::FP_options.flightplan_headered) {
+        if (metadata.jumps != 0 && metadata.ingress) {
+            throw std::logic_error("Unsplittable: cannot access ingress post-jump -- " + fstmt->original->getSourceInfo().toPositionString());
+        }
+        if (metadata.egress || metadata.ingress) {
+          if (!FlightplanExterns::excepted_subset(metadata.remaining_externs).empty()) {
+            throw std::logic_error("Unsplittable: cannot access ingress/egress pre-extern -- " + fstmt->original->getSourceInfo().toPositionString());
+          } else {
+              if (state->are_definitely_on_FlightStart()) {
+                  std::cout << "Annotator: already in FlightStart at metadata-changing: " << fstmt->toP4String() << std::endl;
+                  for (auto &tip : state->getTip()) {
+                      FlightplanAnnotate::SegLines[tip.first] += 1;
+                  }
+                  return fstmt->clone();
+              } else {
+                  std::cout << "Annotator: flyto(FlightStart) because of metadata-changing: " << fstmt->toP4String() << std::endl;
+                  FlightplanAnnotate::SegLines[FlightplanConfig::landing_start] += 1;
+                  return fly_FlightStart_before_stmt(fstmt, state);
+              }
+          }
+        }
+    } else {
+        if (metadata.egress) {
+             FlightplanAnnotate::FlyBack = true;
+        }
+    }
+
+    auto pre_statement = fstmt->original;
+    if (pre_statement->is<IR::Declaration>()) {
+        for (auto &tip : state->getTip()) {
+            FlightplanAnnotate::SegLines[tip.first] += 1;
+        }
+        return fstmt->clone();
+    } else if (pre_statement->is<IR::Statement>()) {
+        auto stmt = &pre_statement->as<IR::Statement>();
+
+        if (stmt->is<IR::MethodCallStatement>()) {
+            auto mcs = &stmt->as<IR::MethodCallStatement>();
+
+            if (calls_table_lookup(mcs)) {
+                if (FlightplanConfig::FP_options.flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::Features) {
+                  // Check if this table lookup is one of the features we've been asked to offload
+                  for (std::string table_name : FlightplanConfig::FP_options.flightplan_table_offload) {
+                      if (table_name + "." + IR::IApply::applyMethodName == table_lookup_string(mcs)) {
+                          std::cout << "Annotator: feature offload: table " << table_name << std::endl;
+                           std::string segment_name = "Offload"/*FIXME const*/;
+                          FlightplanAnnotate::add_segment(segment_name);
+
+                          // FIXME gather both flyto's into the same block, currently it looks a bit odd (but it's semantically fine).
+                          auto pre_result = fly_before_stmt(segment_name, fstmt, state, true);
+                          return fly_FlightStart_after_stmt((FStmt*)pre_result, state);
+                      }
+                  }
+#if 0
+#endif
+                } else {
+                  if (state->are_definitely_on_FlightStart()) {
+                      std::cout << "Annotator: already in FlightStart at table lookup: " << table_lookup_string(mcs) << std::endl;
+                      for (auto &tip : state->getTip()) {
+                          FlightplanAnnotate::SegLines[tip.first] += 1;
+                      }
+                      return fstmt->clone();
+                  } else {
+                      std::cout << "Annotator: flyto(FlightStart) because of table lookup: " << table_lookup_string(mcs) << std::endl;
+                      FlightplanAnnotate::SegLines[FlightplanConfig::landing_start] += 1;
+                      return fly_FlightStart_before_stmt(fstmt, state);
+                  }
+                }
+            }
+
+            auto dest_path = std::string(FlightplanConfig::FP_options.flightplanFolder);
+            auto container = fstmt->container;
+            auto prev = fstmt->get_prev();
+            auto next = fstmt->get_next();
+            std::string segment_name;
+
+            if (FlightplanExterns::calls_extern_function(mcs)) {
+                auto extern_name = FlightplanExterns::extern_function_name(mcs);
+                if (FlightplanConfig::FP_options.flightplan_exclusions.find(extern_name) != FlightplanConfig::FP_options.flightplan_exclusions.end()) {
+                    if (state->are_definitely_on_FlightStart()) {
+                        std::cout << "Annotator: already in FlightStart at excluded extern: " << extern_name << std::endl;
+                        for (auto &tip : state->getTip()) {
+                            FlightplanAnnotate::SegLines[tip.first] += 1;
+                        }
+                        return fstmt->clone();
+                    } else {
+                        std::cout << "Annotator: flyto(FlightStart) because of excluded extern: " << extern_name << std::endl;
+                        for (auto &tip : state->getTip()) {
+                            FlightplanAnnotate::AnnotLines[tip.first] += 1;
+                        }
+                        FlightplanAnnotate::SegLines[FlightplanConfig::landing_start] += 1;
+                        return fly_FlightStart_before_stmt(fstmt, state);
+                    }
+                }
+
+                // Check for bunching
+                bool can_bunch = true;
+                bool not_vacuous = false;
+                for (auto &tip : state->getTip()) {
+                    std::string previous_E = tip.second;
+                    bool bunchable = false;
+                    for (auto &bunch : FlightplanConfig::FP_options.flightplan_bunched) {
+                        not_vacuous = true;
+                        if (bunch.find(extern_name) != bunch.end() && bunch.find(previous_E) != bunch.end()) {
+                            bunchable = true;
+                        } else {
+                            bunchable = false;
+                        }
+
+                        if (!bunchable) {
+                            can_bunch = false;
+                            break;
+                        }
+                    }
+                    if (!can_bunch) {
+                        break;
+                    }
+                }
+
+                if (can_bunch && not_vacuous) {
+                    std::cout << "Annotator: bunching the call to " << extern_name << std::endl;
+                    for (auto &tip : state->getTip()) {
+                        FlightplanAnnotate::SegLines[tip.first] += 1;
+                        FlightplanAnnotate::add_segment_extern(tip.first, extern_name);
+                    }
+                    state->retip_externonly(extern_name);
+                    return fstmt->clone();
+                }
+
+                auto orig_stmt = new Stmt (container, dest_path, mcs, prev, next);
+                auto suffix = std::to_string(FlightplanAnnotate::NoSegments());
+                auto looked_up = FlightplanAnnotate::segment_of_extern(extern_name);
+                if (nullptr == looked_up) {
+                  segment_name = "Segment_" + suffix;
+                } else {
+                  segment_name = *looked_up;
+                }
+
+                switch (FlightplanConfig::FP_options.flightplan_annotation_mode) {
+                    case CompilerOptions::FlightplanAnnotationMode::Features:
+                        {
+                            return fstmt->clone();
+                        }
+                    case CompilerOptions::FlightplanAnnotationMode::EagerOffload:
+                        {
+                            state->incrementJump();
+                            auto flyto_segment_stmt = new Stmt (container, dest_path, FlightplanAnnotate::flyto(segment_name), prev, orig_stmt);
+                            orig_stmt->set_prev(flyto_segment_stmt);
+
+                            orig_stmt->set_next(nullptr);
+                            flyto_segment_stmt->set_next(orig_stmt);
+                            flyto_segment_stmt->set_prev(nullptr);
+
+                            state->incrementJump();
+                            orig_stmt->set_next(new Stmt (container, dest_path, FlightplanAnnotate::flyto(FlightplanConfig::landing_start), orig_stmt, nullptr));
+
+                            if (nullptr == looked_up) {
+                              FlightplanAnnotate::add_segment(segment_name);
+                              FlightplanAnnotate::add_segment_extern(segment_name, extern_name);
+                              std::cout << "New segment " << segment_name << " |-> " << extern_name << std::endl;
+                            }
+
+                            for (const auto& p : state->getTip()) {
+                              FlightplanAnnotate::link(p.first, segment_name);
+                              FlightplanAnnotate::AnnotLines[p.first] += 1;
+                            }
+                            state->retip(segment_name, extern_name);
+                            FlightplanAnnotate::NoJumps += 1;
+                            FlightplanAnnotate::SegLines[segment_name] += 1;
+                            FlightplanAnnotate::link(segment_name, FlightplanConfig::landing_start);
+                            state->retip_flightstart();
+                            FlightplanAnnotate::NoJumps += 1;
+                            FlightplanAnnotate::AnnotLines[segment_name] += 1;
+
+                            return new BlockStmt (container, dest_path, flyto_segment_stmt, prev, next);
+                        }
+                    case CompilerOptions::FlightplanAnnotationMode::InertialOffload:
+                        {
+                            FStmt* jump_to_flightstart = nullptr;
+                            if (!state->are_definitely_on_FlightStart()) {
+                                std::cout << "Annotator: flyto(FlightStart) just before inertial offload" << std::endl;
+
+                                FlightplanAnnotate::NoJumps += 1;
+
+                                auto dest_path = std::string(FlightplanConfig::FP_options.flightplanFolder);
+                                state->incrementJump();
+                                jump_to_flightstart = new Stmt (fstmt->getContainer(), dest_path, FlightplanAnnotate::flyto(FlightplanConfig::landing_start), nullptr, nullptr);
+                                for (const auto& p : state->getTip()) {
+                                  FlightplanAnnotate::link(p.first, FlightplanConfig::landing_start);
+                                  FlightplanAnnotate::AnnotLines[p.first] += 1;
+                                }
+                                state->retip_flightstart();
+                            }
+
+                            FStmt* block_start = nullptr;
+                            FStmt* flyto_segment_stmt = nullptr;
+			    if (jump_to_flightstart != nullptr) {
+                                   block_start = jump_to_flightstart;
+                                   state->incrementJump();
+				   flyto_segment_stmt = new Stmt (container, dest_path, FlightplanAnnotate::flyto(segment_name), jump_to_flightstart, orig_stmt);
+                                   jump_to_flightstart->set_next(flyto_segment_stmt);
+			    } else {
+                                   state->incrementJump();
+				   flyto_segment_stmt = new Stmt (container, dest_path, FlightplanAnnotate::flyto(segment_name), nullptr, orig_stmt);
+                                   block_start = flyto_segment_stmt;
+			    }
+
+                            orig_stmt->set_prev(flyto_segment_stmt);
+                            orig_stmt->set_next(nullptr);
+                            flyto_segment_stmt->set_next(orig_stmt);
+
+                            FlightplanAnnotate::NoJumps += 1;
+                            FlightplanAnnotate::AnnotLines[FlightplanConfig::landing_start] += 1;
+
+                            if (nullptr == looked_up) {
+                              FlightplanAnnotate::add_segment(segment_name);
+                              FlightplanAnnotate::add_segment_extern(segment_name, extern_name);
+                              std::cout << "New segment " << segment_name << " |-> " << extern_name << std::endl;
+                            }
+                            FlightplanAnnotate::SegLines[segment_name] += 1;
+
+                            FlightplanAnnotate::link(FlightplanConfig::landing_start, segment_name);
+                            state->retip(segment_name, extern_name);
+
+                            return new BlockStmt (container, dest_path, block_start, prev, next);
+                        }
+                    case CompilerOptions::FlightplanAnnotationMode::Chain:
+                        {
+                            state->incrementJump();
+                            auto flyto_segment_stmt = new Stmt (container, dest_path, FlightplanAnnotate::flyto(segment_name), prev, orig_stmt);
+                            orig_stmt->set_prev(flyto_segment_stmt);
+
+                            orig_stmt->set_next(nullptr);
+                            flyto_segment_stmt->set_next(orig_stmt);
+                            flyto_segment_stmt->set_prev(nullptr);
+
+                            if (nullptr == looked_up) {
+                              FlightplanAnnotate::add_segment(segment_name);
+                              FlightplanAnnotate::add_segment_extern(segment_name, extern_name);
+                              std::cout << "New segment " << segment_name << " |-> " << extern_name << std::endl;
+                            }
+                            FlightplanAnnotate::NoJumps += 1;
+                            FlightplanAnnotate::SegLines[segment_name] += 1;
+
+                            for (const auto& p : state->getTip()) {
+                              FlightplanAnnotate::link(p.first, segment_name);
+                              FlightplanAnnotate::AnnotLines[p.first] += 1;
+                            }
+                            state->retip(segment_name, extern_name);
+
+                            return new BlockStmt (container, dest_path, flyto_segment_stmt, prev, next);
+                        }
+                    default:
+                        throw std::logic_error("Impossible");
+                }
+
+
+                state->incrementJump();
+                auto flyto_segment_stmt = new Stmt (container, dest_path, FlightplanAnnotate::flyto(segment_name), prev, orig_stmt);
+                orig_stmt->set_prev(flyto_segment_stmt);
+
+                orig_stmt->set_next(nullptr);
+                flyto_segment_stmt->set_next(orig_stmt);
+                flyto_segment_stmt->set_prev(nullptr);
+
+                state->incrementJump();
+                orig_stmt->set_next(new Stmt (container, dest_path, FlightplanAnnotate::flyto(FlightplanConfig::landing_start), orig_stmt, nullptr));
+
+                if (nullptr == looked_up) {
+                  FlightplanAnnotate::add_segment(segment_name);
+                  FlightplanAnnotate::add_segment_extern(segment_name, extern_name);
+                  std::cout << "New segment " << segment_name << " |-> " << extern_name << std::endl;
+                }
+                FlightplanAnnotate::NoJumps += 2;
+
+                for (const auto& p : state->getTip()) {
+                  FlightplanAnnotate::link(p.first, segment_name);
+                }
+                state->retip(segment_name, extern_name);
+                FlightplanAnnotate::link(segment_name, FlightplanConfig::landing_start);
+                state->retip_flightstart();
+
+                return new BlockStmt (container, dest_path, flyto_segment_stmt, prev, next);
+            }
+
+            return new Stmt (container, dest_path, mcs, prev, next);
+        } else if (stmt->is<IR::ReturnStatement>() || stmt->is<IR::ExitStatement>() || ForwardStatementGatherer::sets_hasReturned(stmt)) {
+            append_indentation(state);
+            FlightplanAnnotate::segment_annotated_control_block += "// End of path\n";
+            if (!state->are_definitely_on_FlightStart() &&
+                    (FlightplanAnnotate::FlyBack ||
+                     FlightplanConfig::FP_options.flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::EagerOffload ||
+                     FlightplanConfig::FP_options.flightplan_annotation_mode == CompilerOptions::FlightplanAnnotationMode::InertialOffload)) {
+                    std::cout << "Annotator: returning to FlightStart because of Offload mode or FlyBack" << std::endl;
+                    for (auto &tip : state->getTip()) {
+                        FlightplanAnnotate::AnnotLines[tip.first] += 1;
+                    }
+                    FlightplanAnnotate::SegLines[FlightplanConfig::landing_start] += 1;
+                    auto result = fly_FlightStart_before_stmt(fstmt, state);
+                    state->chop();
+                    return result;
+            } else {
+                for (auto &tip : state->getTip()) {
+                    FlightplanAnnotate::SegLines[tip.first] += 1;
+                }
+                state->chop();
+                return fstmt->clone();
+            }
+        } else {
+            for (auto &tip : state->getTip()) {
+                FlightplanAnnotate::SegLines[tip.first] += 1;
+            }
+            return fstmt->clone();
+        }
+    }
+
+    throw std::logic_error("Impossible");
+}
+
+bool is_sought_header_type_guard(const IR::Expression* expr) {
+    if (expr->is<IR::MethodCallExpression>()) {
+       auto mce = &expr->as<IR::MethodCallExpression>();
+       if (mce->method->is<IR::Member>()) {
+           auto member = &mce->method->as<IR::Member>();
+
+           if (std::string(member->member.originalName) == std::string(IR::Type_Header::isValid)) {
+               if (member->expr->is<IR::ArrayIndex>()) {
+                   auto ai = &member->expr->as<IR::ArrayIndex>();
+
+                   if (ai->type->is<IR::Type_Header>()) {
+                       auto tyh = &ai->type->as<IR::Type_Header>();
+
+                       for (std::string header_type : FlightplanConfig::FP_options.flightplan_header_offload) {
+                           if (header_type == std::string(tyh->getName().originalName)) {
+                               return true;
+                           }
+                       }
+                   }
+               }
+           }
+       }
+    }
+    return false;
+}
+
+FStmt* Flightplan_Annotator::visit(BlockStmt* fstmt, FlightplanAnnotate::Tippy* state) {
+    Occur(fstmt, state);
+    BlockStmt* result = (BlockStmt*)fstmt->clone();
+
+    FStmt* cursor = fstmt->getEntry();
+    FStmt* prev = nullptr;
+    result->setEntry(nullptr);
+
+    auto this_state = state->sprout();
+
+    append_indentation(state);
+    FlightplanAnnotate::segment_annotated_control_block += "{\n";
+
+    //rewrite prev + next as we go along
+    while (cursor != nullptr) {
+        FStmt* subresult = process(cursor, this_state);
+        subresult->set_next(nullptr);
+        subresult->container = result;
+        if (result->getEntry() == nullptr) {
+            result->setEntry(subresult);
+            assert(prev == nullptr);
+            subresult->set_prev(nullptr);
+        } else {
+            assert(prev != nullptr);
+            prev->set_next(subresult);
+            subresult->set_prev(prev);
+        }
+
+        if (!this_state->isActive()) {
+            break;
+        }
+
+        prev = subresult;
+        cursor = cursor->next;
+    }
+
+    if (this_state->isActive()) {
+        this_state->fuse();
+    }
+
+    append_indentation(state);
+    FlightplanAnnotate::segment_annotated_control_block += "}\n";
+
+    // Do the post-program process (i.e., after the last line of the program)
+    if (state->getGeneration() == 0) {
+        assert(fstmt->get_next() == nullptr);
+        std::cout << "Annotator: calling end-of-program handler" << std::endl;
+        FlightplanAnnotate::segment_annotated_control_block += "// Ending the program";
+
+        switch (FlightplanConfig::FP_options.flightplan_annotation_mode) {
+            case CompilerOptions::FlightplanAnnotationMode::Features:
+            case CompilerOptions::FlightplanAnnotationMode::EagerOffload:
+            {
+              assert(state->are_definitely_on_FlightStart());
+              break;
+            }
+            case CompilerOptions::FlightplanAnnotationMode::InertialOffload:
+            {
+              if (state->are_definitely_on_FlightStart()) {
+                  std::cout << "Annotator: already in FlightStart at end-of-program." << std::endl;
+                  break;
+              } else {
+                  std::cout << "Annotator: flyto(FlightStart) at end-of-program" << std::endl;
+                  return fly_FlightStart_after_stmt(result, state);
+              }
+            }
+            case CompilerOptions::FlightplanAnnotationMode::Chain:
+            {
+              if (FlightplanAnnotate::FlyBack) {
+                if (state->are_definitely_on_FlightStart()) {
+                    std::cout << "Annotator: already in FlightStart at end-of-program." << std::endl;
+                } else {
+                    std::cout << "Annotator: flyto(FlightStart) at end-of-program" << std::endl;
+                    return fly_FlightStart_after_stmt(result, state);
+                }
+              }
+              break;
+            }
+            default:
+                throw std::logic_error("Impossible");
+        }
+
+    }
+
+    return result;
+}
+
+FStmt* Flightplan_Annotator::visit(IfStmt* fstmt, FlightplanAnnotate::Tippy* state) {
+    Occur(fstmt, state);
+    if (is_sought_header_type_guard(fstmt->getCondition())) {
+        std::cout << "Annotator: feature offload: header " << FStmt::toP4String(fstmt->getCondition()) << std::endl;
+        // FIXME look instead fstmt to find out of the offload can indeed occur -- e.g., must not reference state that cannot easily be moved to the other target.  
+        std::string segment_name = "Offload"/*FIXME const*/;
+        FlightplanAnnotate::add_segment(segment_name);
+        // FIXME gather both flyto's into the same block, currently it looks a bit odd (but it's semantically fine).
+        auto pre_result = fly_before_stmt(segment_name, fstmt, state, true);
+        return fly_FlightStart_after_stmt((FStmt*)pre_result, state);
+    }
+
+    IfStmt* result = (IfStmt*)fstmt->clone();
+    std::vector<FlightplanAnnotate::Tippy*> this_state = state->sprout(2);
+
+    FlightplanAnnotate::segment_annotated_control_block += "\n";
+    append_indentation(state);
+    append_analysis_metadata(state);
+    append_indentation(state);
+    FlightplanAnnotate::segment_annotated_control_block += "if (";
+    FlightplanAnnotate::segment_annotated_control_block += FStmt::toP4String(fstmt->getCondition());
+    FlightplanAnnotate::segment_annotated_control_block += ")\n";
+
+    assert (result->ifTrue != nullptr);
+    result->ifTrue = process(fstmt->ifTrue, this_state[0]);
+
+    if (result->ifFalse != nullptr) {
+        append_indentation(state);
+        FlightplanAnnotate::segment_annotated_control_block += "else\n";
+        result->ifFalse = process(fstmt->ifFalse, this_state[1]);
+    }
+
+    state->clear();
+
+    for (auto &branch_state : this_state) {
+        if (branch_state->isActive()) {
+            branch_state->fuse();
+        }
+    }
+
+    return result;
+}
+
+FStmt* Flightplan_Annotator::visit(SwitchStmt* fstmt, FlightplanAnnotate::Tippy* state) {
+    Occur(fstmt, state);
+    SwitchStmt* result = (SwitchStmt*)fstmt->clone();
+    std::vector<SwitchStmt::Case> cases = fstmt->getCases();
+    std::vector<FlightplanAnnotate::Tippy*> this_state = state->sprout(cases.size());
+
+    FlightplanAnnotate::segment_annotated_control_block += "\n";
+    append_indentation(state);
+    append_analysis_metadata(state);
+    append_indentation(state);
+    FlightplanAnnotate::segment_annotated_control_block += "switch (";
+    FlightplanAnnotate::segment_annotated_control_block += FStmt::toP4String(fstmt->getExpression());
+    FlightplanAnnotate::segment_annotated_control_block += ") {\n";
+
+    for (unsigned int i = 0; i < cases.size(); ++i) {
+        append_indentation(state);
+        FlightplanAnnotate::segment_annotated_control_block += "case ";
+        FlightplanAnnotate::segment_annotated_control_block += FStmt::toP4String(cases[i].getLabel());
+        FlightplanAnnotate::segment_annotated_control_block += ":\n";
+        result->setCaseStatement(i, process((FStmt*)cases[i].get_fstmt(), this_state[i]));
+    }
+
+    append_indentation(state);
+    FlightplanAnnotate::segment_annotated_control_block += "}\n";
+
+    state->clear();
+
+    for (auto &branch_state : this_state) {
+        if (branch_state->isActive()) {
+            branch_state->fuse();
+        }
+    }
+
+    return result;
+}
+
+FStmt* Flightplan_Annotator::visit(EntryPoint*, FlightplanAnnotate::Tippy*) {
+    throw std::logic_error("Unsupported");
+}
+
+FStmt* Flightplan_Annotator::visit(TransferPoint*, FlightplanAnnotate::Tippy*) {
+    throw std::logic_error("Unsupported");
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan_annotator.h b/frontends/p4/flightplan_annotator.h
new file mode 100644
index 0000000..e49dda2
--- /dev/null
+++ b/frontends/p4/flightplan_annotator.h
@@ -0,0 +1,373 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_ANNOTATOR_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_ANNOTATOR_H_
+
+#include <queue>
+#include <string>
+#include <vector>
+
+#include "flightplan_annotate.h"
+#include "flightplan_convert.h"
+
+namespace P4 {
+class AnalysisState {
+ private:
+  bool self_created_relation = false;
+  unsigned long num_of_statements = 0;
+  unsigned long num_of_paths = 1;
+  std::map<const FStmt*, unsigned long>* path_occurrences;
+ public:
+  using seq_relation = std::map<const FStmt*, std::set<const FStmt*>>;
+  seq_relation* relation;
+
+  std::set<const FStmt*>* pending;
+
+  AnalysisState() {
+    relation = new std::map<const FStmt*, std::set<const FStmt*>>();
+    path_occurrences = new std::map<const FStmt*, unsigned long>();
+    self_created_relation = true;
+    this->relation = relation;
+    pending = new std::set<const FStmt*>();
+  }
+  AnalysisState(seq_relation* relation) {
+    this->relation = relation;
+    pending = new std::set<const FStmt*>();
+    path_occurrences = new std::map<const FStmt*, unsigned long>();
+  }
+  AnalysisState(seq_relation* relation, std::set<const FStmt*>* pending) {
+    this->relation = relation;
+    this->pending = pending;
+  }
+  ~AnalysisState() {
+    if (self_created_relation) {
+        delete relation;
+        delete path_occurrences;
+    }
+    delete pending;
+  }
+  AnalysisState* clone() {
+    AnalysisState* as = new AnalysisState(relation);
+    as->path_occurrences = this->path_occurrences;
+    as->num_of_paths = this->num_of_paths; // Paths continue to flow
+    as->num_of_statements = 0; // Count of statements is reset, to avoid double-counting statements after a branch.
+    for (auto &from_pending : *this->pending) {
+      as->pending->insert(from_pending);
+    }
+    return as;
+  }
+  void incrementStatements() {
+    this->num_of_statements++;
+  }
+  void incrementPaths() {
+    this->num_of_paths++;
+  }
+  void resetNumOfPaths() {
+    // This is called before a set of merges from nested statements (i.e., if or switch)
+    this->num_of_paths = 0;
+  }
+  void Occur(const FStmt* fstmt) {
+    assert(path_occurrences->find(fstmt) == path_occurrences->end());
+    path_occurrences->insert(std::pair<const FStmt*, unsigned long>(fstmt, num_of_paths));
+  }
+  unsigned long NoOccurances(const FStmt* fstmt) {
+    return (*path_occurrences)[fstmt];
+  }
+  void merge(AnalysisState* from) {
+    assert(from->relation == this->relation);
+    this->num_of_paths += from->num_of_paths;
+    this->num_of_statements += from->num_of_statements;
+    for (auto &from_pending : *from->pending) {
+      this->pending->insert(from_pending);
+    }
+  }
+  std::set<const FStmt*> transitive_closure(const FStmt* fstmt) {
+    std::set<const FStmt*> result;
+    std::queue<const FStmt*> pending;
+    std::set<const FStmt*> visited;
+
+    pending.push(fstmt);
+    while (!pending.empty()) {
+      const FStmt* elem = pending.front();
+      pending.pop();
+
+      if (visited.find(elem) == visited.end()) {
+        // We'll already have visited a node if it follows a convergence
+        // between different paths -- e.g., after an if-branch.
+        visited.insert(elem);
+      }
+
+      std::set<const FStmt*> nexts = (*relation)[elem];
+      for (const FStmt* next : nexts) {
+        if (visited.find(next) == visited.end()) {
+           // No need to consider a node if we've already visited it.
+           pending.push(next);
+        }
+      }
+      if (elem != fstmt) {
+        result.insert(elem);
+      }
+    }
+    return result;
+  }
+  std::string toDOT() {
+    int idx = 0;
+    std::string result = "digraph G {\n";
+    std::map<const FStmt*, std::string> map;
+
+    for (const auto& p : *relation) {
+      if (map.find(p.first) == map.end()) {
+        map.insert(std::pair<const FStmt*, std::string>(p.first, "n" + std::to_string(idx)));
+        idx++;
+      }
+
+      result += map[p.first] + " [label=\"" + p.first->toP4String() + "\",color=white,fontcolor=blue];\n";
+    }
+
+    for (const auto& p : *relation) {
+      for (const auto& to : p.second) {
+        result += map[p.first] + " -> " + map[to] + ";\n";
+      }
+    }
+
+    result += "}";
+    return result;
+  }
+    void saveDOTfile() {
+      const cstring destination = std::string(FlightplanConfig::FP_options.flightplanFolder + "/" + FlightplanConfig::adjusted_input_filename) + "_control_flow.dot";
+      std::cout << "AnalysisState: writing DOT file:" << destination << std::endl;
+      if (!destination.isNullOrEmpty()) {
+          Util::PathName path(destination);
+          std::ostream *ost = new std::ofstream(path.toString(), std::ios_base::app);
+          *ost << this->toDOT() << std::endl;
+      } else {
+          ::error("Null filename?");
+      }
+    }
+    void EmitResults() {
+      std::cout << "==[ AnalysisState ]==================" << std::endl;
+      std::cout << "num_of_statements " << num_of_statements << std::endl;
+      std::cout << "num_of_paths " << num_of_paths << std::endl;
+      std::cout << "|relation| " << relation->size() << std::endl;
+      std::cout << "|pending| " << pending->size() << std::endl;
+      if (pending->size() > 0) {
+        for (const FStmt* fstmt : *pending) {
+            std::cout << "    " << fstmt->toP4String() << std::endl;
+        }
+      }
+      std::cout << "|path_occurrences| " << path_occurrences->size() << std::endl;
+      std::cout << "=====================================" << std::endl;
+    }
+};
+
+class Flightplan_Annotator : public FStmtAnalyse<FStmt*, FlightplanAnnotate::Tippy*> {
+ private:
+    AnalysisState* analysis_state = nullptr;
+ public:
+    Flightplan_Annotator(AnalysisState* analysis_state) : analysis_state(analysis_state) {}
+    AnalysisState* getAnalysisState() {
+      return analysis_state;
+    }
+    FStmt* visit(Stmt* fstmt, FlightplanAnnotate::Tippy* state) override;
+    FStmt* visit(BlockStmt* fstmt, FlightplanAnnotate::Tippy* state) override;
+    FStmt* visit(IfStmt* fstmt, FlightplanAnnotate::Tippy* state) override;
+
+    FStmt* visit(SwitchStmt* fstmt, FlightplanAnnotate::Tippy* state) override;
+
+    // We shouldn't encounter these during annotation.
+    FStmt* visit(EntryPoint* fstmt, FlightplanAnnotate::Tippy* state) override;
+    FStmt* visit(TransferPoint* fstmt, FlightplanAnnotate::Tippy* state) override;
+};
+
+class ExpressionAnalyser : public Inspector {
+ private:
+    int ingress = 0;
+    int egress = 0;
+ public:
+    int getIngress() const {
+        return ingress;
+    }
+    int getEgress() const {
+        return egress;
+    }
+    explicit ExpressionAnalyser() {
+        setName("ExpressionAnalyser");
+    }
+    bool preorder(const IR::Member* p) override {
+        std::string s = std::string(p->member.toString());
+        if (s == "ingress_port") {
+          ingress++;
+        } else if (s == "egress_port") {
+          egress++;
+        }
+        return false;
+    }
+    static std::pair<int, int> check_metadata(const IR::Node* node) {
+        auto ea = new ExpressionAnalyser();
+        ea->init_apply(node);
+        ea->apply_visitor(node);
+        ea->end_apply(node);
+        int ingress = ea->getIngress();
+        int egress = ea->getEgress();
+        delete ea;
+        return std::pair<int, int>(ingress, egress);
+    }
+};
+
+struct StatementAnalysisMetadata {
+   int ingress = 0;
+   int egress = 0;
+   int statements_left = 0;
+   int externs_remaining = 0;
+   int unexcepted_externs_remaining = 0;
+   int jumps = 0;
+   std::set<const FStmt*> remaining_externs;
+   std::set<const FStmt*> unexcepted_remaining_externs;
+   StatementAnalysisMetadata (Stmt* fstmt, AnalysisState* analysis_state, FlightplanAnnotate::Tippy* state) {
+     std::pair<int, int> result = ExpressionAnalyser::check_metadata(fstmt->original->getNode());
+     std::set<const FStmt*> tc = analysis_state->transitive_closure(fstmt);
+     ingress = result.first;
+     egress = result.second;
+     statements_left = tc.size();
+     remaining_externs = FlightplanExterns::extern_subset(tc);
+     externs_remaining = remaining_externs.size();
+     unexcepted_remaining_externs = FlightplanExterns::excepted_subset(remaining_externs);
+     unexcepted_externs_remaining = unexcepted_remaining_externs.size();
+     jumps = state->getJumps(); // FIXME this isn't immutable. Could create a map then use it for lookups thereafter  
+     remaining_externs = FlightplanExterns::extern_subset(tc);
+   }
+   std::string toString() {
+     std::string result;
+     result += "// Ingress=" + std::to_string(ingress) + " Egress=" + std::to_string(egress) + " StatementsLeft=" + std::to_string(statements_left) + " ExternsRemaining={";
+     for (const FStmt* fstmt : remaining_externs) {
+         result += FlightplanExterns::name_of_caller(fstmt) + " ";
+     }
+     result += "}";
+     result += " UnexceptedExternsRemaining={";
+     for (const FStmt* fstmt : unexcepted_remaining_externs) {
+         result += FlightplanExterns::name_of_caller(fstmt) + " ";
+     }
+     result += "}";
+     result += " Jumps=" + std::to_string(jumps) + "\n";
+     return result;
+   }
+};
+
+class ExternScanner : public FStmtAnalyse<void, int*> {
+ public:
+    void visit(Stmt* fstmt, int* count) override {
+        auto pre_statement = fstmt->original;
+        if (pre_statement->is<IR::Statement>()) {
+            auto stmt = &pre_statement->as<IR::Statement>();
+            if (stmt->is<IR::MethodCallStatement>()) {
+                auto mcs = &stmt->as<IR::MethodCallStatement>();
+                if (FlightplanExterns::calls_extern_function(mcs)) {
+                    *count += 1;
+                }
+            }
+        }
+    }
+};
+
+class ForwardStatementGatherer : public FStmtAnalyse<void, AnalysisState*> {
+ public:
+    // "return" and "exit" are removed during early program transformation
+    // by the compiler.
+    static bool sets_hasReturned(const IR::Statement* stmt) {
+        const IR::AssignmentStatement *assign_stmt = dynamic_cast<const IR::AssignmentStatement*>(stmt);
+        if (assign_stmt != nullptr) {
+          if (assign_stmt->left->is<IR::PathExpression>() &&
+              assign_stmt->right->is<IR::BoolLiteral>()) {
+            std::string definiens = std::string(assign_stmt->left->as<IR::PathExpression>().toString());
+            auto literal = assign_stmt->right->as<IR::BoolLiteral>();
+            if (literal.value && definiens == std::string("hasReturned"/*FIXME const*/)) {
+              return true;
+            }
+          }
+        }
+        return false;
+    }
+    static bool sets_hasReturned(const IR::StatOrDecl* stmt_or_decl) {
+        if (stmt_or_decl->is<IR::Statement>()) {
+            return sets_hasReturned(&stmt_or_decl->as<IR::Statement>());
+        }
+        return false;
+    }
+    void visit(Stmt* fstmt, AnalysisState* state) override {
+        state->Occur(fstmt);
+        state->incrementStatements();
+        std::set<const FStmt*> fstmt_next;
+        state->relation->insert(std::pair<const FStmt*, std::set<const FStmt*>>(fstmt, fstmt_next));
+        for (const FStmt* from : *state->pending) {
+           (*state->relation)[from].insert(fstmt);
+        }
+        state->pending->clear();
+        // Check if this is the end of a path -- if so then this statement doesn't
+        // precede any more statements.
+        if (!sets_hasReturned(fstmt->original)) {
+            // FIXME could also check if fstmt is a Return or Exit statement.
+            state->pending->insert(fstmt);
+        }
+    }
+    void visit(BlockStmt* fstmt, AnalysisState* state) override {
+        state->Occur(fstmt);
+        state->incrementStatements();
+        FStmt* cursor = fstmt->getEntry();
+        while (cursor != nullptr) {
+            process(cursor, state);
+            cursor = (FStmt*)cursor->get_next();
+        }
+    }
+    void visit(IfStmt* fstmt, AnalysisState* state) override {
+        state->Occur(fstmt);
+        state->incrementStatements();
+        AnalysisState* sub_state1 = state->clone();
+        AnalysisState* sub_state2 = state->clone();
+        assert(fstmt->get_ifTrue() != nullptr);
+        process((FStmt*)fstmt->get_ifTrue(), sub_state1);
+
+        // FIXME check condition expression for references to metadata
+
+        if (fstmt->get_ifFalse() != nullptr) {
+            process((FStmt*)fstmt->get_ifFalse(), sub_state2);
+        }
+        state->pending->clear();
+        state->resetNumOfPaths();
+        state->merge(sub_state1);
+        state->merge(sub_state2);
+        delete sub_state1;
+        delete sub_state2;
+    }
+    void visit(SwitchStmt* fstmt, AnalysisState* state) override {
+        state->Occur(fstmt);
+        state->incrementStatements();
+        // FIXME check condition expression for references to metadata
+        std::vector<SwitchStmt::Case> cases = fstmt->getCases();
+        std::vector<AnalysisState*> sub_states;
+        for (int i = 0; i < cases.size(); ++i) {
+            AnalysisState* sub_state = state->clone();
+            sub_states.push_back(sub_state);
+            process((FStmt*)cases[i].get_stmt(), sub_state);
+        }
+
+        state->pending->clear();
+        state->resetNumOfPaths();
+        for (int i = 0; i < cases.size(); ++i) {
+            state->merge(sub_states[i]);
+            delete sub_states[i];
+        }
+    }
+    void visit(EntryPoint*, AnalysisState*) override {
+       throw std::logic_error("Unsupported");
+    }
+    void visit(TransferPoint*, AnalysisState*) override {
+       throw std::logic_error("Unsupported");
+    }
+};
+
+}  // namespace P4
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_ANNOTATOR_H_ */
diff --git a/frontends/p4/flightplan_context_analysis.cpp b/frontends/p4/flightplan_context_analysis.cpp
new file mode 100644
index 0000000..8192648
--- /dev/null
+++ b/frontends/p4/flightplan_context_analysis.cpp
@@ -0,0 +1,266 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+*/
+
+#include <queue>
+#include <string>
+#include <vector>
+
+#include "flightplan_context_analysis.h"
+
+namespace P4 {
+
+void Fly_Analyser::visit(Stmt* fstmt, FlyAnalysisState* state) {
+   const IR::StatOrDecl* stmt = fstmt->original;
+   if (stmt->is<IR::AssignmentStatement>()) {
+     const IR::AssignmentStatement* ass_stmt = &stmt->as<IR::AssignmentStatement>();
+     if (ass_stmt->left->is<IR::PathExpression>()) {
+       const IR::PathExpression* varname = &ass_stmt->left->as<IR::PathExpression>();
+       auto ty = typeMap->getType(varname->getNode());
+       if (ty->is<IR::Type_Bits>()) {
+         const IR::Type_Bits* ty_bits = &ty->as<IR::Type_Bits>();
+           if (ty_bits->size == 1337/*FIXME const*/) {
+             std::cout << "location temp variable: " << varname->path->toString() << std::endl;
+             //std::cout << "  TY: " << ty << std::endl;
+             const IR::IDeclaration* lhs_decl = refMap->getDeclaration(((const IR::PathExpression*)ass_stmt->left)->path);
+             const IR::IDeclaration* rhs_decl = refMap->getDeclaration(((const IR::PathExpression*)ass_stmt->right)->path);
+             if (rhs_decl == nullptr || state->find(rhs_decl) == state->end()) {
+               // LHS is directly equated to RHS
+               std::cout << "  RHS: " << ass_stmt->right << std::endl;
+               state->insert(std::pair<const IR::IDeclaration*, const IR::Expression*>(lhs_decl, ass_stmt->right));
+             } else {
+               // LHS is indirectly equated to RHS, via another assignment
+               std::cout << "  (RHS): " << (*state)[rhs_decl] << std::endl;
+               state->insert(std::pair<const IR::IDeclaration*, const IR::Expression*>(lhs_decl, (*state)[rhs_decl]));
+             }
+           }
+       }
+     }
+   }
+}
+
+void Fly_Analyser::visit(BlockStmt* fstmt, FlyAnalysisState* state)  {
+    FStmt* cursor = fstmt->getEntry();
+
+    while (cursor != nullptr) {
+        process(cursor, state);
+        cursor = cursor->get_next();
+    }
+}
+
+void Fly_Analyser::visit(IfStmt* fstmt, FlyAnalysisState* state)  {
+    assert (fstmt->get_ifTrue() != nullptr);
+    process(fstmt->get_ifTrue(), state);
+
+    if (fstmt->get_ifFalse() != nullptr) {
+        process(fstmt->get_ifFalse(), state);
+    }
+}
+
+void Fly_Analyser::visit(SwitchStmt* fstmt, FlyAnalysisState* state) {
+    for (auto cas : fstmt->getCases()) {
+        process((FStmt*)cas.get_fstmt(), state);
+    }
+}
+
+void Fly_Analyser::visit(EntryPoint*, FlyAnalysisState*) {
+    throw std::logic_error("Unsupported");
+}
+
+void Fly_Analyser::visit(TransferPoint*, FlyAnalysisState*) {
+    // Nothing to be done.
+}
+
+void Context_Analyser::visit(BlockStmt* fstmt, ContextAnalysisState* state)  {
+    FStmt* cursor = fstmt->getEntry();
+
+    while (cursor != nullptr) {
+        process(cursor, state);
+        cursor = cursor->get_next();
+    }
+}
+
+void Context_Analyser::visit(IfStmt* fstmt, ContextAnalysisState* state)  {
+    assert (fstmt->get_ifTrue() != nullptr);
+    process(fstmt->get_ifTrue(), state);
+
+    if (fstmt->get_ifFalse() != nullptr) {
+        process(fstmt->get_ifFalse(), state);
+    }
+}
+
+void Context_Analyser::visit(SwitchStmt* fstmt, ContextAnalysisState* state) {
+    for (auto cas : fstmt->getCases()) {
+        process((FStmt*)cas.get_fstmt(), state);
+    }
+}
+
+void Context_Analyser::visit(EntryPoint*, ContextAnalysisState*) {
+    throw std::logic_error("Unsupported");
+}
+
+void Context_Analyser::visit(TransferPoint*, ContextAnalysisState*) {
+    // Nothing to be done here.
+}
+
+void Context_Analyser::visit(Stmt* fstmt, ContextAnalysisState* state) {
+    visit(fstmt->original, state);
+}
+
+void Context_Analyser::visit(const IR::AssignmentStatement* stmt, ContextAnalysisState* state) {
+    state->writes.insert(stmt->left);
+    visit(stmt->right, state);
+}
+
+void Context_Analyser::visit(const IR::MethodCallStatement* stmt, ContextAnalysisState* state) {
+    visit(stmt->methodCall, state);
+}
+
+void Context_Analyser::visit(const IR::BlockStatement* bstmt, ContextAnalysisState* state) {
+    for (auto stmt : bstmt->components) {
+       visit(stmt, state);
+    }
+}
+
+void Context_Analyser::visit(const IR::StatOrDecl* sod, ContextAnalysisState* state) {
+    if (sod->is<IR::Statement>()) {
+       visit(&sod->as<IR::Statement>(), state);
+    } else if (sod->is<IR::Declaration>()) {
+       visit(&sod->as<IR::Declaration>(), state);
+    }
+}
+
+void Context_Analyser::visit(const IR::Statement* stmt, ContextAnalysisState* state) {
+    if (stmt->is<IR::AssignmentStatement>()) {
+       visit(&stmt->as<IR::AssignmentStatement>(), state);
+    } else if (stmt->is<IR::MethodCallStatement>()) {
+       visit(&stmt->as<IR::MethodCallStatement>(), state);
+    }
+}
+
+void Context_Analyser::visit(const IR::Declaration* decl, ContextAnalysisState* state) {
+    // No need to change writes, since the declaration is local to a segment.
+    // FIXME check if need to update reads, if declaration has a definition.
+    std::cout << "Declaration::: " << decl->toString() << std::endl;
+
+}
+
+void Context_Analyser::visit(const IR::IfStatement* ifstmt, ContextAnalysisState* state) {
+    visit(ifstmt->ifTrue, state);
+    if (ifstmt->ifFalse != nullptr) {
+      visit(ifstmt->ifFalse, state);
+    }
+}
+
+void Context_Analyser::visit(const IR::Expression* expression, ContextAnalysisState* state) {
+    if (expression->is<IR::MethodCallExpression>()) {
+       visit(&expression->as<IR::MethodCallExpression>(), state);
+    } else if (expression->is<IR::PathExpression>()) {
+       visit(&expression->as<IR::PathExpression>(), state);
+    } else if (expression->is<IR::Operation_Binary>()) {
+       visit(&expression->as<IR::Operation_Binary>(), state);
+    } else if (expression->is<IR::Member>()) {
+       visit(&expression->as<IR::Member>(), state);
+    } else if (expression->is<IR::Operation_Unary>()) {
+       visit(&expression->as<IR::Operation_Unary>(), state);
+    } else if (expression->is<IR::TypeNameExpression>()) {
+       visit(&expression->as<IR::TypeNameExpression>(), state);
+    }
+}
+
+const IR::P4Table* attempt_resolve_table(const IR::Expression* expression, ReferenceMap* refMap, TypeMap* typeMap) {
+    auto mce = expression->to<IR::MethodCallExpression>();
+    auto mi = P4::MethodInstance::resolve(mce, refMap, typeMap);
+    if (!mi->isApply()) {
+        return nullptr;
+    }
+    auto am = mi->to<P4::ApplyMethod>();
+    if (!am->object->is<IR::P4Table>()) {
+        return nullptr;
+    }
+    return am->object->to<IR::P4Table>();
+}
+
+const IR::P4Action* attempt_resolve_action_body(const IR::Expression* expression, ReferenceMap* refMap, TypeMap* typeMap) {
+    auto mce = expression->to<IR::MethodCallExpression>();
+    auto mi = P4::MethodInstance::resolve(mce, refMap, typeMap);
+
+    if (auto ac = mi->to<ActionCall>()) {
+        return ac->action;
+    }
+
+    return nullptr;
+}
+
+void Context_Analyser::visit(const IR::MethodCallExpression* expression, ContextAnalysisState* state) {
+    const IR::P4Table* tbl = attempt_resolve_table(expression, refMap, typeMap);
+    if (tbl != nullptr) {
+        const IR::ActionList* actions = tbl->getActionList();
+        for (const IR::ActionListElement* action : actions->actionList) {
+            const IR::P4Action* p4action = attempt_resolve_action_body(action->expression, refMap, typeMap);
+            visit(p4action->body, state);
+            // Need to remove action parameters, since these come from the lookup's result.
+            std::queue<std::string> to_purge_pre; // FIXME crude: using names without checking for scope, type etc.
+            for (auto param : *p4action->getParameters()) {
+                to_purge_pre.push(std::string(param->getName().toString()));
+	    }
+
+            std::queue<const IR::Expression*> to_purge;
+            while (!to_purge_pre.empty()) {
+                const std::string expr_s = to_purge_pre.front();
+		to_purge_pre.pop();
+                for (const IR::Expression* expr : state->reads) {
+                    if (expr_s == std::string(expr->toString())) {
+                        to_purge.push(expr);
+                    }
+	        }
+	    }
+
+            while (!to_purge.empty()) {
+                const IR::Expression* expr = to_purge.front();
+		to_purge.pop();
+                if (state->reads.find(expr) != state->reads.end()) {
+                    state->reads.erase(expr);
+                }
+                if (state->writes.find(expr) != state->writes.end()) {
+                    state->writes.erase(expr);
+                }
+	    }
+        }
+
+        const IR::Key* key = tbl->getKey();
+        for (const IR::KeyElement* ke : key->keyElements) {
+            visit(ke->expression, state);
+        }
+    }
+
+
+    for (auto &arg : *expression->arguments) {
+      visit(arg->expression, state);
+    }
+}
+
+void Context_Analyser::visit(const IR::PathExpression* p, ContextAnalysisState* state) {
+    state->reads.insert(p);
+}
+
+void Context_Analyser::visit(const IR::Operation_Binary* b, ContextAnalysisState* state) {
+    visit(b->left, state);
+    visit(b->right, state);
+}
+
+void Context_Analyser::visit(const IR::Operation_Unary* u, ContextAnalysisState* state) {
+    visit(u->expr, state);
+}
+
+void Context_Analyser::visit(const IR::TypeNameExpression* e, ContextAnalysisState* state) {
+    // FIXME unsure what this consists of
+    throw std::logic_error("Unsupported: TypeNameExpression");
+}
+
+void Context_Analyser::visit(const IR::Member* e, ContextAnalysisState* state) {
+    state->reads.insert(e); // FIXME unsure about this
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan_context_analysis.h b/frontends/p4/flightplan_context_analysis.h
new file mode 100644
index 0000000..9b8ac30
--- /dev/null
+++ b/frontends/p4/flightplan_context_analysis.h
@@ -0,0 +1,82 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_CONTEXT_ANALYSIS_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_CONTEXT_ANALYSIS_H_
+
+#include "flightplan_annotator.h"
+#include "tableApply.h"
+
+namespace P4 {
+
+using FlyAnalysisState = std::map<const IR::IDeclaration*, const IR::Expression*>;
+
+class Fly_Analyser : public FStmtAnalyse<void, FlyAnalysisState*> {
+    TypeMap* typeMap = nullptr;
+    ReferenceMap* refMap = nullptr;
+ public:
+    Fly_Analyser(TypeMap* typeMap, ReferenceMap* refMap) : typeMap(typeMap), refMap(refMap) {}
+    void visit(Stmt* fstmt, FlyAnalysisState* state) override;
+    void visit(BlockStmt* fstmt, FlyAnalysisState* state) override;
+    void visit(IfStmt* fstmt, FlyAnalysisState* state) override;
+    void visit(SwitchStmt* fstmt, FlyAnalysisState* state) override;
+    void visit(EntryPoint* fstmt, FlyAnalysisState* state) override;
+    void visit(TransferPoint* fstmt, FlyAnalysisState* state) override;
+};
+
+struct ContextAnalysisState {
+  std::set<const IR::Expression*> reads;
+  std::set<const IR::Expression*> writes;
+  std::string setString(std::set<const IR::Expression*> set) {
+    std::string result = "{";
+    bool started = false;
+    for (const IR::Expression* x : set) {
+      if (!started) result += x->toString();
+      else result += " " + x->toString();
+      started = true;
+    }
+    return result + "}";
+  }
+  std::string readsString() {
+    return setString(reads);
+  }
+  std::string writesString() {
+    return setString(writes);
+  }
+};
+
+class Context_Analyser : public FStmtAnalyse<void, ContextAnalysisState*> {
+    TypeMap* typeMap = nullptr;
+    ReferenceMap* refMap = nullptr;
+ public:
+    Context_Analyser(TypeMap* typeMap, ReferenceMap* refMap) : typeMap(typeMap), refMap(refMap) {}
+    void visit(Stmt* fstmt, ContextAnalysisState* state) override;
+    void visit(BlockStmt* fstmt, ContextAnalysisState* state) override;
+    void visit(IfStmt* fstmt, ContextAnalysisState* state) override;
+    void visit(SwitchStmt* fstmt, ContextAnalysisState* state) override;
+    void visit(EntryPoint* fstmt, ContextAnalysisState* state) override;
+    void visit(TransferPoint* fstmt, ContextAnalysisState* state) override;
+
+    void visit(const IR::AssignmentStatement* stmt, ContextAnalysisState* state);
+    void visit(const IR::MethodCallStatement* stmt, ContextAnalysisState* state);
+    void visit(const IR::BlockStatement* stmt, ContextAnalysisState* state);
+    void visit(const IR::StatOrDecl* stmt, ContextAnalysisState* state);
+    void visit(const IR::Statement* stmt, ContextAnalysisState* state);
+    void visit(const IR::Declaration* stmt, ContextAnalysisState* state);
+    void visit(const IR::IfStatement* stmt, ContextAnalysisState* state);
+
+    void visit(const IR::Expression* c, ContextAnalysisState* state);
+
+    void visit(const IR::PathExpression* p, ContextAnalysisState* state);
+    void visit(const IR::Operation_Binary* b, ContextAnalysisState* state);
+    void visit(const IR::Operation_Unary* u, ContextAnalysisState* state);
+    void visit(const IR::TypeNameExpression* e, ContextAnalysisState* state);
+    void visit(const IR::Member* e, ContextAnalysisState* state);
+    void visit(const IR::MethodCallExpression* e, ContextAnalysisState* state);
+};
+
+}  // namespace P4
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_CONTEXT_ANALYSIS_H_ */
diff --git a/frontends/p4/flightplan_convert.h b/frontends/p4/flightplan_convert.h
new file mode 100644
index 0000000..6e1886f
--- /dev/null
+++ b/frontends/p4/flightplan_convert.h
@@ -0,0 +1,272 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_CONVERT_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_CONVERT_H_
+
+#include "flightplan.h"
+#include "flightplan_stmt.h"
+#include "flightplan_annotate.h"
+#include "flightplan_externs.h"
+
+namespace P4 {
+
+class StmtConvert {
+ public:
+    static FStmt* encapsulate (const FStmt* container, std::string dest_path, const IR::AssignmentStatement* stmt, FStmt* prev, FStmt* next) {
+        return new Stmt (container, dest_path, stmt, prev, next);
+    }
+    static FStmt* encapsulate (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* stmt, FStmt* prev, FStmt* next);
+    static FStmt* encapsulate (const FStmt* container, std::string dest_path, const IR::BlockStatement* stmt, FStmt* prev, FStmt* next) {
+        return new BlockStmt (container, dest_path, stmt, prev, next);
+    }
+
+    static FStmt* encapsulate (const FStmt* container, std::string dest_path, const IR::StatOrDecl* stmt, FStmt* prev, FStmt* next) {
+        if (stmt->is<IR::Declaration>()) {
+            return encapsulate(container, dest_path, &stmt->as<IR::Declaration>(), prev, next);
+        } else if (stmt->is<IR::Statement>()) {
+            return encapsulate(container, dest_path, &stmt->as<IR::Statement>(), prev, next);
+        } else {
+            throw std::logic_error("StatOrDecl: Unrecognised statement type");
+        }
+    }
+    static FStmt* encapsulate (const FStmt* container, std::string dest_path, const IR::Statement* stmt, FStmt* prev, FStmt* next) {
+        if (stmt->is<IR::AssignmentStatement>()) {
+            return new Stmt (container, dest_path, &stmt->as<IR::AssignmentStatement>(), prev, next);
+        } else if (stmt->is<IR::MethodCallStatement>()) {
+            return encapsulate (container, dest_path, &stmt->as<IR::MethodCallStatement>(), prev, next);
+        } else if (stmt->is<IR::BlockStatement>()) {
+            return new BlockStmt (container, dest_path, &stmt->as<IR::BlockStatement>(), prev, next);
+        } else if (stmt->is<IR::IfStatement>()) {
+            return new IfStmt (container, dest_path, &stmt->as<IR::IfStatement>(), prev, next);
+        } else if (stmt->is<IR::SwitchStatement>()) {
+            return new SwitchStmt (container, dest_path, &stmt->as<IR::SwitchStatement>(), prev, next);
+	} else if (stmt->is<IR::ReturnStatement>()) {
+            return new Stmt (container, dest_path, &stmt->as<IR::ReturnStatement>(), prev, next);
+        } else {
+            throw std::logic_error("Statement: Unrecognised statement type: " + std::string("\n" + stmt->getSourceInfo().toSourceFragment()));
+        }
+    }
+    static FStmt* encapsulate (const FStmt* container, std::string dest_path, const IR::Declaration* stmt, FStmt* prev, FStmt* next) {
+        return new Stmt (container, dest_path, stmt, prev, next);
+    }
+
+    static FStmt* encapsulate (const FStmt* container, std::string dest_path, const IR::IfStatement* stmt, FStmt* prev, FStmt* next) {
+        return new IfStmt (container, dest_path, stmt, prev, next);
+    }
+};
+
+template <class Out, class State>
+class FStmtAnalyse {
+ public:
+    virtual Out visit(EntryPoint* fstmt, State state) = 0;
+    virtual Out visit(TransferPoint* fstmt, State state) = 0;
+    virtual Out visit(Stmt* fstmt, State state) = 0;
+
+    virtual Out visit(BlockStmt* fstmt, State state) = 0;
+    virtual Out visit(IfStmt* fstmt, State state) = 0;
+    virtual Out visit(SwitchStmt* fstmt, State state) = 0;
+
+    virtual Out process(FStmt* fstmt, State state) {
+        CHECK_NULL(fstmt);
+        switch (FStmt::classify(fstmt)) {
+            case FStmt::Kind::EntryPoint:
+            return visit((EntryPoint*)fstmt, state);
+            case FStmt::Kind::TransferPoint:
+            return visit((TransferPoint*)fstmt, state);
+            case FStmt::Kind::Stmt:
+            return visit((Stmt*)fstmt, state);
+            case FStmt::Kind::BlockStmt:
+            return visit((BlockStmt*)fstmt, state);
+            case FStmt::Kind::IfStmt:
+            return visit((IfStmt*)fstmt, state);
+            case FStmt::Kind::SwitchStmt:
+            return visit((SwitchStmt*)fstmt, state);
+            default:
+            throw std::logic_error("Unrecognised FStmt");
+        }
+    }
+};
+
+class FStmtDeepClone : public FStmtAnalyse<FStmt*, FStmt*> {
+ public:
+    FStmt* visit(EntryPoint* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+        return fstmt->clone();
+    }
+
+    FStmt* visit(TransferPoint* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+        return fstmt->clone();
+    }
+
+    FStmt* visit(Stmt* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+        return fstmt->clone();
+    }
+
+    FStmt* visit(BlockStmt* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+
+        BlockStmt* result = (BlockStmt*)fstmt->clone();
+
+        FStmt* cursor = fstmt->getEntry();
+        FStmt* prev = nullptr;
+        result->setEntry(nullptr);
+
+        //rewrite prev + next as we go along
+        while (cursor != nullptr) {
+            FStmt* subresult = process(cursor, cursor);
+            subresult->set_next(nullptr);
+            subresult->container = result;
+            if (result->getEntry() == nullptr) {
+                result->setEntry(subresult);
+                assert(prev == nullptr);
+                //assert(subresult->get_prev() == nullptr);
+                subresult->set_prev(nullptr);
+            } else {
+                assert(prev != nullptr);
+                prev->set_next(subresult);
+                subresult->set_prev(prev);
+            }
+            prev = subresult;
+            cursor = cursor->next;
+        }
+
+        return result;
+    }
+
+    FStmt* visit(IfStmt* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+
+        IfStmt* result = (IfStmt*)fstmt->clone();
+
+        if (result->ifTrue != nullptr) {
+            result->ifTrue = process(fstmt->ifTrue, fstmt->ifTrue);
+        }
+
+        if (result->ifFalse != nullptr) {
+            result->ifFalse = process(fstmt->ifFalse, fstmt->ifFalse);
+        }
+
+        return result;
+    }
+
+    FStmt* visit(SwitchStmt* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+
+        SwitchStmt* result = (SwitchStmt*)fstmt->clone();
+
+        result->cases.clear();
+        for (SwitchStmt::Case& cas : fstmt->cases) {
+            SwitchStmt::Case cas2 = SwitchStmt::Case(cas.label, process(cas.stmt, cas.stmt));
+            result->cases.push_back(cas2);
+        }
+
+        return result;
+    }
+};
+
+class Annotator {
+ private:
+    virtual FStmt* private_annotate();
+ protected:
+    FStmt* result = nullptr;
+    Stmt* orig_stmt = nullptr;
+    std::string extern_name;
+    std::string suffix;
+    std::string segment_name;
+    std::string* looked_up = nullptr;
+
+ public:
+    const FStmt* container = nullptr;
+    std::string dest_path;
+    const IR::MethodCallStatement* mcs = nullptr;
+    FStmt* prev = nullptr;
+    FStmt* next = nullptr;
+
+     Annotator (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* mcs, FStmt* prev, FStmt* next);
+
+    FStmt* annotate() {
+        if (result != nullptr) { // FIXME factor out      
+            return result;
+        } else {
+            return private_annotate();
+        }
+    };
+};
+
+class EagerOffload : public Annotator {
+  private:
+    FStmt* private_annotate() override;
+  public:
+    EagerOffload (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* mcs, FStmt* prev, FStmt* next) : Annotator(container, dest_path, mcs, prev, next) {}
+};
+
+class ProtoAnnotate : public FStmtDeepClone {
+ public:
+    FStmt* visit(TransferPoint*, FStmt*) override {
+        throw std::logic_error("Unrecognised FStmt");
+    }
+
+    FStmt* visit(Stmt* fstmt, FStmt* value) override {
+        auto pre_statement = fstmt->original;
+        if (pre_statement->is<IR::Declaration>()) {
+            return FStmtDeepClone::visit(fstmt, value);
+        } else if (pre_statement->is<IR::Statement>()) {
+            auto stmt = &pre_statement->as<IR::Statement>();
+            if (stmt->is<IR::MethodCallStatement>()) {
+                EagerOffload ann(fstmt->container, std::string(FlightplanConfig::FP_options.flightplanFolder), &stmt->as<IR::MethodCallStatement>(), fstmt->prev, fstmt->next);
+                return ann.annotate();
+            } else  {
+                return FStmtDeepClone::visit(fstmt, value);
+            }
+        } else {
+            throw std::logic_error("Impossible");
+        }
+    }
+
+    FStmt* annotate(const FStmt* container, std::string dest_path, const IR::MethodCallStatement* mcs, FStmt* prev, FStmt* next);
+};
+
+template <class Ann>
+class ProtoAnnotateGeneric : public FStmtDeepClone {
+ public:
+    FStmt* visit(TransferPoint* fstmt, FStmt* value) override {
+        throw std::logic_error("Unrecognised FStmt");
+    }
+
+    FStmt* visit(Stmt* fstmt, FStmt* value) override {
+        auto pre_statement = fstmt->original;
+        if (pre_statement->is<IR::Declaration>()) {
+            return FStmtDeepClone::visit(fstmt, value);
+        } else if (pre_statement->is<IR::Statement>()) {
+            auto stmt = &pre_statement->as<IR::Statement>();
+            if (stmt->is<IR::MethodCallStatement>()) {
+                Annotator* ann = nullptr;
+
+                switch (FlightplanConfig::FP_options.flightplan_annotation_mode) {
+                    case CompilerOptions::FlightplanAnnotationMode::EagerOffload:
+                        ann = new EagerOffload(fstmt->container, std::string(FlightplanConfig::FP_options.flightplanFolder), &stmt->as<IR::MethodCallStatement>(), fstmt->prev, fstmt->next);
+                        break;
+                    default:
+                        throw std::logic_error("Unsupported annotation sub-mode");
+                }
+
+                return ann->annotate();
+            } else  {
+                return FStmtDeepClone::visit(fstmt, value);
+            }
+        } else {
+            throw std::logic_error("Impossible");
+        }
+    }
+
+    FStmt* annotate(const FStmt* container, std::string dest_path, const IR::MethodCallStatement* mcs, FStmt* prev, FStmt* next);
+};
+
+}  // namespace P4
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_CONVERT_H_ */
diff --git a/frontends/p4/flightplan_convert_extra.h b/frontends/p4/flightplan_convert_extra.h
new file mode 100644
index 0000000..ade7cec
--- /dev/null
+++ b/frontends/p4/flightplan_convert_extra.h
@@ -0,0 +1,96 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_CONVERT_EXTRA_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_CONVERT_EXTRA_H_
+
+#include "flightplan_convert.h"
+
+namespace P4 {
+
+class Cleary : public FStmtDeepClone {
+ public:
+    FStmt* visit(TransferPoint* fstmt, FStmt* value) override {
+        throw std::logic_error("Unrecognised FStmt");
+    }
+
+    FStmt* visit(IfStmt* fstmt, FStmt* value) override {
+        return new EntryPoint (std::string("bla"), nullptr);
+    }
+};
+
+class Dleary : public FStmtDeepClone {
+ public:
+    FStmt* visit(EntryPoint* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+        return fstmt->clone();
+    }
+
+    FStmt* visit(TransferPoint* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+        return fstmt->clone();
+    }
+
+    FStmt* visit(Stmt* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+        return fstmt->clone();
+    }
+
+    FStmt* visit(BlockStmt* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+
+        BlockStmt* result = (BlockStmt*)fstmt->clone();
+
+        FStmt* cursor = fstmt->getEntry();
+        FStmt* prev = nullptr;
+        result->setEntry(nullptr);
+
+        //rewrite prev + next as we go along
+        while (cursor != nullptr) {
+            FStmt* subresult = process(cursor, cursor);
+            subresult->set_next(nullptr);
+            subresult->container = result;
+            if (result->getEntry() == nullptr) {
+                result->setEntry(subresult);
+                assert(prev == nullptr);
+                //assert(subresult->get_prev() == nullptr);
+                subresult->set_prev(nullptr);
+            } else {
+                if (prev != nullptr) {
+                  prev->set_next(subresult);
+                }
+                subresult->set_prev(prev);
+                prev = subresult;
+            }
+            cursor = cursor->next;
+        }
+
+        return result;
+    }
+
+    FStmt* visit(SwitchStmt* fstmt, FStmt* value) override {
+        assert(fstmt == value);
+
+        SwitchStmt* result = (SwitchStmt*)fstmt->clone();
+
+        result->cases.clear();
+        for (SwitchStmt::Case& cas : fstmt->cases) {
+            SwitchStmt::Case cas2 = SwitchStmt::Case(cas.label, process(cas.stmt, cas.stmt));
+            result->cases.push_back(cas2);
+        }
+
+        return result;
+    }
+
+
+
+    FStmt* visit(IfStmt* fstmt, FStmt* value) override {
+        return new EntryPoint (std::string("bla"), nullptr);
+    }
+};
+
+}  // namespace P4
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_CONVERT_EXTRA_H_
diff --git a/frontends/p4/flightplan_dot.cpp b/frontends/p4/flightplan_dot.cpp
new file mode 100644
index 0000000..e47b775
--- /dev/null
+++ b/frontends/p4/flightplan_dot.cpp
@@ -0,0 +1,198 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#include <assert.h>
+#include <iostream>
+#include <fstream>
+
+#include "externInstance.h"
+
+#include "../common/options.h"
+#include "ir/ir.h"
+#include "ir/visitor.h"
+#include "lib/nullstream.h"
+#include "lib/path.h"
+#include "toP4/toP4.h"
+
+#include "flightplan.h"
+#include "flightplan_preanalysis.h"
+
+namespace P4 {
+
+std::string FStmt::link_from_prev() const {
+    std::string result;
+    if (get_prev() != nullptr) {
+        std::string tail;
+        if (get_prev()->getClustID() != nullptr) {
+            tail = "[ltail=" + *(get_prev()->getClustID()) + "]";
+        }
+
+        const BlockStmt *bs = dynamic_cast<const BlockStmt*>(get_prev());
+        if (bs != nullptr) {
+            if (bs->getEntry() != this) {
+                result += get_prev()->DOTid() + " -> " + DOTid() + tail + ";\n";
+            } else {
+                // Don't make the block's node appear in the graph.
+            }
+        } else {
+            result += get_prev()->DOTid() + " -> " + DOTid() + ";\n";
+        }
+    }
+    return result;
+}
+
+std::string Stmt::toDOT() const {
+    std::string abbrev_name = "stmt" + DOTid();
+    assert(original != nullptr);
+    std::string result = DOTid() + " [label=\"" + abbrev_name + ":" + original->getSourceInfo().toPositionString()  + "\",color=white];\n";
+    return result;
+}
+
+std::string TransferPoint::toDOT() const {
+    std::string abbrev_name = "stmt" + DOTid();
+    std::string result = DOTid() + " [label=\"" + abbrev_name + ":" + original->getSourceInfo().toPositionString()  + "\",color=red,style=filled,fontcolor=white];\n";
+    return result;
+}
+
+std::string BlockStmt::toDOT() const {
+    std::string abbrev_name = "block";
+    std::string clust_name = *clust_id;
+
+    std::string result = "subgraph " + clust_name + " {\n";
+
+    result += "label=\"\";\n";
+    result += "style=solid;\n";
+    result += "color=lightgray;\n";
+    const FStmt *cursor = block_entry;
+    while (cursor != nullptr) {
+        result += cursor->toString() + "\n";
+        result += cursor->toDOT();
+        result += cursor->link_from_prev();
+        cursor = cursor->get_next();
+    }
+    result += "}\n";
+    return result;
+}
+
+std::string BlockStmt::entryDOTid() const {
+    return block_entry->DOTid();
+}
+
+std::string IfStmt::toDOT() const {
+    // FIXME DRY principle
+
+    std::string abbrev_name = "if";
+    std::string clust_name = *clust_id;
+
+    std::stringstream sstream;
+    P4::ToP4 top4(&sstream, false, "");
+    (void)condition->apply(top4);
+    std::string cond_s = sstream.str();
+
+    std::string label = "label=\"" + abbrev_name + " " + cond_s + "\"";
+
+    std::string result = "subgraph " + clust_name + " {\n";
+    result += DOTid() + " [" + label + ",color=white,fontcolor=blue];\n";
+
+    result += "label=\"\";\n";
+    result += "style=dotted;\n";
+    result += "color=lightgray;\n";
+
+    abbrev_name = "true";
+    result += "subgraph cluster_" + abbrev_name + "_" + DOTid() + " {\n";
+    result += "label=\"" + abbrev_name + "\";\n";
+    result += "style=dotted;\n";
+    result += "color=lightgray;\n";
+    result += "fontcolor=green;\n";
+    result += ifTrue->toDOT();
+    result += "}\n";
+    result += DOTid() + " -> " + ifTrue->entryDOTid() +";\n";
+
+    if (ifFalse != nullptr) {
+        abbrev_name = "false";
+        result += "subgraph cluster_" + abbrev_name + "_" + DOTid() + " {\n";
+        result += "label=\"" + abbrev_name + "\";\n";
+        result += "style=dotted;\n";
+        result += "color=lightgray;\n";
+        result += "fontcolor=red;\n";
+        result += ifFalse->toDOT();
+        result += "}\n";
+        result += DOTid() + " -> " + ifFalse->entryDOTid() +";\n";
+    } else {
+        result += "// no 'false' branch\n";
+    }
+
+    result += "}\n";
+
+    return result;
+}
+
+std::string SwitchStmt::toDOT() const {
+    throw std::logic_error("Unexpected");
+}
+
+void StmtFlow::cfg_dot(std::ostream *ost, const FStmt* st, std::set<const FStmt*> &visited, const FStmt* pre_st) {
+    std::set<const FStmt*> next = step(Direction::Forward, st, visited);
+    bool src_atom = atomic_stmt(st);
+    std::string node = st->DOTid() + " [color=white,label=\"" + st->toStatement()->toString() + ": " + st->toStatement()->getSourceInfo().toPositionString() + "\"];";
+    if (src_atom) {
+        *ost << node << std::endl;
+    } else {
+        *ost << "// " + node << std::endl;
+    }
+    for (auto next_st : next) {
+        bool tgt_atom = atomic_stmt(next_st);
+
+        std::string edge;
+        if (src_atom && tgt_atom) {
+            edge = st->DOTid() + " -> " + next_st->DOTid();
+        } else if (pre_st != nullptr && tgt_atom) {
+            edge = pre_st->DOTid() + " -> " + next_st->DOTid();
+        } else {
+            edge = "// " + st->DOTid() + " -> " + next_st->DOTid();
+        }
+
+        *ost << edge << std::endl;
+
+        if (st == next_st) {
+            // FIXME Shouldn't happen.   
+            continue;
+        }
+
+        if (src_atom) {
+            cfg_dot(ost, next_st, visited, st);
+        } else {
+            cfg_dot(ost, next_st, visited, pre_st);
+        }
+    }
+}
+
+void Split::to_dot(std::ostream *ost, Split *split) {
+    *ost << "digraph G {" << std::endl;
+    *ost << "compound=true;" << std::endl;
+
+    EntryPoint ep(std::string(FlightplanConfig::FP_options.flightplanFolder), nullptr);
+    *ost << ep.toDOT() << std::endl;
+
+    *ost << ep.DOTid() + " -> " + split->cleaved->entryDOTid() + "; // Entry point's link" << std::endl;
+    *ost << split->cleaved->toDOT() << std::endl;
+
+    *ost << "}" << std::endl;
+}
+
+void Split::splits_dot(std::ostream *ost) {
+    *ost << "digraph G {" << std::endl;
+    *ost << "compound=true;" << std::endl;
+    for (auto split : Split::Splits) {
+        *ost << split->name << ";" << std::endl;
+        std::set<Split*> ts = split->successor_splits;
+        for (auto next_split : ts) {
+            *ost << split->name + " -> " + next_split->name + ";" << std::endl;
+        }
+    }
+    *ost << "}" << std::endl;
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan_ext.cpp b/frontends/p4/flightplan_ext.cpp
new file mode 100644
index 0000000..c3cd1e2
--- /dev/null
+++ b/frontends/p4/flightplan_ext.cpp
@@ -0,0 +1,55 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#include <iostream>
+#include <fstream>
+
+#include "externInstance.h"
+
+#include "../common/options.h"
+#include "ir/ir.h"
+#include "ir/visitor.h"
+#include "lib/nullstream.h"
+#include "lib/path.h"
+#include "toP4/toP4.h"
+
+#include "flightplan.h"
+
+namespace P4 {
+
+const IR::Node* FlightplanTransf::preorder(IR::Type_Declaration* t) {
+/*
+Make list of Landing-returning entries, remember them for the next pass.
+Remove all Landing-returning declarations
+*/
+    if (t->name == FlightplanConfig::landing_type_name) return nullptr;
+    return t;
+}
+
+const IR::Node* FlightplanTransf::preorder(IR::Method* t) {
+    std::cout << "FlightplanTransf = " << t->toString() << std::endl;
+    auto ty = t->type->as<IR::Type_Method>();
+    if (ty.returnType != nullptr && ty.returnType->is<IR::Type_Name>()) {
+      auto re_ty = ty.returnType->as<IR::Type_Name>();
+      std::cout << "                 a " << ty.parameters->size();
+      std::cout << "                 r " << re_ty.toString() << std::endl;
+      if (re_ty.toString() == FlightplanConfig::landing_type_name) return nullptr;
+    }
+    if (FlightplanConfig::landing_API.find(std::string(t->toString())) != FlightplanConfig::landing_API.end()) return nullptr;
+    return t;
+}
+
+const IR::Node* FlightplanTransf::preorder(IR::MethodCallStatement* mcs) {
+    const IR::MethodCallExpression* mce = mcs->methodCall;
+    auto mi = P4::MethodInstance::resolve(mce, refMap, typeMap);
+
+    if (mi->is<P4::ExternFunction>()) {
+        auto ef = mi->to<P4::ExternFunction>();
+        if (FlightplanConfig::landing_API.find(std::string(ef->method->toString())) != FlightplanConfig::landing_API.end()) return new IR::EmptyStatement();
+    }
+    return mcs;
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan_externs.cpp b/frontends/p4/flightplan_externs.cpp
new file mode 100644
index 0000000..c998331
--- /dev/null
+++ b/frontends/p4/flightplan_externs.cpp
@@ -0,0 +1,109 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#include <assert.h>
+#include <iostream>
+#include <fstream>
+#include <regex>
+
+#include "externInstance.h"
+
+#include "../common/options.h"
+#include "ir/ir.h"
+#include "ir/visitor.h"
+#include "lib/nullstream.h"
+#include "lib/path.h"
+#include "toP4/toP4.h"
+
+#include "flightplan_externs.h"
+
+namespace P4 {
+
+bool FlightplanExterns::calls_extern_function(const IR::MethodCallStatement* mcs) {
+    const IR::MethodCallExpression* mce = mcs->methodCall;
+    auto mi = P4::MethodInstance::resolve(mce, FlightplanConfig::FP_refMap, FlightplanConfig::FP_typeMap);
+    return mi->is<P4::ExternFunction>();
+}
+
+std::string FlightplanExterns::extern_function_name(const IR::MethodCallStatement* mcs) {
+    const IR::MethodCallExpression* mce = mcs->methodCall;
+    auto mi = P4::MethodInstance::resolve(mce, FlightplanConfig::FP_refMap, FlightplanConfig::FP_typeMap);
+    auto ef = mi->to<P4::ExternFunction>();
+    return std::string(ef->method->toString());
+}
+
+bool FlightplanExterns::contains_extern_call(std::set<const FStmt*> &stmts) {
+    bool result = false;
+    for (auto &fstmt : stmts) {
+        const Stmt* stmt  = dynamic_cast<const Stmt*>(fstmt);
+        if (stmt != nullptr) {
+            const IR::MethodCallStatement *mcs = dynamic_cast<const IR::MethodCallStatement*>(stmt->original);
+            if (mcs != nullptr) {
+                result |= calls_extern_function(mcs);
+            }
+        }
+    }
+    return result;
+}
+
+// Remove non-extern calls from a set of statements, and return the resulting set.
+std::set<const FStmt*> FlightplanExterns::extern_subset(std::set<const FStmt*> &stmts) {
+    std::set<const FStmt*> result;
+    for (auto &fstmt : stmts) {
+        const Stmt* stmt  = dynamic_cast<const Stmt*>(fstmt);
+        if (stmt != nullptr) {
+            const IR::MethodCallStatement *mcs = dynamic_cast<const IR::MethodCallStatement*>(stmt->original);
+            if (mcs != nullptr) {
+                if (calls_extern_function(mcs)) {
+                    result.insert(fstmt);
+                }
+            }
+        }
+    }
+
+    return result;
+}
+
+std::string FlightplanExterns::name_of_caller(const IR::MethodCallStatement *mcs) {
+    return std::string(mcs->methodCall->method->toString());
+}
+
+std::string FlightplanExterns::name_of_caller(const FStmt* fstmt) {
+    const Stmt* stmt  = dynamic_cast<const Stmt*>(fstmt);
+    if (stmt != nullptr) {
+        const IR::MethodCallStatement *mcs = dynamic_cast<const IR::MethodCallStatement*>(stmt->original);
+        if (mcs != nullptr) {
+            return name_of_caller(mcs);
+        }
+    }
+    throw std::logic_error("Not a method call");
+}
+
+
+
+// Remove non-excepted extern calls from a set of statements, and return the resulting set.
+std::set<const FStmt*> FlightplanExterns::excepted_subset(std::set<const FStmt*> &stmts) {
+    std::set<const FStmt*> result;
+    for (auto &fstmt : stmts) {
+        const Stmt* stmt  = dynamic_cast<const Stmt*>(fstmt);
+        if (stmt != nullptr) {
+            const IR::MethodCallStatement *mcs = dynamic_cast<const IR::MethodCallStatement*>(stmt->original);
+            if (mcs != nullptr) {
+                if (calls_extern_function(mcs)) {
+
+                    for (std::string excluded_extern_name : FlightplanConfig::FP_options.flightplan_exclusions) {
+                        if (excluded_extern_name == name_of_caller(mcs)) {
+                            result.insert(fstmt);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    return result;
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan_externs.h b/frontends/p4/flightplan_externs.h
new file mode 100644
index 0000000..5e344a2
--- /dev/null
+++ b/frontends/p4/flightplan_externs.h
@@ -0,0 +1,25 @@
+/*
+Flightplan
+Nik Sultana, UPenn, January 2019
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_EXTERNS_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_EXTERNS_H_
+
+#include "flightplan_stmt.h"
+
+namespace P4 {
+
+namespace FlightplanExterns {
+    bool calls_extern_function(const IR::MethodCallStatement* mcs);
+    std::string extern_function_name(const IR::MethodCallStatement* mcs);
+    bool contains_extern_call(std::set<const FStmt*> &stmts);
+    std::set<const FStmt*> extern_subset(std::set<const FStmt*> &stmts);
+    std::set<const FStmt*> excepted_subset(std::set<const FStmt*> &stmts);
+    std::string name_of_caller(const IR::MethodCallStatement *mcs);
+    std::string name_of_caller(const FStmt* fstmt);
+}
+
+}
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_EXTERNS_H_ */
diff --git a/frontends/p4/flightplan_preanalysis.cpp b/frontends/p4/flightplan_preanalysis.cpp
new file mode 100644
index 0000000..44fdc35
--- /dev/null
+++ b/frontends/p4/flightplan_preanalysis.cpp
@@ -0,0 +1,281 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#include <assert.h>
+#include <iostream>
+#include <fstream>
+#include <regex>
+
+#include "externInstance.h"
+
+#include "../common/options.h"
+#include "ir/ir.h"
+#include "ir/visitor.h"
+#include "lib/nullstream.h"
+#include "lib/path.h"
+#include "toP4/toP4.h"
+
+#include "flightplan.h"
+#include "flightplan_preanalysis.h"
+
+namespace P4 {
+
+std::set<const FStmt*> StmtFlow::getNext(const FStmt* stmt, std::set<const FStmt*> &visited) {
+    bool is_statement = atomic_stmt(stmt);
+
+    if (!is_statement && visited.find(stmt) == visited.end()) {
+        return getIn(Direction::Forward, stmt, visited);
+    }
+
+    visited.insert(stmt);
+
+    // Continue moving in the same direction if we can, otherwise get out.
+    if (stmt->get_next() != nullptr) {
+        return std::set<const FStmt*>{stmt->get_next()};
+    } else {
+        return getOut(Direction::Forward, stmt, visited);
+    }
+}
+
+std::set<const FStmt*> StmtFlow::getPrev(const FStmt* stmt, std::set<const FStmt*> &visited) {
+    // FIXME DRY with getNext
+
+    bool is_statement = atomic_stmt(stmt);
+
+    if (!is_statement && visited.find(stmt) == visited.end()) {
+        return getIn(Direction::Backward, stmt, visited);
+    }
+
+    visited.insert(stmt);
+
+    // Continue moving in the same direction if we can, otherwise get out.
+    if (stmt->get_prev() != nullptr) {
+        return std::set<const FStmt*>{stmt->get_prev()};
+    } else {
+        return getOut(Direction::Backward, stmt, visited);
+    }
+}
+
+std::set<const FStmt*> StmtFlow::getOut(StmtFlow::Direction dir, const FStmt* stmt, std::set<const FStmt*> &visited) {
+    visited.insert(stmt);
+
+    if (stmt->getContainer() == nullptr) {
+        // In case we're at the top-level (and can't get out) we first try continuing to travel
+        // in the same direction before giving up.
+        const FStmt *next = nullptr;
+        switch (dir) {
+            case Direction::Forward:
+                next = stmt->get_next();
+            case Direction::Backward:
+                next = stmt->get_prev();
+        }
+
+        if (next != nullptr) {
+            return std::set<const FStmt*>{next};
+        } else {
+            // This is how it ends: there's no containing structure, and no next step.
+            return std::set<const FStmt*>{};
+        }
+    } else {
+        switch (dir) {
+            case Direction::Forward:
+                return getNext(stmt->getContainer(), visited);
+            case Direction::Backward:
+                return getPrev(stmt->getContainer(), visited);
+        }
+    }
+}
+
+std::set<const FStmt*> StmtFlow::getIn(StmtFlow::Direction dir, const FStmt* stmt, std::set<const FStmt*> &visited) {
+    visited.insert(stmt);
+
+    const BlockStmt *bs = dynamic_cast<const BlockStmt*>(stmt);
+    if (bs != nullptr) {
+        if (bs->getEntry() != nullptr) {
+            switch (dir) {
+                case Direction::Forward:
+                    return std::set<const FStmt *>{bs->getEntry()};
+                case Direction::Backward:
+                    return std::set<const FStmt *>{bs->getLast()};
+            }
+        } else {
+            throw std::logic_error("Impossible: empty block");
+        }
+    }
+    const IfStmt *ifst = dynamic_cast<const IfStmt*>(stmt);
+    if (ifst != nullptr) {
+        assert(ifst->get_ifTrue() != nullptr);
+        std::set<const FStmt*> result{ifst->get_ifTrue()};
+        if (ifst->get_ifFalse() != nullptr) {
+            result.insert(ifst->get_ifFalse());
+        }
+        return result;
+    }
+    const SwitchStmt *swst = dynamic_cast<const SwitchStmt*>(stmt);
+    if (swst != nullptr) {
+        std::set<const FStmt*> result;
+        for (auto c : swst->getCases()) {
+            result.insert(c.get_stmt());
+        }
+        return result;
+    }
+    throw std::logic_error("getIn: Unknown statement type");
+}
+
+std::string StmtFlow::stmt_kind(const FStmt* stmt) {
+    if (stmt == nullptr) {
+        throw std::logic_error("atomic_stmt: null stmt");
+    }
+    const BlockStmt *bs = dynamic_cast<const BlockStmt*>(stmt);
+    if (bs != nullptr) {
+        return "BlockStmt";
+    }
+    const Stmt *st = dynamic_cast<const Stmt*>(stmt);
+    if (st != nullptr) {
+        return "Stmt";
+    }
+    const TransferPoint *tp = dynamic_cast<const TransferPoint*>(stmt);
+    if (tp != nullptr) {
+        return "TransferPoint";
+    }
+    const IfStmt *ifst = dynamic_cast<const IfStmt*>(stmt);
+    if (ifst != nullptr) {
+        return "IfStmt";
+    }
+    const SwitchStmt *swst = dynamic_cast<const SwitchStmt*>(stmt);
+    if (swst != nullptr) {
+        return "SwitchStmt";
+    }
+    throw std::logic_error("stmt_kind: Unknown statement type");
+}
+
+bool StmtFlow::atomic_stmt(const FStmt* stmt) {
+    if (stmt == nullptr) {
+        throw std::logic_error("atomic_stmt: null stmt");
+    }
+    const BlockStmt *bs = dynamic_cast<const BlockStmt*>(stmt);
+    if (bs != nullptr) {
+        return false;
+    }
+    const Stmt *st = dynamic_cast<const Stmt*>(stmt);
+    if (st != nullptr) {
+        return true;
+    }
+    const TransferPoint *tp = dynamic_cast<const TransferPoint*>(stmt);
+    if (tp != nullptr) {
+        return true;
+    }
+    const IfStmt *ifst = dynamic_cast<const IfStmt*>(stmt);
+    if (ifst != nullptr) {
+        return false;
+    }
+    const SwitchStmt *swst = dynamic_cast<const SwitchStmt*>(stmt);
+    if (swst != nullptr) {
+        return false;
+    }
+    throw std::logic_error("atomic_stmt: Unknown statement type");
+}
+
+bool StmtFlow::transfer_stmt(const FStmt* stmt) {
+    const TransferPoint *tp = dynamic_cast<const TransferPoint*>(stmt);
+    if (tp != nullptr) {
+        return true;
+    }
+    return false;
+}
+
+Split* StmtFlow::transfers_to(const FStmt* stmt) {
+    const TransferPoint *tp = dynamic_cast<const TransferPoint*>(stmt);
+    if (tp == nullptr) {
+        throw std::logic_error("Not a TransferPoint");
+    }
+    Split* result = nullptr;
+    for (auto split : Split::Splits) {
+
+        std::string str(split->output_file);
+        if (str.find(TransferPoint::flyto_target(std::string(tp->original->srcInfo.toBriefSourceFragment()))) != std::string::npos) {
+            result = split;
+            break;
+        }
+    }
+    assert(result != nullptr);
+    return result;
+}
+
+std::set<const FStmt*> StmtFlow::step(StmtFlow::Direction dir, const FStmt* stmt, std::set<const FStmt*> &visited) {
+    switch (dir) {
+        case Direction::Forward:
+            return getNext(stmt, visited);
+        case Direction::Backward:
+            return getPrev(stmt, visited);
+    }
+}
+
+std::set<const FStmt*> StmtFlow::step(StmtFlow::Direction dir, std::set<const FStmt*> stmts, std::set<const FStmt*> &visited) {
+    std::set<const FStmt*> result;
+    for (auto stmt : stmts) {
+        std::set<const FStmt*> pre_result = step(dir, stmt, visited);
+        if (pre_result.size() > 0) {
+            for (auto s : pre_result) {
+                result.insert(s);
+            }
+        }
+    }
+    return result;
+}
+
+std::string TransferPoint::flyto_target(const std::string& expression) {
+    std::regex regex("flyto\\(([a-zA-Z0-9_]+)\\(\\)\\)");
+    std::smatch match;
+    if (!std::regex_search(expression.begin(), expression.end(), match, regex)) {
+        throw std::logic_error("TransferPoint::flyto_target: no match");
+    }
+    return match[1];
+}
+
+void transitive_closure(const FStmt* st, std::set<const FStmt*> &visited, const FStmt* pre_st=nullptr) {
+    std::set<const FStmt*> next = step(StmtFlow::Direction::Forward, st, visited);
+    bool src_atom = StmtFlow::atomic_stmt(st);
+    for (auto next_st : next) {
+        bool tgt_atom = StmtFlow::atomic_stmt(next_st);
+        if (st == next_st) {
+            throw std::logic_error("Unexpected");
+        }
+
+        if (src_atom) {
+            transitive_closure(next_st, visited, st);
+        } else {
+            transitive_closure(next_st, visited, pre_st);
+        }
+    }
+}
+
+std::set<const FStmt*> StmtFlow::TransitClos(const FStmt* stmt) {
+    std::set<const FStmt*> visited;
+    transitive_closure(stmt, visited);
+    return visited;
+}
+
+StmtFlow::P4_Stmt_Kind StmtFlow::p4_classify(IR::StatOrDecl* sod) {
+    if (nullptr == dynamic_cast<const IR::AssignmentStatement*>(sod)) {
+        return P4_Stmt_Kind::AssignmentStatement;
+    } else if (nullptr == dynamic_cast<const IR::MethodCallStatement*>(sod)) {
+        return P4_Stmt_Kind::MethodCallStatement;
+    } else if (nullptr == dynamic_cast<const IR::BlockStatement*>(sod)) {
+        return P4_Stmt_Kind::BlockStatement;
+    } else if (nullptr == dynamic_cast<const IR::StatOrDecl*>(sod)) {
+        return P4_Stmt_Kind::StatOrDecl;
+    } else if (nullptr == dynamic_cast<const IR::Statement*>(sod)) {
+        return P4_Stmt_Kind::Statement;
+    } else if (nullptr == dynamic_cast<const IR::Declaration*>(sod)) {
+        return P4_Stmt_Kind::Declaration;
+    } else if (nullptr == dynamic_cast<const IR::IfStatement*>(sod)) {
+        return P4_Stmt_Kind::IfStatement;
+    } else {
+        throw std::logic_error("Unrecognised StatOrDecl");
+    }
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan_preanalysis.h b/frontends/p4/flightplan_preanalysis.h
new file mode 100644
index 0000000..b3b3ac2
--- /dev/null
+++ b/frontends/p4/flightplan_preanalysis.h
@@ -0,0 +1,41 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_PREANALYSIS_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_PREANALYSIS_H_
+
+#include "flightplan.h"
+#include "flightplan_convert.h"
+
+namespace P4 {
+
+namespace StmtFlow {
+    enum class Direction {Forward, Backward};
+
+    bool atomic_stmt(const FStmt* stmt);
+    bool transfer_stmt(const FStmt* stmt);
+    Split* transfers_to(const FStmt* stmt);
+
+    std::set<const FStmt*> getNext(const FStmt* stmt, std::set<const FStmt*> &visited);
+    std::set<const FStmt*> getPrev(const FStmt* stmt, std::set<const FStmt*> &visited);
+    std::set<const FStmt*> getOut(Direction dir, const FStmt* stmt, std::set<const FStmt*> &visited);
+    std::set<const FStmt*> getIn(Direction dir, const FStmt* stmt, std::set<const FStmt*> &visited);
+    std::set<const FStmt*> step(Direction dir, const FStmt* stmt, std::set<const FStmt*> &visited);
+    std::set<const FStmt*> step(Direction dir, std::set<const FStmt*> stmts, std::set<const FStmt*> &visited);
+
+    void cfg_dot(std::ostream *ost, const FStmt* st, std::set<const FStmt*> &visited, const FStmt* pre_st=nullptr);
+
+    std::string stmt_kind(const FStmt* stmt);
+
+    std::set<const FStmt*> TransitClos(const FStmt* stmt);
+    std::set<const FStmt*> transfers(std::set<const FStmt*>);
+
+    enum class P4_Stmt_Kind {AssignmentStatement, MethodCallStatement, BlockStatement, StatOrDecl, Statement, Declaration, IfStatement};
+    P4_Stmt_Kind p4_classify(IR::StatOrDecl* sod);
+}
+
+}
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_PREANALYSIS_H_ */
diff --git a/frontends/p4/flightplan_stmt.cpp b/frontends/p4/flightplan_stmt.cpp
new file mode 100644
index 0000000..fd3bf8c
--- /dev/null
+++ b/frontends/p4/flightplan_stmt.cpp
@@ -0,0 +1,242 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#include <assert.h>
+#include <iostream>
+#include <fstream>
+
+#include "externInstance.h"
+
+#include "../common/options.h"
+#include "ir/ir.h"
+#include "ir/visitor.h"
+#include "lib/nullstream.h"
+#include "lib/path.h"
+#include "toP4/toP4.h"
+
+#include "flightplan.h"
+#include "flightplan_annotate.h"
+
+namespace P4 {
+
+FStmt::FStmt (const FStmt* container, std::string dest_path, FStmt* prev = nullptr, FStmt* next = nullptr) : DOT(FlightplanConfig::dot_id++), container(container), prev(prev), next(next) {
+    splits.insert(Split::current_split(dest_path, this));
+}
+
+FStmt::FStmt (const FStmt* container, unsigned dot_id, FStmt* prev, FStmt* next) : DOT(dot_id), container(container), prev(prev), next(next) {}
+
+Stmt::Stmt (const FStmt* container, std::string dest_path, const IR::AssignmentStatement* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next), original(stmt) {}
+Stmt::Stmt (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next), original(stmt) {}
+Stmt::Stmt (const FStmt* container, std::string dest_path, const IR::Declaration* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next), original(stmt) {
+    std::cout << "DECLARATION: " << stmt->toString() << std::endl;
+}
+Stmt::Stmt (const FStmt* container, std::string dest_path, const IR::ReturnStatement* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next), original(stmt) {}
+
+TransferPoint::TransferPoint (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next), original(stmt) {}
+
+BlockStmt::BlockStmt (const FStmt* container, std::string dest_path, const IR::BlockStatement* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next), original(stmt) {
+    std::string abbrev_name = "block";
+    clust_id = new std::string("cluster_" + abbrev_name + "_" + DOTid());
+
+    FStmt* last = nullptr;
+    // Deconstruct stmt into statements, have block_entry point to the first of them.
+    for (const IR::StatOrDecl* c : stmt->components) {
+        if (block_entry == nullptr) {
+            assert(last == nullptr);
+            last = StmtConvert::encapsulate(this, dest_path, c, nullptr, nullptr);
+            block_entry = last;
+        } else {
+            auto new_last = StmtConvert::encapsulate(this, dest_path, c, last, nullptr);
+            last->set_next(new_last);
+            last = new_last;
+        }
+    }
+}
+
+IfStmt::IfStmt (const FStmt* container, std::string dest_path, const IR::IfStatement* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next) {
+    std::string abbrev_name = "if";
+    clust_id = new std::string("cluster_" + abbrev_name + "_" + DOTid());
+
+    condition = stmt->condition;
+    ifTrue = StmtConvert::encapsulate(this, dest_path, stmt->ifTrue, nullptr, nullptr);
+    if (stmt->ifFalse == nullptr) {
+        ifFalse = nullptr;
+    } else {
+        ifFalse = StmtConvert::encapsulate(this, dest_path, stmt->ifFalse, nullptr, nullptr);
+    }
+}
+
+SwitchStmt::SwitchStmt (const FStmt* container, std::string dest_path, const IR::SwitchStatement* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next) {
+    expression = stmt->expression;
+    for (auto c : stmt->cases) {
+        Case cs = Case(c->label, StmtConvert::encapsulate(this, dest_path, c->statement, nullptr, nullptr));
+        cases.push_back(cs);
+    }
+}
+
+const IR::StatOrDecl* Stmt::toStatement() const {
+    return original;
+}
+
+cstring Stmt::toString() const {
+    return std::string("/*Stmt: " + splits_string() + " " + toP4String() + " */");
+}
+
+cstring BlockStmt::toString() const {
+    return "/*BlockStmt*/";
+}
+
+cstring IfStmt::toString() const {
+    return "/*IfStmt*/";
+}
+
+cstring SwitchStmt::toString() const {
+    return "/*SwitchStmt*/";
+}
+
+cstring TransferPoint::toString() const {
+    return "/*flyto: " + toP4String() + "*/";
+}
+
+const IR::StatOrDecl* BlockStmt::toStatement() const {
+    // Reconstruct block of statements from block_entry
+    const FStmt* cursor = block_entry;
+    IR::BlockStatement* result = new IR::BlockStatement();
+    while (cursor != nullptr) {
+        result->push_back(cursor->toStatement());
+        cursor = cursor->get_next();
+    }
+    return result;
+}
+
+const IR::Statement* IfStmt::trueStatement() const {
+    const IR::Statement* result = nullptr;
+    if (ifTrue != nullptr) {
+        result = &ifTrue->toStatement()->as<IR::Statement>();
+    }
+    return result;
+}
+
+const IR::Statement* IfStmt::falseStatement() const {
+    const IR::Statement* result = nullptr;
+    if (ifFalse != nullptr) {
+        result = &ifFalse->toStatement()->as<IR::Statement>();
+    }
+    return result;
+}
+
+const IR::StatOrDecl* IfStmt::toStatement() const {
+    // Reconstruct block of statements from block_entry
+    IR::IfStatement* result = new IR::IfStatement(condition, trueStatement(), falseStatement());
+    return result;
+}
+
+const IR::StatOrDecl* SwitchStmt::toStatement() const {
+    IR::Vector<IR::SwitchCase> cases;
+    for (auto c : this->cases) {
+        IR::SwitchCase *sc = new IR::SwitchCase(c.label, c.get_statement());
+        cases.push_back(sc);
+    }
+    IR::SwitchStatement* result = new IR::SwitchStatement(expression, cases);
+    return result;
+}
+
+FStmt* StmtConvert::encapsulate (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* mcs, FStmt* prev, FStmt* next) {
+    const IR::MethodCallExpression* mce = mcs->methodCall;
+
+    auto mi = P4::MethodInstance::resolve(mce, FlightplanConfig::FP_refMap, FlightplanConfig::FP_typeMap);
+
+    if (mi->is<P4::ExternFunction>()) {
+        auto ef = mi->to<P4::ExternFunction>();
+        std::cout << "Flightplan: call statement: " << ef->method->toString() << std::endl;
+        if (FlightplanConfig::FP_options.flightplan_mode != CompilerOptions::FlightplanMode::Split) {
+                std::cout << "WARNING: not effecting Flightplan transfer since not in Split mode" << std::endl;
+        } else {
+            if (FlightplanConfig::landing_API.find(std::string(ef->method->toString())) != FlightplanConfig::landing_API.end()) {
+                // We only insert a TransferPoint at this stage. Then during a later pass we'll annotate each statement on which split(s) is belongs to.
+                auto tp = new TransferPoint (container, dest_path, mcs, prev, next);
+                // NOTE assuming that the parameter to flyto() hasn't been tampered with by any earlier passes.
+                tp->transfer_to = TransferPoint::flyto_target(std::string(mcs->srcInfo.toBriefSourceFragment()));
+                std::cout << "Flightplan transfer: " << tp->transfer_to << std::endl;
+                return tp;
+            }
+        }
+    } else {
+        std::cout << "-> " << mce->toString() << std::endl;
+    }
+
+    if (!mi->is<P4::ExternFunction>()) {
+      return new Stmt (container, dest_path, mcs, prev, next);
+    }
+
+    return new Stmt (container, dest_path, mcs, prev, next);
+}
+
+FStmt* TransferPoint::clone() const {
+    TransferPoint* result = new TransferPoint(container, dot_id, prev, next);
+    result->original = this->original;
+    /*FIXME copy state*/
+    return result;
+}
+
+FStmt* Stmt::clone() const {
+    // FIXME have cloning generate new DOTid, to show multiple splits in the same graph
+    Stmt* result = new Stmt(container, dot_id, prev, next);
+    result->original = this->original;
+    assert(result->original != nullptr);
+    return result;
+}
+
+FStmt* BlockStmt::clone() const {
+    BlockStmt* result = new BlockStmt(container, dot_id, prev, next);
+    result->original = this->original;
+    result->clust_id = this->clust_id;
+    result->block_entry = this->block_entry;
+    return result;
+}
+
+FStmt* IfStmt::clone() const {
+    IfStmt* result = new IfStmt(container, dot_id, prev, next);
+    result->condition = this->condition;
+    result->clust_id = this->clust_id;
+    result->ifTrue = this->ifTrue;
+    result->ifFalse = this->ifFalse;
+    return result;
+}
+
+FStmt* SwitchStmt::clone() const {
+    SwitchStmt* result = new SwitchStmt(container, dot_id, prev, next);
+    result->expression = this->expression;
+    result->clust_id = this->clust_id;
+    result->cases = this->cases;
+    return result;
+}
+
+BlockStmt::BlockStmt (const FStmt* container, std::string dest_path, FStmt* stmt, FStmt* prev, FStmt* next) : FStmt(container, dest_path, prev, next) {
+    std::string abbrev_name = "block";
+    clust_id = new std::string("cluster_" + abbrev_name + "_" + DOTid());
+
+    block_entry = stmt;
+}
+
+FStmt::Kind FStmt::classify(FStmt* fstmt) {
+    if (dynamic_cast<EntryPoint*>(fstmt) != nullptr) {
+        return FStmt::Kind::EntryPoint;
+    } else if (dynamic_cast<TransferPoint*>(fstmt) != nullptr) {
+        return FStmt::Kind::TransferPoint;
+    } else if (dynamic_cast<Stmt*>(fstmt) != nullptr) {
+        return FStmt::Kind::Stmt;
+    } else if (dynamic_cast<BlockStmt*>(fstmt) != nullptr) {
+        return FStmt::Kind::BlockStmt;
+    } else if (dynamic_cast<IfStmt*>(fstmt) != nullptr) {
+        return FStmt::Kind::IfStmt;
+    } else if (dynamic_cast<SwitchStmt*>(fstmt) != nullptr) {
+        return FStmt::Kind::SwitchStmt;
+    } else {
+        throw std::logic_error("Unrecognised FStmt");
+    }
+}
+
+}  // namespace P4
diff --git a/frontends/p4/flightplan_stmt.h b/frontends/p4/flightplan_stmt.h
new file mode 100644
index 0000000..677421c
--- /dev/null
+++ b/frontends/p4/flightplan_stmt.h
@@ -0,0 +1,335 @@
+/*
+Flightplan
+Nik Sultana, UPenn, July 2018
+*/
+
+#ifndef _FRONTENDS_P4_FLIGHTPLAN_STMT_H_
+#define _FRONTENDS_P4_FLIGHTPLAN_STMT_H_
+
+#include "flightplan.h"
+
+namespace P4 {
+
+class FStmt : public DOT {
+ protected:
+    friend class ProtoAnnotate;
+    template <class Ann> friend class ProtoAnnotateGeneric;
+    friend class FStmtDeepClone;
+    friend class Dleary;
+    friend class Flightplan_Annotator;
+
+    const FStmt* container = nullptr;
+
+    FStmt* prev = nullptr;
+    FStmt* next = nullptr;
+
+    void clone_from(FStmt* from_stmt) {
+        container = from_stmt->container;
+        prev = nullptr;
+        next = nullptr;
+        splits.clear();
+        for (auto s : from_stmt->splits) {
+            splits.insert(s);
+        }
+    }
+
+    FStmt (const FStmt* container, unsigned dot_id, FStmt* prev, FStmt* next);
+
+ public:
+    template <class Out, class State> friend class FStmtAnalyse;
+
+    enum class Kind {EntryPoint, TransferPoint, Stmt, BlockStmt, IfStmt, SwitchStmt};
+    static Kind classify(FStmt* fstmt);
+
+    std::set<Split*> splits;
+    std::string splits_string() const {
+      std::string result = "splits{";
+      bool started = false;
+      for (Split* s : splits) {
+        if (!started) result += s->name;
+        else result += " " + s->name;
+        started = true;
+      }
+      return result + "}";
+    }
+    explicit FStmt (const FStmt* container, std::string dest_path, FStmt* prev, FStmt* next);
+
+    // Purge all other splits that this stmt links to, except for one.
+    // For "effected" splits, this is used to purge other split
+    // info from each stmt in a split.
+    void keep_split(Split *split) {
+        assert(split != nullptr);
+        // FIXME these assertions should be switched on
+//        assert(splits.size() > 0);
+//        assert(splits.find(split) != splits.end());
+        splits.clear();
+        splits.insert(split);
+    }
+
+    void set_next (FStmt* next) {
+        this->next = next;
+    }
+
+    void set_prev (FStmt* prev) {
+        this->prev = prev;
+    }
+
+    FStmt* get_next () const {
+        return this->next;
+    }
+
+    FStmt* get_prev () const {
+        return this->prev;
+    }
+
+    const FStmt* getContainer() const {
+       return container;
+    }
+
+    std::string link_from_prev() const;
+
+    virtual FStmt* clone() const = 0;
+
+    virtual const IR::StatOrDecl* toStatement() const = 0;
+
+    virtual cstring toString() const = 0;
+
+    static void toString(const std::vector<const FStmt*> &steps) {
+        for (auto s : steps) {
+            std::cout << ":" << s->toString() << std::endl;
+        }
+    }
+
+    static void toFile(cstring inputfile, const cstring destination, const IR::P4Program* prog) {
+        if (!destination.isNullOrEmpty()) {
+            Util::PathName path(destination);
+            std::ostream *ppStream = new std::ofstream(path.toString(), std::ios_base::app);
+            *ppStream << FlightplanConfig::header_comment << std::endl << std::endl;
+            P4::ToP4 top4(ppStream, false, inputfile);
+            (void)prog->apply(top4);
+        } else {
+            ::error("Null filename?");
+        }
+    }
+
+    std::string toP4String() const {
+        auto stmt = this->toStatement();
+        std::ostringstream ppStream;
+        P4::ToP4 top4(&ppStream, false);
+        (void)stmt->apply(top4);
+        return ppStream.str();
+    }
+
+    static std::string toP4String(const IR::Expression* expr) {
+        std::ostringstream ppStream;
+        P4::ToP4 top4(&ppStream, false);
+        (void)expr->apply(top4);
+        return ppStream.str();
+    }
+
+    static std::string toP4String(const IR::Type* type) {
+        std::ostringstream ppStream;
+        P4::ToP4 top4(&ppStream, false);
+        (void)type->apply(top4);
+        return ppStream.str();
+    }
+
+    static std::string toP4String(const IR::StatOrDecl* stmt) {
+        std::ostringstream ppStream;
+        P4::ToP4 top4(&ppStream, false);
+        (void)stmt->apply(top4);
+        return ppStream.str();
+    }
+};
+
+class EntryPoint : public FStmt {
+ public:
+    EntryPoint (std::string dest_path, FStmt* next) : FStmt (nullptr, dest_path, nullptr, next) {}
+
+    const IR::StatOrDecl* toStatement() const override {
+        return new IR::EmptyStatement();
+    }
+    cstring toString() const override {
+        return std::string("/*EntryPoint*/");
+    }
+    std::string toDOT() const override {
+      std::string result = DOTid() + " [label=\"\",color=white,style=invis]; // Entry point\n";
+      return result;
+    }
+    FStmt* clone() const override {
+        throw std::logic_error("Cannot clone EntryPoint");
+    }
+};
+
+class TransferPoint : public FStmt {
+
+    TransferPoint (const FStmt* container, unsigned dot_id, FStmt* prev, FStmt* next) : FStmt (container, dot_id, prev, next) {}
+
+ public:
+    const IR::StatOrDecl* original = nullptr;
+    std::string transfer_to;
+
+    TransferPoint (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* stmt, FStmt* prev, FStmt* next);
+    const IR::StatOrDecl* toStatement() const override {
+        return original;
+    }
+    cstring toString() const override;
+    std::string toDOT() const override;
+
+    FStmt* clone() const override;
+
+    // FIXME ensure that types have defined width.
+    static void free_vars(std::map<std::string,std::string/*FIXME use AST objects*/> &context);
+
+    static std::string flyto_target(const std::string& expression);
+};
+
+class Stmt : public FStmt {
+    friend class ProtoAnnotate;
+    template <class Ann> friend class ProtoAnnotateGeneric;
+    friend class Cleary;
+    friend class Dleary;
+    friend class Flightplan_Annotator;
+    friend class ExternScanner;
+    Stmt (const FStmt* container, unsigned dot_id, FStmt* prev, FStmt* next) : FStmt (container, dot_id, prev, next) {}
+ public:
+    const IR::StatOrDecl* original = nullptr;
+    Stmt (const FStmt* container, std::string dest_path, const IR::AssignmentStatement* stmt, FStmt* prev, FStmt* next);
+    Stmt (const FStmt* container, std::string dest_path, const IR::MethodCallStatement* stmt, FStmt* prev, FStmt* next);
+    Stmt (const FStmt* container, std::string dest_path, const IR::Declaration* stmt, FStmt* prev, FStmt* next);
+    Stmt (const FStmt* container, std::string dest_path, const IR::ReturnStatement* stmt, FStmt* prev, FStmt* next);
+
+    const IR::StatOrDecl* toStatement() const override;
+    cstring toString() const override;
+    std::string toDOT() const override;
+    FStmt* clone() const override;
+};
+
+class BlockStmt : public FStmt {
+    const IR::BlockStatement* original = nullptr;
+    FStmt* block_entry = nullptr;
+    BlockStmt (const FStmt* container, unsigned dot_id, FStmt* prev, FStmt* next) : FStmt (container, dot_id, prev, next) {}
+ public:
+    template <class Out, class State> friend class FStmtAnalyse;
+    friend class Dleary;
+    BlockStmt (const FStmt* container, std::string dest_path, const IR::BlockStatement* stmt, FStmt* prev, FStmt* next);
+    BlockStmt (const FStmt* container, std::string dest_path, FStmt* stmt, FStmt* prev, FStmt* next);
+
+    const IR::StatOrDecl* toStatement() const override;
+    cstring toString() const override;
+    std::string toDOT() const override;
+    std::string entryDOTid() const override;
+    FStmt* getEntry() const {
+        return block_entry;
+    }
+    void setEntry(FStmt* stmt) {
+        block_entry = stmt;
+    }
+    const FStmt* getLast() const {
+        const FStmt* cursor = block_entry;
+        assert(cursor != nullptr);
+        // Walk to the last entry.
+        while (cursor->get_next() != nullptr) {
+            cursor = cursor->get_next();
+        }
+        return cursor;
+    }
+    FStmt* clone() const override;
+};
+
+class IfStmt : public FStmt {
+    const IR::Expression *condition = nullptr;
+    FStmt* ifTrue = nullptr;
+    FStmt* ifFalse = nullptr;
+    IfStmt (const FStmt* container, unsigned dot_id, FStmt* prev, FStmt* next) : FStmt (container, dot_id, prev, next) {}
+ public:
+    template <class Out, class State> friend class FStmtAnalyse;
+    friend class FStmtDeepClone;
+    friend class Flightplan_Annotator;
+    IfStmt (const FStmt* container, std::string dest_path, const IR::IfStatement* stmt, FStmt* prev, FStmt* next);
+
+    const IR::StatOrDecl* toStatement() const override;
+    cstring toString() const override;
+    std::string toDOT() const override;
+
+    const IR::Statement* trueStatement() const;
+    const IR::Statement* falseStatement() const;
+
+    FStmt* get_ifTrue() const {
+        return ifTrue;
+    }
+    FStmt* get_ifFalse() const {
+        return ifFalse;
+    }
+    void set_ifTrue(FStmt* stmt) {
+        ifTrue = stmt;
+    }
+    void set_ifFalse(FStmt* stmt) {
+        ifFalse = stmt;
+    }
+    const IR::Expression* getCondition() const {
+      return condition;
+    }
+    FStmt* clone() const override;
+};
+
+class SwitchStmt : public FStmt {
+    const IR::Expression *expression = nullptr;
+    SwitchStmt (const FStmt* container, unsigned dot_id, FStmt* prev, FStmt* next) : FStmt (container, dot_id, prev, next) {}
+ public:
+    SwitchStmt (const FStmt* container, std::string dest_path, const IR::SwitchStatement* stmt, FStmt* prev, FStmt* next);
+
+    const IR::StatOrDecl* toStatement() const override;
+    cstring toString() const override;
+    std::string toDOT() const override;
+
+    friend class FStmtDeepClone;
+    friend class Flightplan_Annotator;
+    friend class Dleary;
+
+    class Case final {
+        FStmt *stmt = nullptr;
+     public:
+        template <class Out, class State> friend class FStmtAnalyse;
+        friend class FStmtDeepClone;
+        friend class Flightplan_Annotator;
+        friend class Dleary;
+        const IR::Expression *label = nullptr;
+        Case (const IR::Expression *label, FStmt *stmt) : label(label), stmt(stmt) {}
+        const FStmt* get_stmt() const {
+            return stmt;
+        }
+        const IR::Statement* get_statement() const {
+            const IR::Statement *result = nullptr;
+            if (stmt != nullptr) {
+                result = &stmt->toStatement()->as<IR::Statement>();
+            }
+            return result;
+        }
+        FStmt* get_fstmt() const {
+            return this->stmt;
+        }
+        void set_fstmt(FStmt* stmt) {
+            this->stmt = stmt;
+        }
+        const IR::Expression* getLabel() const {
+            return label;
+        }
+    };
+ private:
+    std::vector<Case> cases;
+ public:
+    std::vector<Case> getCases() const {
+        return cases;
+    }
+    void setCaseStatement(int i, FStmt* stmt) {
+        cases[i].set_fstmt(stmt);
+    }
+    const IR::Expression* getExpression() const {
+        return expression;
+    }
+    FStmt* clone() const override;
+};
+}
+
+#endif /* _FRONTENDS_P4_FLIGHTPLAN_STMT_H_ */
diff --git a/frontends/p4/frontend.cpp b/frontends/p4/frontend.cpp
index ba7266e..437a5b2 100644
--- a/frontends/p4/frontend.cpp
+++ b/frontends/p4/frontend.cpp
@@ -1,5 +1,6 @@
 /*
 Copyright 2013-present Barefoot Networks, Inc.
+Copyright 2020 University of Pennsylvania
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -36,6 +37,8 @@ limitations under the License.
 #include "directCalls.h"
 #include "dontcareArgs.h"
 #include "evaluator/evaluator.h"
+#include "flightplan.h"
+#include "flightplan_annotate.h"
 #include "frontends/common/constantFolding.h"
 #include "functionsInlining.h"
 #include "hierarchicalNames.h"
@@ -149,6 +152,39 @@ const IR::P4Program *FrontEnd::run(const CompilerOptions &options, const IR::P4P
         new BindTypeVariables(&refMap, &typeMap),
         new StructInitializers(&refMap, &typeMap),
         new TableKeyNames(&refMap, &typeMap),
+
+	// NOTE more pass wrangling  
+        //new SimplifyControlFlow(&refMap, &typeMap),
+        //new UniqueNames(&refMap),  // Give each local declaration a unique internal name
+        new MoveDeclarations(),  // Move all local declarations to the beginning
+        new MoveInitializers(),
+        //new SideEffectOrdering(&refMap, &typeMap, skipSideEffectOrdering),
+        new SpecializeAll(&refMap, &typeMap),
+        evaluator,
+
+	// NOTE nik snipped this block from later into here
+        new Inline(&refMap, &typeMap, evaluator),
+        new InlineActions(&refMap, &typeMap),
+        new InlineFunctions(&refMap, &typeMap),
+
+	//// These were added later
+        //new UniqueNames(&refMap),  // needed again after inlining
+        //new UniqueParameters(&refMap, &typeMap),
+        //new HierarchicalNames(),
+        //new SetHeaders(&refMap, &typeMap),
+        //new ClearTypeMap(&typeMap),
+        //evaluator,
+        //new CheckConstants(&refMap, &typeMap),
+        //new UselessCasts(&refMap, &typeMap),
+        //new ClearTypeMap(&typeMap),
+        //new ConstantFolding(&refMap, &typeMap),
+        //new SimplifyControlFlow(&refMap, &typeMap),
+        new ConstantFolding(&refMap, &typeMap),
+        new StrengthReduction(&refMap, &typeMap),
+        new UselessCasts(&refMap, &typeMap),
+        new SimplifyControlFlow(&refMap, &typeMap),
+
+new Flightplan(&refMap, &typeMap, options),
         // Another round of constant folding, using type information.
         new ConstantFolding(&refMap, &typeMap),
         new StrengthReduction(&refMap, &typeMap),
@@ -158,6 +194,9 @@ const IR::P4Program *FrontEnd::run(const CompilerOptions &options, const IR::P4P
         new RemoveAllUnusedDeclarations(&refMap, true),
         new SimplifyParsers(&refMap),
         new ResetHeaders(&refMap, &typeMap),
+
+//        new Flightplan(&refMap, &typeMap, options),
+
         new UniqueNames(&refMap),  // Give each local declaration a unique internal name
         new MoveDeclarations(),  // Move all local declarations to the beginning
         new MoveInitializers(),
@@ -169,6 +208,7 @@ const IR::P4Program *FrontEnd::run(const CompilerOptions &options, const IR::P4P
         new UniqueParameters(&refMap, &typeMap),
         new SimplifyControlFlow(&refMap, &typeMap),
         new SpecializeAll(&refMap, &typeMap),
+ 
         new RemoveParserControlFlow(&refMap, &typeMap),
         new RemoveReturns(&refMap),
         new RemoveDontcareArgs(&refMap, &typeMap),
@@ -179,6 +219,7 @@ const IR::P4Program *FrontEnd::run(const CompilerOptions &options, const IR::P4P
         new Inline(&refMap, &typeMap, evaluator),
         new InlineActions(&refMap, &typeMap),
         new InlineFunctions(&refMap, &typeMap),
+ 
         // Check for constants only after inlining
         new CheckConstants(&refMap, &typeMap),
         new SimplifyControlFlow(&refMap, &typeMap),
@@ -189,6 +230,23 @@ const IR::P4Program *FrontEnd::run(const CompilerOptions &options, const IR::P4P
         new UniqueParameters(&refMap, &typeMap),
         new SimplifyControlFlow(&refMap, &typeMap),
         new HierarchicalNames(),
+// NOTE repeated by me
+        new ClearTypeMap(&typeMap),
+        evaluator,
+        new Inline(&refMap, &typeMap, evaluator),
+        new InlineActions(&refMap, &typeMap),
+        new InlineFunctions(&refMap, &typeMap),
+        // Check for constants only after inlining
+        new CheckConstants(&refMap, &typeMap),
+
+        new ConstantFolding(&refMap, &typeMap),
+
+        new SimplifyControlFlow(&refMap, &typeMap),
+// NOTE end of repetition
+
+//        new FlightplanAnnotate(&refMap, &typeMap, options),
+//        new Flightplan(&refMap, &typeMap, options),
+
         new FrontEndLast(),
     };
 
diff --git a/frontends/p4/methodInstance.cpp b/frontends/p4/methodInstance.cpp
index ceaa6c0..1d47b7d 100644
--- a/frontends/p4/methodInstance.cpp
+++ b/frontends/p4/methodInstance.cpp
@@ -1,5 +1,6 @@
 /*
 Copyright 2013-present Barefoot Networks, Inc.
+Copyright 2020 University of Pennsylvania
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
